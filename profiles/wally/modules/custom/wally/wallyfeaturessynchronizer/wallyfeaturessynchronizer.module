<?php

/**
 * Implémentation du hook_form_FORM_ID_alter.
 */
function wallyfeaturessynchronizer_form_taxonomy_form_term_alter (&$form, &$form_state) {
  $form['#validate'][] = 'wallyfeaturessynchronizer_form_taxonomy_form_term_alter_validate';
}

/**
 * Validation du formulaire d'ajout/d'édition d'un terme taxonomique.
 */
function wallyfeaturessynchronizer_form_taxonomy_form_term_alter_validate (&$form, &$form_state) {
  $values = $form_state['values'];
  $bad_car = array('_', ' ', '\'');
  if ($form_state['values']['tid']) {
    $term = taxonomy_get_term($form_state['values']['tid']);
  }
  if (!$form_state['values']['tid'] || !isset($term->featid)) {
    $form_state['values']['featid'] = $values['vid'] .'_'. str_replace($bad_car, '-', strtolower($values['name']));
  }
}

/**
 * Implémentation du hook_schema_alter.
 */
function wallyfeaturessynchronizer_schema_alter (&$schema) {
  if ($schema['term_data']) {
    $schema['term_data']['fields']['featid'] = array(
      'type' => 'varchar',
      'length' => '255',
      'description' => 'An unique name used to synchronize features between instances of Wally.'
    );
  }
}

/**
 * Alter the object considered by features as default value to replace
 * the complete taxonomy terms by their IDs.
 * 
 * @param &$cached
 *   The unaltered default values object.
 */
function wallyfeaturessynchronizer_default_page_manager_handlers_alter (&$cached) {
  foreach ($cached as $component => $comp_infos) {
    $temp_conf = $cached[$component]->conf;
    $plugins = $temp_conf['access']['plugins'] ? $temp_conf['access']['plugins'] : array();
    foreach ($plugins as $plug_id => $plugin) {
      $settings = $plugin['settings'] ? $plugin['settings'] : array();
      foreach ($settings as $set_id => $setting) {
        if (is_array($setting) && sizeof($setting)>0) {
          foreach ($setting as $featid => $featid_infos) {
            if (sizeof(explode('_', $featid)) == 2) {
              $tid = _wallyfeaturessynchronizer_get_tid_from_featid($featid_infos);
              $temp_conf['access']['plugins'][$plug_id]['settings'][$set_id][$tid] = $tid;
              unset($temp_conf['access']['plugins'][$plug_id]['settings'][$set_id][$featid]);
            }
          }
        }
      }
    }
    $cached[$component]->conf = $temp_conf;
  }
}

/**
 * Implementation of hook_features_export_render() for page_manager_handlers.
 * 
 * @see features.ctools.inc
 */
function page_manager_handlers_features_export_render($module, $data, $export = 'normal') {
  ctools_include('export');
  $component = 'page_manager_handlers';
  $schema = ctools_export_get_schema($component);
  /*if (function_exists($schema['export']['to hook code callback'])) {
    $export = $schema['export']['to hook code callback']($data, $module);
    $code = explode("{\n", $export);
    array_shift($code);
    $code = explode('}', implode($code, "{\n"));
    array_pop($code);
    $code = implode('}', $code);
  }
  else {*/
    $code = '  $export = array();'."\n";dsm($data, 'data');
    foreach ($data as $object_name) {
      if ($object = _ctools_features_export_crud_load($component, $object_name)) {dsm($object, 'object');
        if (sizeof($object->conf['access']['plugins'])>0) {
          if ($export != 'normal') {
            _wallyfeaturessynchronizer_set_featid_from_object($object);
            break;
          }
        }dsm($object, 'object');dsm('coucou');
        $identifier = $schema['export']['identifier'];
        dsm(function_exists('_ctools_features_export_crud_export')?'func ok':'func nok');
        $code .= _ctools_features_export_crud_export($component, $object, '  ');
        $code .= "\n";
        $code .= "  \$export[" . ctools_var_export($object_name) . "] = \${$identifier};\n";
      }
    }
    $code .= '  return $export;';
  //}
dsm($code);
  return array($schema['export']['default hook'] => $code);
}

/**
 * Replace the taxonomy term ID by the complete term object.
 * 
 * @param &$object
 *   The object in which the replacement is done.
 */
function _wallyfeaturessynchronizer_set_featid_from_object (&$object) {
  $plugins = $object->conf['access']['plugins'];
  dsm($plugins, 'plugi');
  foreach ($plugins as $plug_id => $plugin) {
    $settings = $plugin['settings'] ? $plugin['settings'] : array();
    foreach ($settings as $set_id => $setting) {
      if (is_array($setting) && sizeof($setting)>0) {
        foreach ($setting as $tid => $tid_infos) {
          $term = taxonomy_get_term($tid);
          $plugins[$plug_id]['settings'][$set_id][$term->featid] = $term;
          unset($plugins[$plug_id]['settings'][$set_id][$tid]);
          $object->conf['access']['plugins'][$plug_id] = $plugins[$plug_id];
        }
      }
    }
  }
}

/**
 * Find the taxonomy term associated to a given featid. If no term is
 * found, a new taxonomy term is created.
 * 
 * @return
 *   The tid of the founded or created term.
 */
function _wallyfeaturessynchronizer_get_tid_from_featid($feat_term) {
  $terms = taxonomy_get_tree($feat_term->vid);
  $temp_term = new stdClass();
  
  foreach ($terms as $term) {
    if ($term->featid == $feat_term->featid) {
      $temp_term = $term;
    }
  }

  if (!isset($temp_term->tid)) {
    $array_feat_term = (array)$feat_term;
    taxonomy_save_term($array_feat_term);
    $temp_term = $feat_term;
  }
  
  return $temp_term->tid;
}
