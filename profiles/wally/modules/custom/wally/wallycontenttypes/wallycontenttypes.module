<?php

include_once('wallycontenttypes.features.inc');

/**
 * @defgroup wallycontenttypes Wally main module.
 * @{
   * 
 * In this module we define all wally specific content types & taxonomies
 * Also include all invocation for specific theme hook & theming preprocess
 * functions. 
 */
 

/**
 * Implementation of hook_perm().
 */
function wallycontenttypes_perm() {
  return array(
    'administer wallycontenttypes',
  );
}

/**
 *  Implémentation du hook_menu(); 
 */
function wallycontenttypes_menu() {
  $items = array();
  
  $items['admin/content/editcrop'] = array(
    'title' => t('Edit croping'), 
    'description' => t('Edit croping'), 
    'page callback' => 'wallycontenttypes_ajax_editcrop',
    'access arguments' => array('administer nodes'), 
    'type' => MENU_CALLBACK,
    'file' => 'includes/wallycontenttypes.node_form.inc',
  );
  
  $items['admin/wally/wallycontenttypes/settings'] = array(
    'title' => t('Wally Content Types Settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wallycontenttypes_page_admin_form'),
    'access arguments' => array('administer wallycontenttypes'),
    'description' => t('Allows administrators to set paramaters for this module to function properly.'),
    'file' => 'includes/wallycontenttypes.admin.inc',
  );

  return $items;
}

/**
 *  Implémentation du hook_theme(); 
 */
function wallycontenttypes_theme(&$var) {

  $path = drupal_get_path('module', 'wallycontenttypes');
  $base = array(
    'file' => 'theme.inc',
    'path' => "$path/theme",
  );
  
  return array(
    'wallyct_photoobject_slider' => $base + array(
      'arguments' => array("nodes" => NULL, "node" => NULL),
      'template' => 'wallyct_photoobject_slider',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_mainstory' => $base + array(
      'arguments' => array("mainstory" => NULL, "node" => NULL),
      'template' => 'wallyct_mainstory',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_embededobjects' => $base + array(
      'arguments' => array("embededobjects" => NULL, "node" => NULL),
      'template' => 'wallyct_embededobjects',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_photoobject' => $base + array(
      'arguments' => array("embededobject" => NULL),
      'template' => 'wallyct_photoobject',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_videoobject' => $base + array(
      'arguments' => array("embededobject" => NULL),
      'template' => 'wallyct_videoobject',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_digitalobject' => $base + array(
      'arguments' => array("embededobject" => NULL),
      'template' => 'wallyct_digitalobject',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_linkedobjects' => $base + array(
      'arguments' => array("linkedobjects" => NULL, "node" => NULL),
      'template' => 'wallyct_linkedobjects',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_teaser' => $base + array(
      'arguments' => array("text" => NULL, "length" => 200, "node" => NULL),
      'template' => 'wallyct_teaser',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_destinationlist' => $base + array(
      'arguments' => array("destinations" => NULL, "separator" => NULL, "prefix" => NULL, "suffix" => NULL),
      'template' => 'wallyct_destinationlist',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_linkedobjects' => $base + array(
      'arguments' => array("linkedobjects" => NULL, "node" => NULL),
      'template' => 'wallyct_linkedobjects',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_galleryphoto' => $base + array(
      'arguments' => array("node" => NULL),
      'template' => 'wallyct_galleryphoto',
      'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_editcrop' => $base + array(
      'arguments' => array("filepath" => NULL, "defaultvalues" => NULL),
      'template' => 'wallyct_editcrop',
      'preprocess functions' => array('wally_get_tpl_suggestions')
    ),
  );
}

function wallycontenttypes_theme_registry_alter(&$theme_registry) {
  $theme_registry['textfield']['function'] = 'wallycontenttypes_rubik_textfield';
  $theme_registry['textfield']['file'] = 'theme.inc';
  $theme_registry['textfield']['path'] = drupal_get_path('module', 'wallycontenttypes').'/theme';
}

/**
 * Implementation of hook_action_info().
 */
function wallycontenttypes_action_info() {
  $actions = array(
    'wallycontenttypes_publish_nodes' => array(
      'type' => 'node',
      'description' => t('Publish package'),
      'configurable' => FALSE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('insert', 'update'),
      ),
    ),
    'wallycontenttypes_unpublish_nodes' => array(
      'type' => 'node',
      'description' => t('Unpublish package'),
      'configurable' => FALSE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('insert', 'update'),
      ),
    ),
  );
  return $actions;
}

function wallycontenttypes_publish_nodes(&$node, $context = array()) {
  $node->status = 1;
  if ($node->field_autopublish && $node->field_autopublish[0]['value'] == 'No') {
    $node->field_autopublish[0]['value'] = 'Autopublish';
  }
}

function wallycontenttypes_unpublish_nodes(&$node, $context = array()) {
  $node->status = 0;
  if ($node->field_autopublish && $node->field_autopublish[0]['value'] == 'Autopublish') {
    $node->field_autopublish[0]['value'] = 'No';
  }
}

/**
 * Implementation of hook_node_operations().
 */
function wallycontenttypes_node_operations() {
  $operations = array(
    'wallycontenttypes_publish_nodes' => array(
      'label' => t('Publish package'),
      'callback' => 'node_mass_update',
      'callback arguments' => array('updates' => array('status' => 1, 'field_autopublish' => array(0 => array('value' => 'Autopublish')))),
    ),
    'wallycontenttypes_unpublish_nodes' => array(
      'label' => t('Unpublish package'),
      'callback' => 'node_mass_update',
      'callback arguments' => array('updates' => array('status' => 0, 'field_autopublish' => array(0 => array('value' => 'No')))),
    ),
  );
  return $operations;
}

/**
 * Implementation of hook_imagecache_actions().
 */
function wallycontenttypes_imagecache_actions() {
  $actions = array(
    'wallycontenttypes_wallycrop' => array(
      'name' => 'Wally crop',
      'description' => t('Perform a wallycrop action.'),
      'file' => 'includes/wallycontenttypes_actions.inc',
    ),
    'wallycontenttypes_cropcopy' => array(
      'name' => 'Copy of a Wally crop',
      'description' => t('Reuse the settings of a Wally crop and adapt them to another scale.'),
      'file' => 'includes/wallycontenttypes_actions.inc',
    ),
  );

  return $actions;
}

/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement task and task_handler plugins.
 */
function wallycontenttypes_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return 'plugins/'.$plugin;
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function wallycontenttypes_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){
  switch ($op) {

    case 'view':
      if (($node->type == 'wally_articlepackage' || 
           $node->type == 'wally_gallerypackage' ||
           $node->type == 'wally_pollpackage') && 
           !$node->DoNotPopulate) //DoNotPopulate is for wallyedit preview, since we give it a node already populated
      { 
        wallycontenttypes_packagepopulate($node);
        //$node->inlineobjects = $node->field_embededobjects_nodes;
        //wallycontenttypes_process_inline_objects($node);
      }
      break;
    case 'insert':
      if ($node->type == 'wally_articlepackage' ||
      $node->type == 'wally_gallerypackage' ||
      $node->type == 'wally_pollpackage'){
        module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');
        _wallycontenttypes_insertautopublish($node);
      }
      break;
    case 'presave' : 
      if ($node->type == 'wally_articlepackage' || 
        $node->type == 'wally_gallerypackage' ||
        $node->type == 'wally_pollpackage') {
          module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');
          _wallycontenttypes_addtaxonomywheninserted($node);
          _wallycontenttypes_checkautopublish($node);
      }
      break;

    case 'update' :
      module_load_include('inc', 'wallytoolbox', 'includes/wally.object-cache');
      if ($node->type == 'wally_articlepackage' || 
          $node->type == 'wally_gallerypackage' ||
          $node->type == 'wally_pollpackage') 
      {
        wallytoolbox_object_cache_clear($node->nid, $node->revision_uid);
        module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');
        _wallycontenttypes_insertautopublish($node);
      } elseif(($node->type == 'wally_textobject' ||
                $node->type == 'wally_audioobject' ||
                $node->type == 'wally_digitalobject' || 
                $node->type == 'wally_photoobject' || 
                $node->type == 'wally_videoobject' ||
                $node->type == 'wally_linkslistobject' ||
                $node->type == 'wally_pollobject' ||
                $node->type == 'poll') && 
                !$node->doNotPullUp) 
      {
        wallytoolbox_object_cache_clear($node->nid, $node->revision_uid);
        module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');
        _wallycontenttypes_addtaxonomywhenupdated($node);
      }
      wallytoolbox_object_referencer_cache_clear($node);
      break;
    
    case 'delete' :
      module_load_include('inc', 'wallytoolbox', 'includes/wally.object-cache');
      if ($node->type == 'wally_articlepackage' || 
          $node->type == 'wally_gallerypackage' ||
          $node->type == 'wally_pollpackage') 
      {
        wallycontenttypes_delete_orphans_objects($node); 
        wallytoolbox_object_cache_clear($node->nid, $node->revision_uid);
        module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');
        _wallycontenttypes_deletefromtempautopublish($node);
      } elseif( $node->type == 'wally_textobject' ||
                $node->type == 'wally_audioobject' ||
                $node->type == 'wally_digitalobject' || 
                $node->type == 'wally_photoobject' || 
                $node->type == 'wally_videoobject' ||
                $node->type == 'wally_linkslistobject' ||
                $node->type == 'wally_pollobject' ||
                $node->type == 'poll') 
      {
        wallytoolbox_object_cache_clear($node->nid, $node->revision_uid);
      }
      wallytoolbox_object_referencer_cache_clear($node);
      break;
  }
}

/**
 * Implementation of hook_prenodeapi().
 */
function wallycontenttypes_prenodeapi(&$form_state, $op){
  switch ($op) {
    case 'presave' :
      if($form_state['type'] == 'wally_articlepackage' ||
        $form_state['type'] == 'wally_gallerypackage' ||
        $form_state['type'] == 'wally_pollpackage') {
        module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');
        _wallycontenttypes_update_package_prenode_taxonomy_recursive($form_state[$form_state['type']], $form_state['profile_id']);
      }
      break;
  }
}

/**
 * Implementation of hook_wimprt_process_package().
 * Put the main object's taxonomy terms in the package
 */
function wallycontenttypes_wimprt_process_package($node, $dom, $log, $op, $importer) {
  if ($op == 'after_process') {
    if ($node->type == 'wally_articlepackage' ||
        $node->type == 'wally_gallerypackage' ||
        $node->type == 'wally_pollpackage') {
      module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');
      _wallycontenttypes_addtaxonomywheninserted($node);
    }
  }
}

/**
 *  Implémentation du hook_preprocess_page(); 
 */
function wallycontenttypes_preprocess_page(&$variables) {
  $suggestion = array();

  // For all Nodes types with a destination field.
  if (isset($variables['node']->field_destinations) && false) {
    $suggestion = wallycontenttypes_getpackagesuggestions(&$variables, 'page'); 
  }
  if(count($suggestion)) $variables['template_files'] = array_merge($suggestion, $variables['template_files']);
  
  $menu_item = menu_get_item();
  if ($menu_item['page_callback'] == 'page_manager_page_execute') {
    array_unshift($variables['template_files'], 'page-'.$menu_item['page_arguments'][0]);
  }
}

/**
 *  Implémentation du hook_preprocess_node(); 
 */
function wallycontenttypes_preprocess_node(&$variables) {
  $suggestion = array(); 

  // For all Nodes types with a destination field.
  if (isset($variables['node']->field_destinations[0])) {
    $suggestion = wallycontenttypes_getpackagesuggestions(&$variables, 'node'); 
  }
  if(count($suggestion)) $variables['template_files'] = array_merge($suggestion, $variables['template_files']);
}

/**
 *  Implémentation du hook_form_alter(); 
 */
function wallycontenttypes_form_alter(&$form, $form_state, $form_id){
  if (isset($form['type']) && isset($form['#node'])) {
    switch ($form_id) {
      case 'wally_photoobject_node_form':
        _wallycontenttypes_addcroppinglink($form, $form_state, $form_id);
        break;
      case 'wally_articlepackage_node_form':
      case 'wally_gallerypackage_node_form' :
      case 'wally_pollpackage_node_form':
        _wallycontenttypes_disabletaxonomy($form, $form_state, $form_id);
        break;
    }
  }
}

/**
 * Add a Edit Crop link to form.
 * 
 * In case of Photo Object editing, we need to show a "edit crop"
 * link. 
 * 
 * @param &$form
 *   The form currently build
 * @param $form_state 
 *   A keyed array containing the current state of the form.
 * @param $form_id 
 *   String representing the name of the form itself. Typically this is the name of the function that generated the form.
 *
 * @return
 *   Nothing
 */
function _wallycontenttypes_addcroppinglink(&$form, $form_state, $form_id) {
  $form['#after_build'][] = 'wallycontenttypes_addeditcroplink_after_build';
}

/**
 * call back to add edit crop link on Photo Object editing
 * 
 * Call back function used by after_build attribute to 
 * add an edit crop link into form.
 * 
 * Because, we're in an after-build process, cck_field could
 * be already relocated to a cck_fieldset.
 *
 * @param &$form
 *   The form currently build
 * @param $form_state 
 *   A keyed array containing the current state of the form.
 *
 * @return
 *   Nothing
 *   
 * @TODO: Need more intelligence, should be enabled when
 *   a file is uploaded.
 */
function wallycontenttypes_addeditcroplink_after_build(&$form, &$form_state) {
  module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');

  // Include the CTools tools that we need.
  ctools_include('ajax');
  ctools_include('modal');

  // Add CTools' javascript to the page.
  ctools_modal_add_js();

  // Create our own javascript that will be used to theme a modal.
  $edit_crop_style = array(
    'edit-crop-style' => array(
      'modalSize' => array(
        'type' => 'fixed',
        'width' => 500,
        'height' => 300,
        'addWidth' => 20,
        'addHeight' => 15,
      ),
      'modalOptions' => array(
        'opacity' => .5,
        'background-color' => '#000',
      ),
      'animation' => 'fadeIn',
      'modalTheme' => 'CToolsSampleModal',
      'throbber' => theme('image', ctools_image_path('ajax-loader.gif', 'ctools_ajax_sample'), t('Loading...'), t('Loading')),
    ),
  );

  drupal_add_js($edit_crop_style, 'setting');

  // Since we have our js, css and images in well-known named directories,
  // CTools makes it easy for us to just use them without worrying about
  // using drupal_get_path() and all that ugliness.
  ctools_add_js('ctools-ajax-sample', 'ctools_ajax_sample');
  ctools_add_css('ctools-ajax-sample', 'ctools_ajax_sample');

  $pseudo_nid = isset($form_state['cache name']) ? $form_state['cache name'] : $form['nid']['#value'];
  $nid_type = isset($form_state['cache name']) ? 'prenode' : 'node';

  $callback = 'admin/content/editcrop/'.$nid_type.'/'.$pseudo_nid.'/1';
  $callback .= isset($form_state['parents']) ? '/'.implode('/', $form_state['parents']) : '';

  $edit_crop_link = ctools_modal_text_button(t('Click here to edit croping informations'), $callback, '');
  
  $form['group_photo']['field_croping'][0]['#type'] = 'value';
  $form['group_photo']['field_croping'][0]['value']['#type'] = 'value';

  _wallycontenttypes_update_crop_state_value($form, $form_state);

  if (isset($form['#node']->field_photofile) && $form['group_photo']['field_photofile'][0]['fid']['#value'] == $form['#node']->field_photofile[0]['fid']) {
    $form['group_photo']['field_photofile'][0]['edit_croping']=array(
      '#weight' => $form['group_photo']['field_photofile'][0]['preview']['#weight']*1.1,
    	'#type' => 'markup',
  		'#value' => $edit_crop_link,
    );
  }

  return $form;
}

/**
 * Disable all taxonomy fields on package editing.
 * 
 * In case of package editing, all taxonomy/entities/persons/locations/...
 * are taken from the main object. So we disabled the edition for these
 * fields.
 * 
 * Because CCK fields didn't suppor the "disabled = true" attribute, and
 * because we must set all sub-element from a cck_field we add
 * an after_build callback function to the form. So all cck fields are
 * completly build.    
 *
 * @param &$form
 *   The form currently build
 * @param $form_state 
 *   A keyed array containing the current state of the form.
 * @param $form_id 
 *   String representing the name of the form itself. Typically this is the name of the function that generated the form.
 *
 * @return
 *   Nothing
 */
function _wallycontenttypes_disabletaxonomy(&$form, $form_state, $form_id){
  $form['#after_build'][] = 'wallycontenttypes_disabletaxonomy_after_build';
}

/**
 * call back to disable all taxonomy fields on package editing
 * 
 * Call back function used by after_build attribute to 
 * disabled all "taxonomy" from a package content types. 
 * 
 * Because CCK fields didn't suppor the "disabled = true" attribute, and
 * because we must set all sub-element from a cck_field we had to put 
 * a disabled attribute to all sub-element of the cck field. 
 * 
 * Because, we're in an after-build process, cck_field could
 * be already relocated to a cck_fieldset. So we have to 
 * seach recursivly for fields.
 *
 * @param &$form
 *   The form currently build
 * @param $form_state 
 *   A keyed array containing the current state of the form.
 *
 * @return
 *   Nothing
 */
function wallycontenttypes_disabletaxonomy_after_build(&$form, &$form_state) {
  module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');

  $fields = array(
    "field_locations",
    "field_markers",
    "field_entities",
    "field_persons",
    "field_tags",
    "field_free_tags"
  );

  foreach ($fields as $field) {
    // CCK field on the 1st level of $form
    if (isset($form[$field])) {
      _wallycontenttypes_mysnippetfixdisabled($form[$field]);
    } else {
      // Because we're in afterbuild function, fields could be already
      // relocated into cck fieldsets > $form['fiedset']['cckfield'] 
      foreach (element_children($form) as $k) {
        if (isset($form[$k][$field])) {
          _wallycontenttypes_mysnippetfixdisabled($form[$k][$field]);
        }
      }
    } 
  }
  return($form);
}

function wallycontenttypes_form_poll_view_voting_alter (&$form, &$form_state) {
  $form['choice']['#title'] = $form['#node']->title;
  $form['vote']['#submit'][] = 'wallycontentypes_update_poll_cache';
}

function wallycontenttypes_form_poll_cancel_form_alter (&$form, &$form_state) {
  $form['submit']['#submit'][] = 'wallycontentypes_update_poll_cache';
}

function wallycontentypes_update_poll_cache (&$form, &$form_state) {
  module_load_include('inc', 'wallytoolbox', 'includes/wally.object-cache');
  $node = $form['#node'];
  $nid = $node->nid;
  wallytoolbox_object_cache_clear($nid, $node->revision_uid);
  wallytoolbox_object_referencer_cache_clear($node);
}

function wallycontenttypes_form_wallyedit_form_fields_overview_form_alter(&$form, $form_state) {
  module_load_include('inc', 'wallyedit', 'includes/config_api');
  $flat_fields = wyditadmin_get_fields_flat($form['profile_id']['#value'], $form['type']['#value']);
  if (isset($flat_fields['field_editorialupdatedate'])) {
    $default_field = $flat_fields['field_editorialupdatedate'];
    $form['fields']['field_editorialupdatedate']['wallyedit'] = array(
      '#type' => 'select',
      '#options' => array(0 => t('Exclude'), 1 => t('Normal'), 4 => t('Checkbox')),
      '#default_value' => $default_field['display'] ? $default_field['display'] : 0,
    );
  }
}

function wallycontenttypes_form_wallyedit_form_node_edition_form_alter(&$form, &$form_state) {
  $pack_types = array('wally_articlepackage', 'wally_gallerypackage', 'wally_pollpackage');
  if (sizeof($form_state['parents']) == 1 && in_array($form_state['type'], $pack_types)) {
    array_unshift($form['#submit'], 'wallycontenttypes_form_wallyedit_form_node_edition_form_submit');

    // Editorial Update Date gestion
    // Replace the DateTime field with a checkbox
    $type_name = $form_state['type'];
    module_load_include('inc', 'wallyedit', 'includes/config_api');
    $flat_fields = wyditadmin_get_fields_flat($form_state['profile_id'], $type_name);
    if (is_array($flat_fields) && isset($flat_fields['field_editorialupdatedate']) && ($flat_fields['field_editorialupdatedate']['display'] == 4)) {
      $type = wydit_get_infos_type($type_name);
      $cck_fields = $type['fields'];
      if (isset($cck_fields['field_editorialupdatedate'])) {
        if (isset($cck_fields['field_editorialupdatedate']['display_settings']['parent']) && !empty($cck_fields['field_editorialupdatedate']['display_settings']['parent'])) {
          $edit_update_elem = &$form[$type_name][$cck_fields['field_editorialupdatedate']['display_settings']['parent']]['field_editorialupdatedate'];
        } else {
          $edit_update_elem = &$form[$type_name]['field_editorialupdatedate'];
        }

        $edit_update_elem[0]['#prefix'] = '<div style="display:none;">';
        $edit_update_elem[0]['#suffix'] = '</div>';
        $edit_update_elem[] = array(
          '#type' => 'checkbox',
          '#title' => t('Update Editorial Update Date'),
        );
      }
    }
  }
}

function wallycontenttypes_form_wallyedit_form_node_edition_form_submit(&$form, &$form_state) {
  $pack_types = array('wally_articlepackage', 'wally_gallerypackage', 'wally_pollpackage');
  if (in_array($form_state['type'], $pack_types)) {
    $type_name = $form_state['type'];
    module_load_include('inc', 'wallyedit', 'includes/config_api');
    $flat_fields = wyditadmin_get_fields_flat($form_state['profile_id'], $type_name);

    // Force update of the editorial update date
    if (($form_state['clicked_button']['#name'] == 'publish_global') && is_array($flat_fields) && isset($flat_fields['field_editorialupdatedate']) && ($flat_fields['field_editorialupdatedate']['display'] == 4) && $form_state['values'][$type_name]['field_editorialupdatedate'][1]) {
      $type = wydit_get_infos_type($type_name);
      $cck_fields = $type['fields'];
      $format = $cck_fields['field_editorialupdatedate']['widget']['input_format'];
      $form_state[$type_name]['#node']->field_editorialupdatedate[0]['value'] = gmdate($format);
      unset($form_state['values'][$type_name]['field_editorialupdatedate']);
    }
  }
}

/**
 * Alter delete form of a preset, do not allow to delete if another as a copy crop action based on this preset
 */
function wallycontenttypes_form_imagecache_ui_preset_delete_form_alter(&$form, $form_state) {
  $db_copy_crops = db_query("SELECT * FROM {imagecache_action} WHERE action = 'wallycontenttypes_cropcopy'");
  while ($res_copy_crop = db_fetch_array($db_copy_crops)) {
    $dependent_presetnames = '';
    $settings = unserialize($res_copy_crop['data']);
    if ($settings['copied_preset'] == $form['presetid']['#value']) {
      $dependent_preset = imagecache_preset($res_copy_crop['presetid']);
      $dependent_presetnames[] = $dependent_preset['presetname'];
    }
  }

  if (!empty($dependent_presetnames)) {
    drupal_set_message(t('Some presets have copy crop actions defined following this preset (concerned preset(s) : !preset_list)', array('!preset_list' => implode(', ', $dependent_presetnames))), 'error');
    drupal_goto('admin/build/imagecache');
  }
}

/**
 * Implementation of hook_schema_alter()
 * Add some indexes in tables
 */
function wallycontenttypes_schema_alter(&$schema) {
  if (isset($schema['content_field_externalreference'])) {
    $schema['content_field_externalreference']['indexes']['field_externalreference_value'] = array('field_externalreference_value');
  }
  if (isset($schema['files'])) {
    $schema['files']['indexes']['Idx_filepath'] = array('filepath');
  }
}

function wallycontenttypes_add_indexes(&$ret = array()) {
  db_add_index($ret, 'content_field_externalreference', 'field_externalreference_value', array('field_externalreference_value'));
  db_add_index($ret, 'files', 'Idx_filepath', array('filepath'));
}

/**
 * Insert additional template suggestions to wally specific theme functions.
 * This preprocess function could be set by any hook_theme.
 *
 * @param $vars
 *   An array of variables to pass to the theme template.
 * @param $hook
 *   The name of the template being rendered.
 */
function wally_get_tpl_suggestions(&$variables, $hook) {
  $suggestion = wallycontenttypes_getpackagesuggestions($variables, $hook);
  if(count($suggestion)) $variables['template_files'] = array_merge($suggestion, $variables['template_files']);
}

/** 
 * Load related nodes into package object via nodepi - "op view". 
 * 
 * When a Wally specific node is loaded, this hook will load all the extra 
 * nodes from all the node reference fields.
 * 
 * Specific wally fields supported:
 *  
 * - NID (node reference) specific link ( NODE -> NODE ).
 *   - field_mainstory: Load the Mainstory text node. Load extra "types" into mainstory node.
 *   - field_linkedobjects: Load all the linked objects (any type).
 *   - field_embededobjects: Load all the embeded objects (any type).
 * 
 * - TID (Taxonomy field) specific link ( NODE -> TAXONOMY -> NODE ). 
 *   - field_authors: Load the Persons content type for authors.
 *   - field_locations: Load the Location content type for locations.
 *   - field_entities: Load the entity content type for entities.
 *   - field_persons: Load the Persons content type for persons.
 *
 * @param: &$node
 *   The node that will be inspected for node/taxonomy reference
 * @param: $op
 *   Nodeapi operation
 * 
 * @return Nothing but modify the $node
 */

function wallycontenttypes_packagepopulate(&$node, $op = '', $reset_cache = FALSE) {
  // Avoid infinite loop
  if ((isset($node->parents) && !in_array($node->nid, $node->parents)) || !isset($node->parents)) {
    if (variable_get('wallycontenttypes_packagepopulate_cache', 1) == 1) {
      module_load_include('inc', 'wallytoolbox', 'includes/wally.object-cache');
      if (!isset($node->view)) {
        $node->view->name = '';
        $node->view->current_display = '';
      }
      $cached_node = wallytoolbox_object_cache_get($node->nid, $node->revision_uid, $node->view->name, $node->view->current_display);
      if (!$cached_node || $reset_cache) {
        $cleaned_node = wallycontenttypes_clean_node($node);
        wallycontenttypes_fieldNID($cleaned_node);
        wallycontenttypes_fieldTID($cleaned_node);
        wallytoolbox_object_cache_set($cleaned_node);
      } else {
        $cleaned_node = $cached_node;
      }
      wallycontenttypes_restore_node($node, $cleaned_node);
    } else {
      $cleaned_node = wallycontenttypes_clean_node($node);
      wallycontenttypes_fieldNID($cleaned_node);
      wallycontenttypes_fieldTID($cleaned_node);
      wallycontenttypes_restore_node($node, $cleaned_node);
    }
  }
}

function wallycontenttypes_process_inline_objects($node) {
  if (isset($node->inlineobjects) && !empty($node->inlineobjects)) {
    $inline_objects = $node->inlineobjects;
    if ($node->type == 'wally_articlepackage') {
      $text = &$node->field_mainstory_nodes[0]->field_textbody[0]['value'];
      $matches = array();
      $regex = '@<ccix:inline(.*)\/>@iU';
      preg_match_all($regex, $text, $matches);
      if (!empty($matches[1])) {
        foreach ($matches[1] as $id => $match) {
          $found_args = explode(' ', trim($match));
          $args = array();
          foreach ($found_args as $found_arg) {
            $temp_arg = explode('=', $found_arg);
            $args[$temp_arg[0]] = str_replace(array('"', "'"), '', $temp_arg[1]);
          }

          foreach ($inline_objects as $inline_object) {
            if ($inline_object->field_externalreference[0]['value'] == $args['extref']) {
              $text = str_replace($matches[0][$id], node_view($inline_object), $text);
            }
          }
        }
      }
    }
  }
}

/**
 * Implementation of hook_cron
 * Check once a day(at midnight) if the temporary table is build
 * if not build it
 * Publish or Unpublish node based on information in temporary table.
 */
function wallycontenttypes_cron() {
  $return = '<b>'.t('Run on !date :', array('!date' => date('Y-m-d H:i:s'))).'</b></br>';

  //Reset the temp table once a day
  $today = strtotime(date('Y-m-d'));
  $last_run_timestamp = wally_variable_get('wallycontenttypes_embargo_last_run', time() - 86400);

  if ($last_run_timestamp < $today) {
    wally_variable_set('wallycontenttypes_embargo_last_run', $today);

    // If Memcached is used we don't try to flush old packages, Memcached do it itself.
    if (!function_exists('memcache_variable_set') && variable_get('wallycontenttypes_packagepopulate_cache', 1)) {
      $flush_time_days = variable_get('wallycontenttypes_packagepopulate_flush_frequency', 7);
      if ($flush_time_days && !empty($flush_time_days)) {
        $return .= '<b>'.t('Cached contents flush :').'</b></br>';

        if ($removed_contents = db_fetch_array(db_query("SELECT COUNT(*) FROM {cache_wally_object} WHERE created < NOW() - INTERVAL %d DAY", $flush_time_days))) {
          if ($removed_contents['COUNT(*)'] > 0) {
            if (db_query("DELETE FROM {cache_wally_object} WHERE created < NOW() - INTERVAL %d DAY", $flush_time_days)) {
              $return .= t('!num_files cached contents removed.', array('!num_files' => $removed_contents['COUNT(*)']));
            } else {
              $return .= t('SQL error during cached contents removal.');
            }
          } else {
            $return .= t('No cached contents to remove.');
          }
        } else {
          $return .= t('SQL error during cached contents count.');
        }
        $return .= '</br>';
      }
    }

    if (db_table_exists('wallycontenttypes_temp_nodetopublish')) {
      db_query("DELETE FROM {wallycontenttypes_temp_nodetopublish}");
      //We need to build the table

      $results = db_query("SELECT DISTINCT n.nid, n.status, cfe.field_embargodatetime_value, cfu.field_unpublishdate_value
              					   FROM {node} n 
              					   LEFT JOIN {content_field_embargodatetime} cfe ON cfe.nid = n.nid 
              					   LEFT JOIN {content_field_unpublishdate} cfu ON cfu.nid = n.nid
              					   LEFT JOIN {content_field_autopublish} auto ON auto.nid = n.nid
              					   WHERE (
              					     (DATE_FORMAT(cfe.field_embargodatetime_value,'%Y-%m-%%d')) = CURDATE() 
              					   OR 
              					     (DATE_FORMAT(cfu.field_unpublishdate_value,'%Y-%m-%%d') = CURDATE())
              					   )
              					   AND (n.type = 'wally_gallerypackage' OR n.type = 'wally_articlepackage')
              					   AND auto.field_autopublish_value = 'Autopublish' 
              					   ");

      while ($obj = db_fetch_object($results)){
        drupal_write_record('wallycontenttypes_temp_nodetopublish', $obj);
      }
    }
  }

  if (db_table_exists('wallycontenttypes_temp_nodetopublish')) {
    $return .= '<b>'.t('Autopublish :').'</b></br>';

    //look at the node who their umbargo date or unpublish date are lower than current time
    $result = db_query("SELECT *
                  			FROM {wallycontenttypes_temp_nodetopublish}
                  			WHERE (
                  		    (field_embargodatetime_value < UTC_TIMESTAMP() AND field_embargodatetime_value IS NOT NULL)
                  			OR
                  		  	(field_unpublishdate_value < UTC_TIMESTAMP() ANd field_unpublishdate_value IS NOT NULL) 
                  			)");
    while ($obj = db_fetch_object($result)) {
      //@todo remove this to get real timezone of the fields
      if (module_exists('date_timezone')) {
        $zones = date_timezone_names(FALSE, TRUE);
        $timezone = $zones[variable_get('date_default_timezone_name', 0)];
      } else {
        $zones = _system_zonelist();
        $timezone = $zones[variable_get('date_default_timezone', 0)];
      }

      //node to publish
      if ($obj->field_embargodatetime_value && $obj->status != 1) {
        if ($form_date = date_make_date($obj->field_embargodatetime_value, 'UTC')) {
          $form_date = (object)date_timezone_set($form_date, timezone_open($timezone));
          $form_date = unserialize(serialize($form_date));
          $safe_embargo_date = $form_date->date;
          if (strtotime($safe_embargo_date) < time()) {
            $node = node_load(array('nid' => $obj->nid));
            node_publish_action($node);
            
            //We need to set the publication date related to the embargo
            
            $type = wydit_get_infos_type($node->type);
            $cck_fields = $type['fields'];
            $format = $cck_fields['field_publicationdate']['widget']['input_format'];
            $node->field_publicationdate[0]['value'] = gmdate($format,strtotime($node->field_embargodatetime[0]['value']));
             node_save($node);
            $return .= t('Node !nid published', array('!nid' => $node->nid)).'</br>';
            
            
            $form_date = date_make_date($obj->field_unpublishdate_value, 'UTC');
            $form_date = (object)date_timezone_set($form_date, timezone_open($timezone));
            $form_date = unserialize(serialize($form_date));
            $safe_unpublish_date = $form_date->date;
            if(date("d-m-Y",strtotime($safe_unpublish_date))==date("d-m-Y")){
            	$still_need_this_row=TRUE;
            }
            
          }
        }
        
        
      }
      
      //node to unpublish
      if ($obj->field_unpublishdate_value && $obj->status != 0) {
        if ($form_date = date_make_date($obj->field_unpublishdate_value, 'UTC')) {
          $form_date = (object)date_timezone_set($form_date, timezone_open($timezone));
          $form_date = unserialize(serialize($form_date));
          $safe_unpublish_date = $form_date->date;
          if (strtotime($safe_unpublish_date) < time()) {
            $node = node_load(array('nid' => $obj->nid));
            node_unpublish_action($node);
            cckdestinations_force_dnc($node);
            node_save($node);
            $return .= t('Node !nid unpublished', array('!nid' => $node->nid)).'</br>';
          }
        }
      }
      if($still_need_this_row==TRUE){      	 
      	db_query("UPDATE {wallycontenttypes_temp_nodetopublish} SET status = 1 WHERE nid = %d", $obj->nid);
      }else{
      	//delete node from the temp table
      	db_query("DELETE FROM {wallycontenttypes_temp_nodetopublish} WHERE nid = %d", $obj->nid);
      	 
      }
    }

    $return .= '</br>';
  }

  print $return;
}

/**
 * Remove all unnecessery fields from the node before it is
 * populated.
 * 
 * @param $node
 *   The node that will be populated.
 * 
 * @return
 *   The cleaned node.
 */
function wallycontenttypes_clean_node($node) {
  $cleaned_node = new Stdclass;
  $cleaned_node->nid = $node->nid;
  $cleaned_node->revision_uid = $node->revision_uid;
  $cleaned_node->view = isset($node->view) ? $node->view : NULL;
  $cleaned_node->type = isset($node->type) ? $node->type : NULL;
  $cleaned_node->parents = isset($node->parents) ? $node->parents : NULL;
  
  $node_content_types = content_types($node->type);
  
  foreach ($node_content_types['fields'] as $field_name => $field) {
    if ($field['type'] == 'content_taxonomy' || $field['type'] == 'nodereference') {
      $clean_field = array();
      $clean_field = $node->$field_name;
      $clean_field['type'] = $field['type'];
      $clean_field['name'] = $field_name;
      $cleaned_node->$field_name = $clean_field;
    }
  }

  return $cleaned_node;
}

/**
 * Restore the node after it has been populated so that the result
 * can be returned as a clean node.
 * 
 * @param &$node
 *   The node to be restored.
 * @param $cleaned_node
 *   The populated node.
 */
function wallycontenttypes_restore_node(&$node, $cleaned_node) {
  $cleaned_node = (array)$cleaned_node;
  unset($cleaned_node['nid']);
  unset($cleaned_node['revision_uid']);
  unset($cleaned_node['view']);
  unset($cleaned_node['type']);
  
  foreach ($cleaned_node as $field_name => $field) {
    if (isset($field['type']))
      unset($cleaned_node[$field_name]);
  }
  
  $node = (array)$node;
  $node = array_merge_recursive($node, $cleaned_node);
  $node = (object)$node;
}

/**
 * Process Node Reference fields in for populate node.
 */
function wallycontenttypes_fieldNID(&$node) {
	foreach ($node as $field_name => $field) {
    if (is_array($field) && $field['type'] == 'nodereference' && $field['name'] != 'field_internal_link') {
      $new_field_name = $field_name.'_nodes';
      $parents_nids = isset($node->parents) ? $node->parents : array();
      $parents_nids[] = $node->nid;
      $node->$new_field_name = wallycontenttypes_fieldnodeload($field_name, $parents_nids, $field);
    }
	}
	return $node;
}

/**
 * Process Content Taxonomy fields for populate node.
 */
function wallycontenttypes_fieldTID(&$node) {
  $convert_types = array(
    'field_authors' => 'wally_persontype',
    'field_locations' => 'wally_locationtype',
    'field_entities' => 'wally_entitytype',
    'field_persons' => 'wally_persontype',
  );

  if(isset($node)) {
    foreach ($node as $field_name => $field) {
      if (is_array($field) && isset($field['type']) && $field['type'] == 'content_taxonomy' && array_key_exists($field['name'], $convert_types)) {
        $type = $convert_types[$field['name']];
        $new_field_name = $field_name.'_nodes';
        $node->$new_field_name = wallycontenttypes_fieldTIDload($field_name, $field, $type);
      }
    }
  }
  return $node;
}

/**
 * Process all taxonomy reference and return an array of node
 */
function wallycontenttypes_fieldTIDload($field, $values, $type = NULL) {
  $r = array();
  $tids = array();  

  foreach ($values as $value => $tid2load) {
    if (is_array($tid2load) && isset($tid2load['value']) && $tid2load['value']) {
      $tids[] = $tid2load['value']; 
    }
  }
  $results = (count($tids)) ? wallytoolbox_taxonomy_get_nodes($tids, 'or', 0, false, $type) : array(); 
  foreach ($results as $value => $node2load) {
    $r[$value] = node_load($node2load);
    if (empty($r[$value])) {
      unset($r[$value]); 
    }
  }
  return $r; 
}

/**
 * Process all node reference fields and return array of node
 */
function wallycontenttypes_fieldnodeload($field, $parent_nids, $values = NULL) {
  $r = array();
  foreach ($values as $value => $node2load) {
    if (is_numeric($value)) {
      $tmp_node = node_load($node2load['nid']);
      module_load_include('inc', 'wallytoolbox', 'includes/wallytoolbox.helpers');
      if (wallytoolbox_check_is_node($tmp_node)) {
        $r[$value] = $tmp_node;
        $r[$value]->parents = $parent_nids;

        // Render the node.
        if (!empty($r[$value])) {
          // $r[$value] = node_build_content($r[$value]);
          // drupal_render($r[$value]->content);
          if (variable_get('wallycontenttypes_packagepopulate_recursive', 1)) {
            wallycontenttypes_packagepopulate($r[$value]);
          }
        } else {
          unset($r[$value]); 
        }
      }
    }
  } 
  return $r; 
}
   
/**
 * Get nid from packages who reference the current node
 * 
 * @param $node
 *   Node currently processed(TextObject, AudioObject, DigitalObject,PhotoObject, Videoobject, PollObject)
 *
 * @return
 *   Array() of array() of nid
 */
function _wallycontenttypes_getpackagesid($node){
  $rows = array(); 
  
  if($node->type=='wally_textobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_articlepackage} WHERE field_mainstory_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  }
  elseif($node->type=='wally_audioobject' || $node->type=='wally_digitalobject' || $node->type=='wally_photoobject' || $node->type=='wally_videoobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_gallerypackage} WHERE field_mainobject_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  }
  elseif($node->type=='wally_pollobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_pollpackage} WHERE field_mainpoll_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  }
  return $rows;
}

/**
 * Sort an array of Wally objects in the various objects types.
 */
function wallycontenttypes_sort_embededobjects($embededobjects, $sort_order = array()) {
  if (empty($sort_order)) {
    $sort_order = array(
      'wally_photoobject',
      'wally_videoobject',
      'wally_audioobject',
      'wally_digitalobject',
    );
  }
  
  $return = array();
  
  foreach ($sort_order as $key_elem)
    $return[$key_elem] = array();
  
  foreach ($embededobjects as $embededobject)
    $return[$embededobject->type][] = $embededobject;
  
  return $return;
}

/**
 * Build all the page/node suggestions template for a node of type "package"
 * of any content type with Destinations information.   
 *
 *  Wally specific suggestions are (for pages):  
 * 
 *  - page_{destinations_terms_underscore_separated}.tpl.php
 *  - page_{destinations_terms_underscore_separated}_{node_type}.tpl.php
 *  - page_{destinations_terms_underscore_separated}_{node_type}_{package_layout}.tpl.php
 *  - page_{node_type}_{package_layout}.tpl.php
 *  - page_{node_type}.tpl.php
 *  - page.tpl.php
 * 
 *  Wally specific suggestions are (for nodes):  
 * 
 *  - node-{node_type}.tpl.php
 *  - node_{destinations_terms_underscore_separated}.tpl.php
 *  - node_{destinations_terms_underscore_separated}_{node_type}.tpl.php
 *  - node_{destinations_terms_underscore_separated}_{node_type}_{package_layout}.tpl.php
 *  - node_{node_type}_{package_layout}.tpl.php
 *  - node_{node_type}.tpl.php < node.tpl.php
 *
 *  Wally specific suggestions are (other - types):  
 * 
 *  - {type}-{node_type}.tpl.php
 *  - {type}_{destinations_terms_underscore_separated}.tpl.php
 *  - {type}_{destinations_terms_underscore_separated}_{node_type}.tpl.php
 *  - {type}_{destinations_terms_underscore_separated}_{node_type}_{package_layout}.tpl.php
 *  - {type}_{node_type}_{package_layout}.tpl.php
 *  - {type}_{node_type}.tpl.php < node.tpl.php
 * 
 * @param $variables
 *   Templating variables
 * @param $type
 *   Prefix added to suggestions (default = page). Could be "page" or "node".
 * 
 * @return 
 *   Array of suggestion pages templates.
 */
function wallycontenttypes_getpackagesuggestions(&$variables, $type="page") {
  $destinations = array();
  $suggestion = array(); 
  $tax_children = array(); 
  $vid=variable_get('wallymport_destinationpath',null);
  $path = ""; 
  $package_layout = (isset($variables['node'])) ? wallycontenttypes_getpackagelayout($variables['node']) : NULL ; 

  // For a node, destination is taken on the 1st destination. 
  if (isset($variables['node']->field_destinations[0]['tid'])) {
    $destinations = array($variables['node']->field_destinations[0]['tid']);
  }

  (isset($variables['node']->type)) ? $suggestion[] = $type . '_' . strtolower($variables['node']->type) : NULL ;
  
  if ($variables['teaser'] && $variables['node']->teaser) $suggestion[] = $type . '_' . strtolower($variables['node']->type) . '_teaser';
 
  if ($package_layout) $suggestion[] = $type . '_' . strtolower($variables['node']->type) . '_' . $package_layout;

  if (count($destinations)) {
    $destination = $destinations[0];
    $tax_children = taxonomy_get_parents_all($destination, $vid);
    $count = count($tax_children);
    for ($i = $count-1; $i >= 0; $i--) {
      ($i == $count-1) ? $path .= strtolower($tax_children[$i]->name) : $path .= "_".strtolower($tax_children[$i]->name);
      if ($type) $suggestion[] = $type . '_' . $path;
      if (isset($variables['node']->type)) $suggestion[] = $type . '_' . $path . '_' . strtolower($variables['node']->type);
      if ($package_layout) $suggestion[] = $type . '_' .$path . '_' . strtolower($variables['node']->type) . '_' . $package_layout;
    }
  }

  if ($type == 'panels_pane') {
    $suggestion = isset($variables['classes']) ? explode(' ',$variables['classes']) : array();
    array_unshift($suggestion, 'panels-page');
  }

  return $suggestion;  
}

/**
 * Extract page layout information from the node. 
 *
 * @param $node
 *   The node currently processed
 *
 * @return 
 *   The Package layout as a string or NULL.
 */
function wallycontenttypes_getpackagelayout($node) {
  if (isset($node->field_packagelayout)) {
    $package_layout = taxonomy_get_term($node->field_packagelayout[0]["value"]);
    $package_layout = strtolower(str_replace(' ', '_', trim($package_layout->name)));
  } else {
    $package_layout = NULL;
  }
  return $package_layout; 
}

/**
* This function is called in the nodeapi hook, op 'delete if the node is a package.
* Its purpose is to delete the orphan objects that would be left behind when the parent is deleted.
* @param: $node
* The parent being deleted.
* @return Nothing but delete the orphans.
*/
function wallycontenttypes_delete_orphans_objects($node){
  $nids = array();
  switch ($node->type){
    case 'wally_articlepackage':
      $main_object_type = 'field_mainstory';
      break;
    case 'wally_gallerypackage':
      $main_object_type = 'field_mainobject';
      break;
    case 'wally_pollpackage':
      $main_object_type = 'field_mainpoll';
      break;
    default:
      $main_object_type = FALSE;
  }
  if ($main_object_type) {
    $main_object = $node->$main_object_type;
    $nids[] = $main_object[0]['nid'];
  }
  if (isset($node->field_embededobjects) && is_array($node->field_embededobjects)) {
    foreach($node->field_embededobjects as $emobject){
      if($emobject['nid']!= NULL && !in_array($emobject['nid'], $nids)){
        $nids[] = $emobject['nid'];
      }
    }
  }
  if (isset($node->field_linkedobjects) && is_array($node->field_linkedobjects)) {
    foreach($node->field_linkedobjects as $lnobject){
      if($lnobject['nid']!= NULL && !in_array($lnobject['nid'], $nids)){
        $nids[] = $lnobject['nid'];
      }
    }
  }
  foreach($nids as $nid){
    $child = node_load($nid);
    $parents = wallytoolbox_get_node_by_reference($child);
    foreach($parents as &$parent) {
      $parent = $parent['nid'];
    }
    if (count($parents) == 1 && in_array($node->nid, $parents)){
      node_delete($nid);
    }
  }
}

/**
 * @} End of "defgroup wallycontenttypes".
 */
