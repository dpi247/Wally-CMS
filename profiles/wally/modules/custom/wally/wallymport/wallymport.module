<?php
/**
 * @defgroup wallymport Wally Import Core Functions
 * @{
 * In this module we define core functions of wally xml import module.  
 * Do not put field specific functions or generic helpers functions here. 
 */

module_load_include('inc', 'wallymport', 'includes/wallymport.fields');
module_load_include('inc', 'wallymport', 'includes/wallymport.fieldshelpers');

/**
 * Implementation of hook_perm().
 */
function wallymport_perm() {
  return array(
    'administer wallymport',
  );
}

/**
 * Implementation of hook_menu().
 */
function wallymport_menu() {
  $items = array();
  
  //Admin settings Page
  $items['admin/wally/wallymport/settings'] = array(
    'title'            => t('Wally Import Settings'),
    'page callback'    => 'wallymport_page_admin',
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to set paramaters for this module to function properly.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  $items['admin/wally/wallymport/settings/general'] = array(
    'title'            => t('General'),
    'page callback'    => 'wallymport_page_admin',
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to set paramaters for this module to function properly.'),
    'file'             => 'includes/wallymport.admin.inc',
    'weight'           => -3,
    'type'             => MENU_DEFAULT_LOCAL_TASK,
  );
  
  //Page to create an importer
  $items['admin/wally/wallymport/settings/add'] = array(
    'title'            => t('Create importer'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('wallymport_page_importer_form'),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to create a new importer.'),
    'file'             => 'includes/wallymport.admin.inc',
    'type'             => MENU_LOCAL_TASK,
  );
  
  //Page to edit an importer
  $items['admin/wally/wallymport/settings/edit/%'] = array(
    'title'            => t('Edit importer'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('wallymport_page_importer_form', 5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to edit an importer.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  //Page to look at the logs of an importer
  $items['admin/wally/wallymport/settings/cronlog/%'] = array(
    'title'            => t('Importer CRON logs'),
    'page callback'    => 'wallymport_page_importer_cron_logs',
    'page arguments'   => array(5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to see importer CRON logs.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  //Page to look at the logs of an importer
  $items['admin/wally/wallymport/settings/log/%'] = array(
      'title'            => t('Importer logs'),
      'page callback'    => 'wallymport_page_importer_logs',
      'page arguments'   => array(5),
      'access arguments' => array('administer wallymport'),
      'description'      => t('Allows administrators to see importer logs.'),
      'file'             => 'includes/wallymport.admin.inc',
  );
  
  //Page to delete an importer
  $items['admin/wally/wallymport/settings/delete/%'] = array(
    'title'            => t('Delete importer'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('wallymport_page_importerdelete_form', 5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to delete an importer.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  //Page with the links to the folders of the importer 
  $items['admin/wally/wallymport/settings/links/%'] = array(
    'title'            => t('Packages links'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('wallymport_page_links_form', 5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Display download links for imported packages.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  $items['wallymport/process_folder/%'] = array(
    'title'            => t('Run XML Import'),
    'description'      => t('Run data import'),
    'page callback'    => 'wallymport_check_process_folder',
    'page arguments'   => array(2),
    'access callback'  => TRUE,
    'type'             => MENU_CALLBACK,
  );
  
  $items['wallymport/process_file/%/%/run'] = array(
    'title'            => t('Run one XML Import'),
    'description'      => t('Run one import'),
    'page callback'    => 'wallymport_check_process_file',
    'page arguments'   => array(2,3),
    'access callback'  => TRUE,
    'type'             => MENU_CALLBACK,
  );

  $items['wallymport/post/%'] = array(
    'page callback'    => 'wallymport_post',
    'access callback'  => TRUE,
    'page arguments'   => array(2),
    'type'             => MENU_CALLBACK,
  );

  $items['wallymport/destinations_items'] = array(
    'title'            => t('Return a XML list of all available destinations'),
    'description'      => t('Return a XML list of all available destinations'),
    'page callback'    => 'wallymport_page_destinations_items',
    'access callback'  => TRUE,
    'type'             => MENU_CALLBACK,
  );
  
  $items['wallymport/test'] = array(
  	'title'           => 'test',
    'page callback'   => 'wallymport_page_test',
    'access arguments' => array('administer wallymport'),
    'type'            => MENU_NORMAL_ITEM,
  );
  
  return $items;
}
/**
 * Implementation of hook_cron().
 */ 
function wallymport_cron(){
  $list = db_query('SELECT name, data FROM {ctools_object_cache} WHERE name LIKE "wallymport_preview_%" AND updated < %d', time() - 3600);
  $return = array();
  while ($elem = db_fetch_array($list)) {
    $data = unserialize($elem['data']);
    foreach ($data[$data['type']]['#node']->field_embededobjects_nodes as $embed) {
      if ($embed->type == 'wally_photoobject' && isset($embed->field_photofile[0]))
        wallytoolbox_delete_photofile($embed->field_photofile[0]);
    }
    
    db_query('DELETE FROM {ctools_object_cache} WHERE name = %d', $elem['name']);
    $return[] = 'Preview cache deleted for : '.$elem['name'].' on '.date('Y-m-d H:i:s', time());
  }
  if (empty($return)){
    $return = 'No deletion done on '.date('Y-m-d H:i:s', time());
  }
  print_r($return);
  //Run wallymport cron.
  if (db_table_exists('wallymport_importer')){
    //Sélectionne les importeurs dont leur exécutions remonte à plus longtemps par rapport à leur cron_frequency.
    $importer_to_process = db_query("SELECT wi.*
    								 FROM {wallymport_importer} wi
    								 WHERE wi.processed_by_cron = 1 
    								 AND (SELECT ((wi2.cron_timestamp + wi2.cron_frequency))
    								 	  FROM {wallymport_importer} wi2
    								 	  WHERE wi.iid = wi2.iid) < %d", time());
    while ($importer = db_fetch_object($importer_to_process)){
      $return = wallymport_check_process_folder($importer->name);
      if (!$return['error']){
        $importer->cron_timestamp = time();
      }
      $return['date'] = time();
      drupal_write_record('wallymport_importer', $importer, array('iid'));
    }
  }
}

/*
 * Implementation of hook_theme().
 */
function wallymport_theme(){
  $path = drupal_get_path('module', 'wallymport');

  $base = array(
    'file' => 'theme.inc',
    'path' => $path."/theme",
  );
  $theme_functions = array(
    'wallymport_logs' => $base + array(
      'arguments' => array('log' => array()),
    ),
  );
  return $theme_functions;
}
/*
* Implementation of hook_views_api().
*/
function wallymport_views_api() {
  return array(
    'api'  => 2.0,
	'path' => drupal_get_path('module', 'wallymport') . '/plugins/views',
  );
}
/**
 * Create a XML document containing all available destinations.
 * The structure of the XML follows packages.xsd.
 * 
 * <xsd:complexType name="DestinationsItem">
 *   <xsd:sequence>
 *     <xsd:element name="DestinationPath" type="xsd:string" />
 *   </xsd:sequence>
 *   <xsd:attribute name="DestinationRank" type="xsd:string" use="required" />
 *   <xsd:attribute name="Position" type="xsd:string" />
 *   <xsd:attribute name="DocumentLayout" use="required" type="xsd:string" />
 * </xsd:complexType>
 * 
 * @return
 *   The XML document as a string.
 */
function wallymport_page_destinations_items(){
  $array_dests = wallytoolbox_destinations_items_array();
  $dom_dests = new DOMDocument('1.0', 'UTF-8');

  $destinations = $dom_dests->createElement('Destinations');
  $destinations = $dom_dests->appendChild($destinations);

  foreach ($array_dests as $tid => $term_infos) {
    $term = wallytoolbox_taxonomy_get_path_by_tid_or_term($tid);
    $term = strtoupper($term);
    foreach ($term_infos as $target_name => $target_infos) {
      foreach ($target_infos as $layout_name => $layout_infos) {
        foreach ($layout_infos as $rank_elem => $true_value) {
          $destination = $dom_dests->createElement('Destination');
          $destination = $destinations->appendChild($destination);
          
          $destination->setAttribute('tid', $tid);
          $destination->setAttribute('Position', $target_name);
          $destination->setAttribute('DocumentLayout', $layout_name);
          $destination->setAttribute('DestinationRank', $rank_elem);
          
          $destination_path = $dom_dests->createElement('DestinationPath');
          $destination_path = $destination->appendChild($destination_path);
          $destination_path_text = $dom_dests->createTextNode($term);
          $destination_path->appendChild($destination_path_text);
        }
      }
    }
  }
  
  print $dom_dests->saveXML(); 
}

/**
 * Check if Wallymport can process folder.
 * 
 * @param $importer_name
 * The importer who will process the file
 * 
 * @return
 *   Response about the success or failure of import.
 */
function wallymport_check_process_folder($importer_name) {
  // Try to allocate enough time to run import process.
  if (function_exists('set_time_limit')) {
    @set_time_limit(60);
  }
  $returns = array();
  // Fetch the cron semaphore
  $semaphore = variable_get('wallymport_process_folder_semaphore', FALSE);

  if ($semaphore) {
    if (time() - $semaphore > 60) {
      // Either cron has been running for more than an hour or the semaphore
      // was not reset due to a database error.
      watchdog('Wallymport', 'Process folder task has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);

      // Release cron semaphore
      variable_del('wallymport_process_folder_semaphore');
    } else {
      // Cron is still running normally.
      watchdog('Wallymport', 'Attempting to re-run process folder task while it is already running.', array(), WATCHDOG_WARNING);
    }

    $returns[] = array('error' => TRUE, 'error_msg' => t('Process folder task has been running for more than an hour and is most likely stuck.'));
  } else {
    // Register shutdown callback
    register_shutdown_function('wallymport_process_folder_cleanup');

    // Lock cron semaphore
    variable_set('wallymport_process_folder_semaphore', time());

    // Call the function calling the RSS feeds
    $importer = wallymport_getimporterbyname($importer_name);
    if ($importer != NULL){
      $returns = wallymport_process_folder($importer);
    } else {
      //Unknown importer
      $returns[] = array('error' => TRUE, 'error_msg' => t('Unknown importer'));
    }
    // Record cron time
    variable_set('wallymport_process_folder_last', time());
    // watchdog('Wallymport', 'Process folder task completed.', array(), WATCHDOG_NOTICE);

    // Release cron semaphore
    variable_del('wallymport_process_folder_semaphore');
    
  }
  $content = '';
  foreach ($returns as $return){
    $return['date'] = time();
    $content .= theme('wallymport_logs', $return);
  } 
  return $content;
}
/**
 * Check if Wallymport can process folder.
 * 
 * @param $importer_name
 * The importer who will process the file
 * 
 * @return
 *   Response about the success or failure of import.
 */
function wallymport_check_process_file($importer_name, $file_name) {
  // Try to allocate enough time to run import process.
  if (function_exists('set_time_limit')) {
    @set_time_limit(60);
  }
  $returns = array();
  // Fetch the cron semaphore
  $semaphore = variable_get('wallymport_process_folder_semaphore', FALSE);

  if ($semaphore) {
    if (time() - $semaphore > 60) {
      // Either cron has been running for more than an hour or the semaphore
      // was not reset due to a database error.
      watchdog('Wallymport', 'Process folder task has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);

      // Release cron semaphore
      variable_del('wallymport_process_folder_semaphore');
    } else {
      // Cron is still running normally.
      watchdog('Wallymport', 'Attempting to re-run process folder task while it is already running.', array(), WATCHDOG_WARNING);
    }
    $returns[] = array('error' => TRUE, 'error_msg' => t('Process folder task has been running for more than an hour and is most likely stuck.'));
  } else {
    // Register shutdown callback
    register_shutdown_function('wallymport_process_folder_cleanup');

    // Lock cron semaphore
    variable_set('wallymport_process_folder_semaphore', time());
    
    // Call the function calling the RSS feeds
    
    $importer = wallymport_getimporterbyname($importer_name);
    if ($importer != NULL){
      $returns = wallymport_process_file($importer, $file_name);
    } else {
      //Unknown importer
      $returns[] = array('error' => TRUE, 'error_msg' => t('Unknown importer'));
    }
    // Record cron time
    variable_set('wallymport_process_folder_last', time());
    // watchdog('Wallymport', 'Process folder task completed.', array(), WATCHDOG_NOTICE);

    // Release cron semaphore
    variable_del('wallymport_process_folder_semaphore');
    
    /**
    * @todo Remove print in production mode OR check the "log" mode or import settings.
    */
    
  }
  $content = '';
  foreach ($returns as $return){
    $return['date'] = time();
    $content .= theme('wallymport_logs', $return);
  }
  return $content;
}
/**
 * Shutdown function for Wallymport process folder cleanup.
 */
function wallymport_process_folder_cleanup() {
  // See if the semaphore is still locked.
  if (variable_get('wallymport_process_folder_semaphore', FALSE)) {
    watchdog('Wallymport', 'Process folder task run exceeded the time limit and was aborted.', array(), WATCHDOG_WARNING);

    // Release semaphore
    variable_del('wallymport_process_folder_semaphore');
  }
}

/**
 * Process all zip files from the import folder. 
 * Page Callback of the processing of the import folder and call for each XML element the wallymport_process_xmlfile().
 * 
 * @param $importer
 *   Importer choose to process file
 * 
 * @return errors, logs
 */
function wallymport_process_folder($importer){

  $returns = NULL;
  
  $folder = $importer->source_directory_path;
  $format = 'xml';
  if ($importer->zip == 1){
    $format = 'zip';
  }
  $files = file_scan_directory($folder, '.*\.'. $format .'$', array('.', '..', 'CVS'), 0, FALSE, 'name', 0);// get list of all files
  
  if (count($files) == 0 ) {
    $error_msg = t('No input files found.');
    drupal_set_header('HTTP/1.1 517 '.$error_msg);
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  }
  ksort($files);
  if ($returns == NULL){
    // Process each files from folder.
    foreach ($files as $file) {
      //Unzip the file if its zipped
      $xml_file = wallymport_preprocess_file($file, $importer, $returns);
      if ($xml_file != NULL){
        //Process the file
        $return = wallymport_process_xmlfile($xml_file, $importer);
        wallymport_movefiles($importer, $file, $xml_file, $return);
        $returns[] = $return;
      } else {
        wallymport_save_log($importer, time(), $importer->error_directory_path.'/'.$file->name, serialize($returns[0]));
      }
    }
  }
  return $returns;
}
/**
 * Save logs in db
 * 
 * @param $importer_name
 *   Importer_name of the importer choose to process file
 * @param $date
 * @param $file_location
 * @param $log
 * @return errors, logs
 */
function wallymport_save_log($importer, $date, $file_location, $log){
  if ($importer->keep_log == 1){
    $logs = new stdClass();
    $logs->importer_name = $importer->name;
    $logs->date = $date;
    $logs->location = $file_location;
    $logs->log = $log;
    drupal_write_record('wallymport_logs', $logs);
  }
}
/**
 * Process all zip files from the import folder. 
 * Page Callback of the processing of the import folder and call for each XML element the wallymport_process_xmlfile().
 * 
 * @param: $importer_name
 *   Importer_name of the importer choose to process file
 * @param $file_name
 *   File name
 * @return errors, logs
 */
function wallymport_process_file($importer, $file_name){
  
  $returns = NULL;
  
  $folder = $importer->source_directory_path;

  $file = new stdClass();
  
  $file->name = $file_name;
  $file->filename = $folder."/".$file_name;
  $file->basename = $file_name;

  if (!file_exists($file->filename)) {
    $error_msg = t('Input file doesn\'t exists');
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  }
  if ($returns == NULL){
    $xml_file = wallymport_preprocess_file($file, $importer, $returns);
    if ($xml_file != NULL & $returns == NULL){
      //Process the file
      $return = wallymport_process_xmlfile($xml_file, $importer);
      wallymport_movefiles($importer, $file, $xml_file, $return);
      $returns[] = $return;
    } else {
      wallymport_save_log($importer, time(), $importer->error_directory_path.'/'.$file->name, serialize($returns[0]));
    }
  }
  return $returns;
}

/**
 * Return the form containing the preview iframe and the select box to choose the destination preview
 */
function wallymport_preview_form(&$form_state, $cache_name, $dest = 'disabled') {
  global $base_url;
  $prev_js = '$(document).ready(function() {
            var temp = "'.$base_url.'/node/'.$cache_name.'/preview2/"+$("#edit-select-preview").val();
            $("#prev_iframe").attr("src", temp);
            
            $("#edit-select-preview").change(function () {
              temp = "'.$base_url.'/node/'.$cache_name.'/preview2/"+$(this).val();
              $("#prev_iframe").attr("src", temp);
            });
          });';

  drupal_add_js($prev_js, 'inline');
  drupal_get_messages();
  $prenode = new Prenode($cache_name);

  if (!empty($prenode->form_state)){
    $options = array('no_dest' => 'Node', );
    foreach ($prenode->form_state[$prenode->form_state['type']]['#node']->field_destinations as $delta => $dest){
      if ($delta !== 'field_destinations_add_more'){
        $dest_name = taxonomy_get_term($dest['tid'])->name;
        $options += array($delta => $dest_name.' - Target : '.$dest['target'].' - Layout : '.$dest['layout'].' - Rank : '.$dest['rank'], );
      }
    }
    $form['select_preview'] = array(
      '#type' => 'select',
      '#title' => t('Preview destination'),
      '#default_value' => 'no_dest',
      '#options' => $options,
      '#attributes' => array('prenode' => $cache_name),
    );
    $form['#suffix'] = theme('wallyedit_preview_id', array('cache name' => $cache_name, 'dest' => 'no_dest')).drupal_get_js();
  } else {
    $form['#suffix'] = theme('wallyedit_nopreview');
  }

  return $form;
}

/**
 * Import files receive by POST
 * 
 * @param $importer_name
 *  $importer choosed to process de file
 *  
 * @return $result of the post
 * 
 * */
function wallymport_post($importer_name){
  
  $returns = array('error' => FALSE);
  
  $importer = wallymport_getimporterbyname($importer_name);
  if ($importer == NULL){
    $error_msg  = t('This importer does not exist');
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  } elseif ($importer->processed_by_post != 1){
    $error_msg = t('This importer does not accept POST');
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  } else {
    $nb_file = 0;
    $object_file = new stdClass();
    
    //Get the file
    foreach ($_FILES as $key => $input){
      $object_file->name = $input['name'];
      $object_file->filename = $input['tmp_name'];
      $object_file->basename = $input['tmp_name'];
      $nb_file ++;
    }
    
    if ($nb_file > 1){
      $error_msg = 'There is more than one file in the POST';
      $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
    } elseif ($nb_file == 0){
      $error_msg = 'There is no file in the POST';
      $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
    } else {
      $xml_file = wallymport_preprocess_file($object_file, $importer, $returns);
      if ($xml_file != NULL & !$returns['error']){
        //Proccess xml
        $return = wallymport_process_xmlfile($xml_file, $importer);
        wallymport_movefiles($importer, $file, $xml_file, $return);
        $returns[] = $return;
      } else {
        wallymport_save_log($importer, time(), $importer->error_directory_path.'/'.$file->name, serialize($returns[0]));
      }
    }
  }
  $content = '';
  foreach ($returns as $return){
    $return['date'] = time();
    $content .= theme('wallymport_logs', $return).$return['content'];
  }
  return $content;
}
/**
* Move files to their new directory and delete tmp files
*
* @param $importer
*  $importer choosed to process de file
* @param $file
* The file to move
* @param $xml_file
* The tmp file to delete
* @param $return
* information about the import
*
*
* */
function wallymport_movefiles($importer, $file, $xml_file, $return){
  if ($return['error'] == FALSE){
    if (!file_move($file->filename, $importer->done_directory_path)) {
      $error_msg = t('An error occured during file copy to done directory.');
      drupal_set_header('HTTP/1.1 517 '.$error_msg);
    } else {
      $file_location = $importer->done_directory_path.'/'.$file->name;
    }
  } else {
    if (!file_move($file->filename, $importer->error_directory_path)) {
      $error_msg = t('An error occured during file copy to error directory.');
      drupal_set_header('HTTP/1.1 517 '.$error_msg);
    } else {
      $file_location = $importer->error_directory_path.'/'.$file->name;
    }
  }
  //save log in db
  unset($return['log']['node']);
  wallymport_save_log($importer, time(), $file_location, serialize($return));
  file_delete($xml_file);
}
/**
 * Process one file.
 * 
 * @param stdObject $file
 *   File object to be processed.
 * @param importer
 *   The importer object used for the import
 * @param array $returns
 *   Results of the import.
 * @return $xml_file (name of the xml file to process)
 */
function wallymport_preprocess_file($file, &$importer, &$returns){
  
  if ($importer->zip == 1){
    $xml_file = wallymport_preprocess_zip($file, $importer, $returns);
  } else {
    $xml_file = $file->filename;
  }
  
  return $xml_file;
  
}
/**
 * Process one zip file.
 * 
 * @param stdObject $file
 *   File object to be processed.
 * @param importer
 *   The importer object used for the import
 * @param array $returns
 *   Results of the import.
 * @return $xml_file (name of the xml file to process)
 */
function wallymport_preprocess_zip($file, &$importer, &$returns){
  $xml_file = NULL;
  $zip_error = FALSE;
  $error_msg = FALSE;
  // Unzip input file to the temp directory
  $zip = new ZipArchive;

  $res = $zip->open($file->filename);
  if ($res === TRUE) {
    
    $temp_subdir = $importer->temp_directory_path.'/'.$file->name;
    file_check_directory($temp_subdir,1);
    if (is_dir($temp_subdir)) {
      $importer->temp_subdir = $temp_subdir;
      $zip->extractTo($temp_subdir);
      // Search for XMLs
      $import_files = file_scan_directory($temp_subdir, '.*\.xml$', array('.', '..', 'CVS'), 0, TRUE, 'name', 0);
      if (count($import_files) == 0) {
        $zip_error = TRUE;
        $error_msg = t('No XML file found in the import: !file', array('!file' => $file->basename));
        $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
      } elseif (count($import_files) > 1) {
        $zip_error = TRUE;
        $error_msg = t('There is more than one XML file found in the import: !file', array('!file' => $file->basename));
        $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
      } else {
        // Yeah .. ready to ROCK & ROLL
        $import_file = reset($import_files);
        $xml_file = $import_file->filename;
      }
      $zip->close();
    } else {
      $zip_error = TRUE;
      $error_msg = t('Input file !file could not be unzipped to !subdir. Error code !res', array('!file' => $file->filename, '!subdir' => $temp_subdir, '!res' => $res));
      $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
    }
  } else {
    $zip_error = TRUE;
    $error_msg = t('Cant UnZip file: !file', array('!file' => $file->filename));
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  }
  if ($zip_error) {
    if (!file_move($file->filename, $importer->error_directory_path)) {
      $error_msg .= ' '.t('An error occured during file copy to error directory.');
    }
    drupal_set_header('HTTP/1.1 517 '.$error_msg);
  }
  return $xml_file;
}



/**
 * Process a xml file
 * The function load the XML file, validate it with the xsd defined in the module's settings
 * and call the recursive process wimprt_process_packages()
 *
 * @param $xml_file
 *   The path to a XML file to be proccesed.
 * @param importer
 *   The importer object used for the import
 * @return
 *   array with logs
 */
function wallymport_process_xmlfile($xml_file, $importer){
  $handle = fopen($xml_file, "r");
  $contents = fread($handle, filesize($xml_file));
  
  $contents = wallymport_convertEntities($contents);
  fclose($handle);
  //Need to rewrite the file to convert entites
  $handle = fopen($xml_file, "w");
  if (!$handle){
    $return = array('error' => TRUE, 'error_msg' => t('Can\'t read the xml file (Permission denied)'));
  } else {
    fwrite($handle, $contents);
  
    $dom = new DomDocument();
    $dom->LoadXML($contents);
    $log = array();
    $return = array('error' => FALSE);
   
    if (!$dom->schemaValidate($importer->xsd_path)){
      dsm('XML not VALIDATED');
      $error_msg = t('The XML file (!xml_file) isn\'t validate by the XSD file', array('!xml_file' => $xml_file));
      $return = array('error' => TRUE, 'error_msg' => $error_msg); 
    } else {
      foreach ($dom->childNodes as $child){
        $return = call_user_func("wimprt_process_entrypoint_generic", $dom, &$log, $importer);
      }
      if ($return['log']['error'] == TRUE){
        $return['error'] = TRUE;
        $return['error_msg'] = $return['log']['error_msg'];
      }
    }
  }
  return $return;
}

/**
 * Convert HTML Entites in acceptable XML Entites (See http://www.developpez.net/forums/d238024/java/general-java/xml/caracteres-speciaux/)
 *
 * @param $str
 *   the string that represent the xml
 *
 * @return
 *   the converted string
 */
function wallymport_convertEntities($str){
  $xml = array('&#8364;','&#8217;','&#233;', '&#34;','&#38;','&#38;','&#60;','&#62;','&#160;','&#161;','&#162;','&#163;','&#164;','&#165;','&#166;','&#167;','&#168;','&#169;','&#170;','&#171;','&#172;','&#173;','&#174;','&#175;','&#176;','&#177;','&#178;','&#179;','&#180;','&#181;','&#182;','&#183;','&#184;','&#185;','&#186;','&#187;','&#188;','&#189;','&#190;','&#191;','&#192;','&#193;','&#194;','&#195;','&#196;','&#197;','&#198;','&#199;','&#200;','&#201;','&#202;','&#203;','&#204;','&#205;','&#206;','&#207;','&#208;','&#209;','&#210;','&#211;','&#212;','&#213;','&#214;','&#215;','&#216;','&#217;','&#218;','&#219;','&#220;','&#221;','&#222;','&#223;','&#224;','&#225;','&#226;','&#227;','&#228;','&#229;','&#230;','&#231;','&#232;','&#233;','&#234;','&#235;','&#236;','&#237;','&#238;','&#239;','&#240;','&#241;','&#242;','&#243;','&#244;','&#245;','&#246;','&#247;','&#248;','&#249;','&#250;','&#251;','&#252;','&#253;','&#254;','&#255;');
  $html = array('&euro;','&rsquo;','&eacute;','&quot;','&amp;','&amp;','&lt;','&gt;','&nbsp;','&iexcl;','&cent;','&pound;','&curren;','&yen;','&brvbar;','&sect;','&uml;','&copy;','&ordf;','&laquo;','&not;','&shy;','&reg;','&macr;','&deg;','&plusmn;','&sup2;','&sup3;','&acute;','&micro;','&para;','&middot;','&cedil;','&sup1;','&ordm;','&raquo;','&frac14;','&frac12;','&frac34;','&iquest;','&Agrave;','&Aacute;','&Acirc;','&Atilde;','&Auml;','&Aring;','&AElig;','&Ccedil;','&Egrave;','&Eacute;','&Ecirc;','&Euml;','&Igrave;','&Iacute;','&Icirc;','&Iuml;','&ETH;','&Ntilde;','&Ograve;','&Oacute;','&Ocirc;','&Otilde;','&Ouml;','&times;','&Oslash;','&Ugrave;','&Uacute;','&Ucirc;','&Uuml;','&Yacute;','&THORN;','&szlig;','&agrave;','&aacute;','&acirc;','&atilde;','&auml;','&aring;','&aelig;','&ccedil;','&egrave;','&eacute;','&ecirc;','&euml;','&igrave;','&iacute;','&icirc;','&iuml;','&eth;','&ntilde;','&ograve;','&oacute;','&ocirc;','&otilde;','&ouml;','&divide;','&oslash;','&ugrave;','&uacute;','&ucirc;','&uuml;','&yacute;','&thorn;','&yuml;');
  $str = str_replace($html, $xml, $str);
  $str = str_ireplace($html, $xml, $str);
  return $str;
}

/**
 * Get importers info
 *
 * @return
 *   an array of importers
 */
function wallymport_getimporters(){
  $result = db_query("SELECT * FROM {wallymport_importer}");
  $importers = NULL;
  while ($importer = db_fetch_object($result)){
    $importers[] = $importer;
  }
  return $importers;
}

/**
 * Get importer info
 *
 * @param iid
 * id of the importer
 * @return
 *   an array of importers
 */
function wallymport_getimporter($iid){
  $result = db_query("SELECT * FROM {wallymport_importer} WHERE iid = %d", $iid);
  $importer = NULL;
  while ($obj = db_fetch_object($result)){
    $importer = $obj;
  }
  return $importer;
}

/**
 * Get importer info
 *
 * @param iid
 * id of the importer
 * @return
 *   an array of importers
 */
function wallymport_getimporterbyname($name){
  $result = db_query("SELECT * FROM {wallymport_importer} WHERE name = '%s'", $name);
  $importer = NULL;
  while ($obj = db_fetch_object($result)){
    $importer = $obj;
    $modules = module_invoke_all('wallymport_importer');
    foreach ($modules as $module_importers){
      foreach ($module_importers as $module_importer){
        if ($module_importer['importer_type'] == $importer->importer_type){
          $importer->importer_functions = $module_importer['importer_functions'];
          break 2;
        }
      }
    }
  }
  return $importer;
}
/**
* Process the Dom Object
* 
*
* @param $dom
*   The DomDocument who is being proceed
* @param $log
*   The log object build recursively in different operation. this could track error in the process and build nodes
* @param $importer
*   The importer object used to import
* @return
*   the log object
*/
function wimprt_process_entrypoint_generic($dom, &$log, $importer){
  $return = array();
  
  module_invoke_all('wallymport_process', $dom, $log, $importer, 'process_entrypoint', 'before_process');
  
  wimprt_exploredom($dom, $log, $importer);
  
  module_invoke_all('wallymport_process', $dom, $log, $importer, 'process_entrypoint', 'after_process');
  
  $return['log'] = $log;
  return $return;
}
/**
* Process the Dom Object
*
*
* @param $dom
*   The DomDocument who is being proceed
* @param $log
*   The log object build recursively in different operation. this could track error in the process and build nodes
* @param $importer
*   The importer object used to import
* @return
*   the log object
*/
function wimprt_exploredom($dom, &$log, $importer){
  if ($dom->hasChildNodes()){
    //For each child of the dom
    foreach ($dom->childNodes as $child){
      $name = $child->nodeName;
      if ($name != '#text'){
        $explore_child = TRUE;
        //Search for a function named with node name, if the function return FALSE, it does not explode the children of the node.
        foreach ($importer->importer_functions as $importer_function){
          if (function_exists($importer_function.'_process_'.$name)){
            $explore_child = call_user_func($importer_function.'_process_'.$name, $child, &$log, $importer);
            break;
          }
        }
        if ($explore_child){
          wimprt_exploredom($child, $log, $importer);
        }
      }
    }
  }
}

/**
* Call an apropriate function to process an type element depending the attribute type of the child element.
*
* The naming convention to load or create the node before his build is: wimprt_create_or_load_type_CALLCACK
* The naming convention to build a node from a specific callback is: wimprt_process_type_CALLCACK
*
* @param $dom
*   The DomDocument who is being proceed (A DomElement)
* @param $log
*   The log object build recursively in different operation. this could track error in the process and build nodes
* @param importer
*   The importer object used for the import
* @param $callback
* @return
*   the node object that has been build
*/
function wimprt_node_process($dom, &$log, $importer, $callback = NULL){
  //get function name
  $callback = wimprt_set_callback($dom, $importer, $callback);
  
  //Create or load the node
  $node = wimprt_node_create_or_load($dom, $importer, $callback, $log);

  //@todo: place in wallymportlog module
  if (variable_get('wallymport_debug',0) or TRUE){
    $log['log'][] = 'process type: '.$dom->nodeName;
  }
  module_invoke_all('wallymport_nodeprocess', $node, $dom, $log, $importer, 'node_process', 'before_process');
  $callback = strtolower($callback);
  $function_exist = FALSE;
  foreach ($importer->importer_functions as $importer_function){
    if (function_exists($importer_function.'_node_process_'.$callback)){
      call_user_func($importer_function.'_node_process_'.$callback, &$node, $dom, &$log, $importer);
      break;
    }
  }

  module_invoke_all('wallymport_nodeprocess', $node, $dom, $log, $importer, 'node_process', 'after_process');

  if (!empty($node) && !$node->rejected){
    node_save($node);
    module_invoke_all('wallymport_nodeprocess', $node, $dom, $log, $importer, 'node_process', 'postsave');
  }

  $log['node'] = array('current' => $node,'next' => $log['node']);

  return $node;
}

/**
 * Call an apropriate function to process an list of elements depending the attribute type of the child element.
 *
 * The naming convention to build a node from a specific package type is: wimprt_process_type_CALLCACK
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes.
 * @param importer
 *   The importer object used for the import
 * @param $callback
 * @return
 *   the array of nodes objects that has been build
 */
function wimprt_node_process_list($dom_element, &$log, $importer){
 
  //@todo: place in walymportlog module  
  if (variable_get('wallymport_debug',0) or TRUE){
    $log['log'][] = 'process list: '.$dom_element->nodeName;
  }

  $array_of_nodes = array();
  module_invoke_all('wallymport_nodeprocess', $array_of_nodes, $dom_element, $log, $importer, 'node_process_list', 'before_process');
 
  foreach ($dom_element->childNodes as $dom_child){
    $element_name = $dom_child->nodeName;
    if ($element_name != '#text'){
      $array_of_nodes[] = call_user_func('wimprt_node_process', $dom_child, &$log, $importer, NULL);
    }
  }
  module_invoke_all('wallymport_nodeprocess', $array_of_nodes, $dom_element, $log, $importer, 'node_process_list', 'after_process');

  $log['node'] = array('current' => $array_of_nodes);
  return $array_of_nodes;
}


/**
* The default Callback function for processing a node
*
* @param $node
*   The current node te be edited
* @param $dom
*   The DomDocument who is being proceed (A DomElement)
* @param $log
*   The log object build recursively in different operation. this could track error in the process and build nodes.
* @param $importer
*  The importer used to import
* @return
*   The modified package node
*/
function wimprt_node_process_fields(&$node, $dom, &$log, $importer){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){
    $name = strtolower($element->nodeName);

    if ($name != '#text'){
      foreach ($importer->importer_functions as $importer_function){
        if (function_exists($importer_function.'_node_set_field_'.$name)){
          call_user_func($importer_function."_node_set_field_".$name, &$node, $element, &$log, $importer);
          break;
        }
      }
    }
  }
  return $node;
}

/**
 * Determine the next callback function from the Dom element
 *
 * If a callback is passed don't change else try to determine the next callback:
 * - first try callbak associated with the xsi:type attribute.
 * - second try the tag name if the xsi:type attribute doesn't exist.
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $callback
 *   The callback passing as argument to the caller function
 *   
 * @return
 *   The next callback
 */
function wimprt_set_callback($dom, $importer, $callback = NULL){
  $function_exist = FALSE;
  foreach ($importer->importer_functions as $importer_function){
    if (function_exists($importer_function.'_set_callback')){
      $callback = call_user_func($importer_function."_set_callback", $dom, $callback);
      $function_exist = TRUE;
      break;
    } 
  }
  if (!$function_exist) {
    $callback = strtolower($dom->nodeName);
  }
  return strtolower($callback);
}

/**
* Call the fonction who will load or create the node
*
* @param $dom
*   The DomDocument who is being proceed (A DomElement)
* @param importer
*   The importer object used for the import
* @param $objecttype
*   Node type
* @param $callback
*   The callback of the process function to allow specific call of wimprt_create_or_load_object_CALLBACK
* @param $log
*
* @return
*   A node object
*/
function wimprt_node_create_or_load($dom, $importer, $callback, &$log){
  $node = new stdClass;
  foreach ($importer->importer_functions as $importer_function){
    if (function_exists($importer_function.'_node_create_or_load_'.$callback)){
      $node = call_user_func($importer_function."_node_create_or_load_".$callback, $dom, &$log, $importer);
      break;
    }
  }
  return $node;
}
function wallymport_page_test(){
  $content .= '<form enctype="multipart/form-data" action="/wallymport/post/package/preview" method="POST">
       
		
        Choose a file to upload: <input name="uploadedfile" type="file" /><br />
        <input type="submit" value="Upload File" />
      </form>';

  return $content;
}

/**
 * @} End of "defgroup wallymport_process_default".
 */
