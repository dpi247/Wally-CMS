<?php
/**
 * @defgroup wallymport Wally Import Core Functions
 * @{
 * In this module we define core functions of wally xml import module.  
 * Do not put field specific functions or generic helpers functions here. 
 */

module_load_include('inc', 'wallymport', 'includes/wallymport.fields');
module_load_include('inc', 'wallymport', 'includes/wallymport.fieldshelpers');

/**
 * Implementation of hook_menu().
 */
function wallymport_menu() {
  $items = array();
  $items['admin/wally/wallymport/settings'] = array(
    'title' => 'Wally Import Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wallymport_page_admin_form'),
    'access arguments' => array('access administration pages'),
    'description' => 'Allows administrators to set paramaters for this module to function properly.',
    'file' => 'includes/wallymport.admin.inc',
  );

  $items['wallymport/process_folder'] = array(
    'title' => 'Run XML Import Process for a forlder',
    'description' => 'Run data import (folder)',
    'page callback' => 'wallymport_check_process_folder',
  //  'access arguments' => array('access administration pages'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  
  $items['wallymport/process_zip'] = array(
    'title' => 'Run XML Import Process for a zip file',
    'description' => 'Run data import (zip)',
    'page callback' => 'wallymport_process_zip',
  //  'access arguments' => array('access administration pages'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  
  $items['wallymport/destinations_items'] = array(
    'title' => 'Return a XML list of all available destinations',
    'description' => 'Return a XML list of all available destinations',
    'page callback' => 'wallymport_page_destinations_items',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Create a XML document containing all available destinations.
 * The structure of the XML follows packages.xsd.
 * 
 * <xsd:complexType name="DestinationsItem">
 *   <xsd:sequence>
 *     <xsd:element name="DestinationPath" type="xsd:string" />
 *   </xsd:sequence>
 *   <xsd:attribute name="DestinationRank" type="xsd:string" use="required" />
 *   <xsd:attribute name="Position" type="xsd:string" />
 *   <xsd:attribute name="DocumentLayout" use="required" type="xsd:string" />
 * </xsd:complexType>
 * 
 * @return
 *   The XML document as a string.
 */
function wallymport_page_destinations_items(){
  $array_dests = wallytoolbox_destinations_items_array();
  $dom_dests = new DOMDocument('1.0', 'UTF-8');

  $destinations = $dom_dests->createElement('Destinations');
  $destinations = $dom_dests->appendChild($destinations);

  foreach ($array_dests as $tid=>$term_infos) {
    $term = wallytoolbox_taxonomy_get_path_by_tid_or_term($tid);
    $term = strtoupper($term);
    foreach ($term_infos as $target_name=>$target_infos) {
      foreach ($target_infos as $layout_name=>$layout_infos) {
        foreach ($layout_infos as $rank_elem=>$true_value) {
          $destination = $dom_dests->createElement('Destination');
          $destination = $destinations->appendChild($destination);
          
          $destination->setAttribute('Position', $target_name);
          $destination->setAttribute('DocumentLayout', $layout_name);
          $destination->setAttribute('DestinationRank', $rank_elem);
          
          $destination_path = $dom_dests->createElement('DestinationPath');
          $destination_path = $destination->appendChild($destination_path);
          $destination_path_text = $dom_dests->createTextNode($term);
          $destination_path->appendChild($destination_path_text);
        }
      }
    }
  }
  
  print $dom_dests->saveXML(); 
}

/**
 * Check if Wallymport can process folder.
 * 
 * @return
 *   Response about the success or failure of import.
 */
function wallymport_check_process_folder($path_to_folder = NULL, $absolute_path = FALSE) {
  // Try to allocate enough time to run import process.
  if (function_exists('set_time_limit')) {
    @set_time_limit(60);
  }

  // Fetch the cron semaphore
  $semaphore = variable_get('wallymport_process_folder_semaphore', FALSE);

  if ($semaphore) {
    if (time() - $semaphore > 3600) {
      // Either cron has been running for more than an hour or the semaphore
      // was not reset due to a database error.
      watchdog('Wallymport', 'Process folder task has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);

      // Release cron semaphore
      variable_del('wallymport_process_folder_semaphore');
    } else {
      // Cron is still running normally.
      watchdog('Wallymport', 'Attempting to re-run process folder task while it is already running.', array(), WATCHDOG_WARNING);
    }

    return FALSE;
  } else {
    // Register shutdown callback
    register_shutdown_function('wallymport_process_folder_cleanup');

    // Lock cron semaphore
    variable_set('wallymport_process_folder_semaphore', time());

    // Call the function calling the RSS feeds
    $return = wallymport_page_process_folder($path_to_folder, $absolute_path);

    // Record cron time
    variable_set('wallymport_process_folder_last', time());
    watchdog('Wallymport', 'Process folder task completed.', array(), WATCHDOG_NOTICE);

    // Release cron semaphore
    variable_del('wallymport_process_folder_semaphore');
    
    /**
    * @todo Remove print in production mode OR check the "log" mode or import settings.
    */
    print json_encode($return);
  }
}

/**
 * Shutdown function for Wallymport process folder cleanup.
 */
function wallymport_process_folder_cleanup() {
  // See if the semaphore is still locked.
  if (variable_get('wallymport_process_folder_semaphore', FALSE)) {
    watchdog('Wallymport', 'Process folder task run exceeded the time limit and was aborted.', array(), WATCHDOG_WARNING);

    // Release semaphore
    variable_del('wallymport_process_folder_semaphore');
  }
}

/**
 * Process all zip files from the import folder. 
 * Page Callback of the processing of the import folder and call for each XML element the wallymport_page_process_file().
 * 
 * @param: $path_to_folder
 *   The child folder to be proccesed. Root folder is alway determined by the wallymport_source settings
 * 
 * @return Nothing
 */
function wallymport_page_process_folder($path_to_folder = NULL, $absolute_path = FALSE){
  global $proceed_folder_path;
  $returns = array(); 
   
  $temp=file_directory_temp();
  $format='zip';   // input file extension

  if($absolute_path){
    $xml_file=$path_to_folder;
  } else {
    if ($path_to_folder) {
      $xml_file = variable_get('wallymport_source','')."/".$path_to_folder;
    } else { 
      $xml_file = variable_get('wallymport_source','');
    }
  }
  $files = drupal_system_listing('.*\.'. $format .'$', $xml_file, 'name', 0);	// get list of all *.zip files
  if (count($files)==0) {
    drupal_set_message('No input files found','error');
    return null;
  }
  ksort($files);

  // Process each ZIP files from folder.
  foreach ($files as $file) {
    $zip_error = FALSE;
    // Unzip input file to the temp directory
    $zip = new ZipArchive;
    $res = $zip->open($file->filename);
    if ($res === TRUE) { 
      
      $temp_subdir=$temp.'/'.$file->name;
      file_check_directory($temp_subdir,1);
      if (is_dir($temp_subdir)) { 
        $zip->extractTo($temp_subdir);
        // Search for XMLs
        $import_files = drupal_system_listing('.*\.xml$', $temp_subdir, 'name', 0);
        if (count($import_files)==0) {
          $zip_error = TRUE;
          drupal_set_message('No XML file found in the import: '.$file->basename, "error");
        } elseif (count($import_files)>1) {
          $zip_error = TRUE;
          drupal_set_message('There is more than one XML file found in the import: '.$file->basename, "error");
        } else {
          // Yeah .. ready to ROCK & ROLL
          $import_file=reset($import_files);
          $xml_file=$import_file->filename;
          $proceed_folder_path = $temp_subdir; 
          $returns[] = wallymport_page_process_file($xml_file);
        }
        $zip->close();
        rrmdir($temp_subdir);
      } else {
        $zip_error = TRUE;
        drupal_set_message('Input file '.$file->filename.' could not be unzipped to '.$temp_subdir.'. Error code '.$res, "error");
      }

    } else {
      $zip_error = TRUE;
      drupal_set_message('Cant UnZip file: '.$file->filename, "error");
    }

    if ($zip_error) {
      file_move($file->filename, variable_get('wallymport_import_error'));
    } else {
      file_move($file->filename, variable_get('wallymport_import_done'));
    }
  }
  
  return $returns; 
}

/**
 * Process all zip files from the import folder. 
 * Page Callback of the processing of the import folder and call for each XML element the wallymport_page_process_file().
 * 
 * @param: $path_to_folder
 *   The child folder to be proccesed. Root folder is alway determined by the wallymport_source settings
 * 
 * @return Nothing
 */
function wallymport_process_zip($path_to_zip, $absolute_path = FALSE){
  global $proceed_folder_path;
  $returns = array();
  
  $temp = file_directory_temp();
  $format = 'zip'; // input file extension
  
  if($absolute_path){
    $file = $path_to_zip;
  } else {
    $file = variable_get('wallymport_source','')."/".$path_to_zip;
  }
  
  if (!file_exists($file)) {
    drupal_set_message('Input file doesn\'t exists','error');
    print 'error';
    return;
  }
  
  $zip_error = FALSE;
  $error_msg = FALSE;
  // Unzip input file to the temp directory
  $zip = new ZipArchive;
  $res = $zip->open($file);
  if ($res === TRUE) { 
    $expl_filename = explode('.'.$format, $file);
    $expl_filename = explode('/', $expl_filename[0]);
    $temp_subdir=$temp.'/'.$expl_filename[sizeof($expl_filename)-1];
    file_check_directory($temp_subdir,1);
    if (is_dir($temp_subdir)) { 
      $zip->extractTo($temp_subdir);
      // Search for XMLs
      $import_files = drupal_system_listing('.*\.xml$', $temp_subdir, 'name', 0);
      if (count($import_files)==0) {
        $zip_error = TRUE;
        $error_msg = 'No XML file found in the import: '.$file;
      } elseif (count($import_files)>1) {
        $zip_error = TRUE;
        $error_msg = 'There is more than one XML file found in the import: '.$file;
      } else {
        // Yeah .. ready to ROCK & ROLL
        $import_file=reset($import_files);
        $xml_file=$import_file->filename;
        $proceed_folder_path = $temp_subdir; 
        $returns[] = wallymport_page_process_file($xml_file);
      }
      $zip->close();
      rrmdir($temp_subdir);
    } else {
      $zip_error = TRUE;
      $error_msg = 'Input file '.$file.' could not be unzipped to '.$temp_subdir.'. Error code '.$res;
    }

  } else {
    $zip_error = TRUE;
    $error_msg = 'Cant UnZip file: '.$file;
  }
  
  $error_msg ? watchdog('Wallymport', $error_msg, array(), WATCHDOG_ERROR) : NULL;
  $returns[] = $error_msg;
  $zip_error ? file_move($file, variable_get('wallymport_import_error', file_directory_path())) : file_move($file, variable_get('wallymport_import_done', file_directory_path()));
  
  print json_encode($returns); 
}

/**
 * Process a xml file or a folder containg an xml file.
 * The function load the XML file, validate it with the xsd defined in the module's settings
 * and call the recursive process wimprt_process_packages()
 *
 * @param $path_to_file
 *   The path to a XML file to be proccesed. if the path is an XML file, the parent folder will be considered.
 *
 * @return
 *   nothing
 */
function wallymport_page_process_file($path_to_file){
  global $proceed_file_path;

  $proceed_file_path=$path_to_file;
    
  if(!$path_to_file){
    drupal_set_message("error",'You must to provide a path to the XML');
    return '';
  }

  $xsd_file= variable_get('wallymport_definition', 'definitions/yaxim.input.xsd');
//  $xml_file = variable_get('wallymport_source','')."/".$path_to_file;
  $xml_file = $path_to_file;
  $handle = fopen($xml_file, "r");
  $contents = fread($handle, filesize($xml_file));
  fclose($handle);
  $dom = new DomDocument();
  $dom->LoadXML($contents);
  if (!$dom->schemaValidate($xsd_file)){
    drupal_set_message('The XML file isn\'t validate by the XSD file',"error");
    return '';
  }

  $node=new StdClass();
  $log=array();
  $return=wimprt_process_packages($node,$dom,$log);
  return $return;
}

/**
 * Process the packages element of a wally DomDocument object.
 * Initiate the node object Call an apropriate function to process the childs of the packages element (package)
 *
 * @param $dom
 *   The DomDocument who is being proceed
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   the log object
 */
function wimprt_process_packages($node,$dom,&$log){

  module_invoke_all('wimprt_process_packages',$dom,$log,'before_process');
  foreach($dom->getElementsByTagName('Package') as $package_element){
    $node=new stdClass;
    wimprt_process_package($node,$package_element,$log);
    //$log[]=$log;
  }
  module_invoke_all('wimprt_process_packages',$dom,$log,'after_process');

  return $log;
}


/**
 * Call an apropriate function to process the childs of the package element depending the attribute callback of the child element.
 * 
 * The naming convention to build a node from a specific package callback is: wimprt_process_package_CALLCACK
 * if no specific function found nothing is done.
 *
 * @param $node
 *   The Node that's being build
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   the node object that has been build
 */
function wimprt_process_package(&$node,$dom,&$log,$callback=NULL){
  $callback=wimprt_set_callback($dom,$callback);
  $node=wimprt_create_or_load($dom,'package', $callback,$log);

  //@todo: place in walymportlog module
  if(variable_get('wallymport_debug',0) or true)
    $log['log'][]='process package: '.$dom->nodeName;

  module_invoke_all('wimprt_process_package',$node,$dom,$log,'before_process');

  // ?Posibility of extension with 'hook_wallymport_info' / CTools Plugin?
  if(function_exists("wimprt_process_package_".$callback)){
    call_user_func("wimprt_process_package_".$callback,&$node,$dom,&$log);
  }

  module_invoke_all('wimprt_process_package',$node,$dom,$log,'after_process');

  if(!empty($node))
    node_save($node);
  $log['node']=array('current'=>$node,'next'=>$log['node']);
    
  return $node;
}


/**
 * Process an object element
 *
 * Call an apropriate function to process an object element
 * depending the attribute callback of the child element.
 *
 * The naming convention to load or create the node before his build is: wimprt_create_or_load_object_CALLBACK
 * 
 * The naming convention to build a node from a specific package callback is: wimprt_process_object_CALLBACK
 *
 * if no specific function found nothing is done.
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   The node object that has been build
 */
function wimprt_process_object($dom,&$log,$callback=NULL){
  $callback=wimprt_set_callback($dom,$callback);
  $node=wimprt_create_or_load($dom,'object', $callback,$log);

/**
 * @todo Put into walymportlog module
 */
  if(variable_get('wallymport_debug',0) or true)
    $log['log'][]='process object: '.$dom->nodeName;

  module_invoke_all('wimprt_process_object',$node,$dom,$log,'before_process');
  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  if(function_exists("wimprt_process_object_$callback")){
    call_user_func("wimprt_process_object_$callback",&$node,$dom,&$log);
  }

  module_invoke_all('wimprt_process_object',$node,$dom,$log,'after_process');
  
  if(!empty($node))
    node_save($node);
 
  $log['node']=array('current'=>$node,'next'=>$log['node']);
  return $node;
}

/**
 * Call an apropriate function to process an type element depending the attribute type of the child element.
 *
 * The naming convention to load or create the node before his build is: wimprt_create_or_load_type_CALLCACK
 * The naming convention to build a node from a specific callback is: wimprt_process_type_CALLCACK
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   the node object that has been build
 */
function wimprt_process_type($dom,&$log,$callback=NULL){
  $callback=wimprt_set_callback($dom,$callback);
  $node=wimprt_create_or_load($dom,'type', $callback,$log);
  //@todo: place in walymportlog module
  if(variable_get('wallymport_debug',0) or true)
    $log['log'][]='process type: '.$dom->nodeName;
    
  module_invoke_all('wimprt_process_type',$node,$dom,$log,'before_process');
  $callback=strtolower($callback);
  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  if(function_exists("wimprt_process_type_$callback")){
    call_user_func("wimprt_process_type_$callback",&$node,$dom,&$log);
  }

  module_invoke_all('wimprt_process_type',$node,$dom,$log,'after_process');
  
  if(!empty($node))
    node_save($node);

  $log['node']=array('current'=>$node,'next'=>$log['node']);
  
  return $node;
}


/**
 * Call an apropriate function to process an list of elements depending the attribute type of the child element.
 *
 * The naming convention to build a node from a specific package type is: wimprt_process_type_CALLCACK
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes.
 *
 * @return
 *   the array of nodes objects that has been build
 */
function wimprt_process_list($dom_element,&$log,$callback=NULL){
  $callback=wimprt_set_callback($dom_element,$callback);

  //@todo: place in walymportlog module  
  if(variable_get('wallymport_debug',0) or true){
    $log['log'][]='process list: '.$dom_element->nodeName;
  }

  $array_of_nodes=array();
  module_invoke_all('wimprt_process_list',$array_of_nodes,$dom_element,$callback,$log,'before_process');
  
  foreach($dom_element->childNodes as $dom_child){
    $element_name=$dom_child->nodeName;
    if($element_name!='#text'){
      if(function_exists("wimprt_process_".$callback)){
        $array_of_nodes[]= call_user_func("wimprt_process_".$callback,$dom_child,&$log);
      }
    }

  }
  module_invoke_all('wimprt_process_list',$array_of_nodes,$dom_element,$callback,$log,'after_process');

  $log['node']=array('current'=>$array_of_nodes);
  return $array_of_nodes;
}


/**
 * The default Callback function for processing a package
 *
 * @param $node
 *   The current node te be edited
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes.
 *
 * @return
 *   The modified package node
 */
function wimprt_process_package_default(&$node,$dom,&$log){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){
    $name=strtolower($element->nodeName);
    if(function_exists("wimprt_set_field_$name")){
      call_user_func("wimprt_set_field_$name",&$node,$element,&$log);
    }
  }
  return $node;
}


/**
 * The default Callback function for processing a object
 *
 * @param $node
 *   The current node te be edited
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes.
 *
 * @return
 *   The modified object node
 */
function wimprt_process_object_default(&$node,$dom,&$log){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){
    $name=strtolower($element->nodeName);
    if(function_exists("wimprt_set_field_$name")){
      call_user_func("wimprt_set_field_$name",&$node,$element,&$log);
    }
     
  }
}

/**
 * The default Callback function for processing a type
 *
 * @param $node
 *   The current node te be edited
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes.
 *
 * @return
 *   The modified type node
 */
function wimprt_process_type_default(&$node,$dom,&$log){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){
    $name=strtolower($element->nodeName);
    if(function_exists("wimprt_set_field_$name")){
      call_user_func("wimprt_set_field_$name",&$node,$element,&$log);
    }
  }
}

/**
 * Determine the next callback function from the Dom element
 *
 * If a callback is passed don't change else try to determine the next callback:
 * - first try callbak associated with the xsi:type attribute.
 * - second try the tag name if the xsi:type attribute doesn't exist.
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $callback
 *   The callback passing as argument to the caller function
 *   
 * @return
 *   The next callback
 */
function wimprt_set_callback($dom,$callback=NULL){
  if(get_class($dom)=='DOMElement'){
    if($callback==NULL){
      if($dom->hasAttribute('xsi:type'))
        $callback=$dom->getAttributeNode('xsi:type')->value;
      else
        $callback=$dom->nodeName;
    }
  }
  return strtolower($callback);
}

/**
 * Determine if the node from the processed element should be create or update based on the dom.
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $callback
 *   The callback of the process function to allow specific call of wimprt_create_or_load_object_CALLBACK
 *   
 * @return
 *   A node object
 */
function wimprt_create_or_load($dom,$objecttype, $callback,$log){
if(function_exists("wimprt_create_or_load_".$objecttype."_".$callback)){
    $node=call_user_func("wimprt_create_or_load_".$objecttype."_".$callback,$dom,&$log);
  }
  else{
   $node=new stdClass;
  }
  return $node;
}

/**
 * @} End of "defgroup wallymport_process_default".
 */
