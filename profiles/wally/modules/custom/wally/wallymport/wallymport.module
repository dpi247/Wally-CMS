<?php
/**
 * @defgroup wallymport Wally Import Core Functions
 * @{
 * In this module we define core functions of wally xml import module.  
 * Do not put field specific functions or generic helpers functions here. 
 */

module_load_include('inc', 'wallymport', 'includes/wallymport.fields');
module_load_include('inc', 'wallymport', 'includes/wallymport.fieldshelpers');

/**
 * Implementation of hook_perm().
 */
function wallymport_perm() {
  return array(
    'administer wallymport',
  );
}

/**
 * Implementation of hook_menu().
 */
function wallymport_menu() {
  $items = array();
  
  //Admin settings Page
  $items['admin/wally/wallymport/settings'] = array(
    'title'            => t('Wally Import Settings'),
    'page callback'    => 'wallymport_page_admin',
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to set paramaters for this module to function properly.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  $items['admin/wally/wallymport/settings/general'] = array(
    'title'            => t('General'),
    'page callback'    => 'wallymport_page_admin',
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to set paramaters for this module to function properly.'),
    'file'             => 'includes/wallymport.admin.inc',
    'weight'           => -3,
    'type'             => MENU_DEFAULT_LOCAL_TASK,
  );
  
  //Page to create an importer
  $items['admin/wally/wallymport/settings/add'] = array(
    'title'            => t('Create importer'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('wallymport_page_importer_form'),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to create a new importer.'),
    'file'             => 'includes/wallymport.admin.inc',
    'type'             => MENU_LOCAL_TASK,
  );
  
  //Page to edit an importer
  $items['admin/wally/wallymport/settings/edit/%'] = array(
    'title'            => t('Edit importer'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('wallymport_page_importer_form', 5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to edit an importer.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  $items['admin/wally/wallymport/settings/log/%'] = array(
    'title'            => t('Importer logs'),
    'page callback'    => 'wallymport_page_importer_logs',
    'page arguments'   => array(5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to see importer logs.'),
    'file'             => 'includes/wallymport.admin.inc',
  );

  $items['admin/wally/wallymport/settings/logs/%'] = array(
    'title'            => t('Importer logs'),
    'page callback'    => 'wallymport_page_importerlogs',
    'page arguments'   => array(5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to see importer logs.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  //Page to delete an importer
  $items['admin/wally/wallymport/settings/delete/%'] = array(
    'title'            => t('Delete importer'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('wallymport_page_importerdelete_form', 5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Allows administrators to delete an importer.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  //Page with the links to the folders of the importer 
  $items['admin/wally/wallymport/settings/links/%'] = array(
    'title'            => t('Packages links'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('wallymport_page_links_form', 5),
    'access arguments' => array('administer wallymport'),
    'description'      => t('Display download links for imported packages.'),
    'file'             => 'includes/wallymport.admin.inc',
  );
  
  $items['wallymport/process/%'] = array(
    'title'            => t('Run XML Import'),
    'description'      => t('Run data import'),
    'page callback'    => 'wallymport_check_process_folder',
    'page arguments'   => array(2),
    'access callback'  => TRUE,
    'type'             => MENU_CALLBACK,
  );
  
  $items['wallymport/process_file/%/%/run'] = array(
    'title'            => t('Run one XML Import'),
    'description'      => t('Run one import'),
    'page callback'    => 'wallymport_check_process_file',
    'page arguments'   => array(2,3),
    'access callback'  => TRUE,
    'type'             => MENU_CALLBACK,
  );

  $items['wallymport/post/%'] = array(
    'page callback'    => 'wallymport_post',
    'access callback'  => TRUE,
    'page arguments'   => array(2),
    'type'             => MENU_CALLBACK,
  );

  $items['wallymport/destinations_items'] = array(
    'title'            => t('Return a XML list of all available destinations'),
    'description'      => t('Return a XML list of all available destinations'),
    'page callback'    => 'wallymport_page_destinations_items',
    'access callback'  => TRUE,
    'type'             => MENU_CALLBACK,
  );
  
  $items['wallymport/test/%'] = array(
  	'title'           => 'test',
    'page callback'   => 'wallymport_page_test',
    'page arguments'  => array(2),
    'access arguments' => array('administer wallymport'),
    'type'            => MENU_NORMAL_ITEM,
  );
  
  return $items;
}

/**
 * Implementation of hook_cron().
 */ 
function wallymport_cron() {
  $prev_cleanup_ret = wimprt_cron_previews_cleanup();
  if (empty($prev_cleanup_ret)){
    $prev_cleanup_ret[] = t('No preview prenodes deleted done on !date', array('!date' => date('Y-m-d H:i:s', time())));
  }
  print_r($prev_cleanup_ret);
  
  $logs_cleanup_ret = wimprt_cron_logs_cleanup();
  if (empty($logs_cleanup_ret)){
    $logs_cleanup_ret[] = t('No logs deleted done on !date', array('!date' => date('Y-m-d H:i:s', time())));
  }
  print_r($logs_cleanup_ret);

  //Run wallymport cron.
  if (db_table_exists('wallymport_importer')){
    //Sélectionne les importeurs dont leur exécutions remonte à plus longtemps par rapport à leur cron_frequency.
    $importer_to_process = db_query("SELECT wi.*
                                    FROM {wallymport_importer} wi
                                    WHERE wi.processed_by_cron = 1 
                                    AND (SELECT ((wi2.cron_timestamp + wi2.cron_frequency))
                                    FROM {wallymport_importer} wi2
                                    WHERE wi.iid = wi2.iid) < %d", time());
    while ($importer = db_fetch_object($importer_to_process)){
      $return = wallymport_check_process_folder($importer->name);
      if (!$return['error']){
        $importer->cron_timestamp = time();
      }
      $return['date'] = time();
      if ($importer->cron_keep_log == 1){
        $cron_log = unserialize($importer->cron_log);
        $cron_log[] = $return;
        $importer->cron_log = serialize($cron_log);
      }
      drupal_write_record('wallymport_importer', $importer, array('iid'));
    }
  }
}

/**
 * Implementation of hook_theme().
 */
function wallymport_theme(){
  $path = drupal_get_path('module', 'wallymport');

  $base = array(
    'file' => 'theme.inc',
    'path' => $path."/theme",
  );
  $theme_functions = array(
    'wallymport_logs' => $base + array(
      'arguments' => array('log' => array()),
    ),
  );
  return $theme_functions;
}

/**
 * Create a XML document containing all available destinations.
 * The structure of the XML follows packages.xsd.
 * 
 * <xsd:complexType name="DestinationsItem">
 *   <xsd:sequence>
 *     <xsd:element name="DestinationPath" type="xsd:string" />
 *   </xsd:sequence>
 *   <xsd:attribute name="DestinationRank" type="xsd:string" use="required" />
 *   <xsd:attribute name="Position" type="xsd:string" />
 *   <xsd:attribute name="DocumentLayout" use="required" type="xsd:string" />
 * </xsd:complexType>
 * 
 * @return
 *   The XML document as a string.
 */
function wallymport_page_destinations_items($short = FALSE) {
  $array_dests = wallytoolbox_destinations_items_array();
  $dom_dests = new DOMDocument('1.0', 'UTF-8');

  $destinations = $dom_dests->createElement('Destinations');
  $destinations = $dom_dests->appendChild($destinations);

  foreach ($array_dests as $tid => $term_infos) {
    $term = wallytoolbox_taxonomy_get_path_by_tid_or_term($tid);
    $term = strtoupper($term);
    foreach ($term_infos as $target_name => $target_infos) {
      if (!$short) {
        foreach ($target_infos as $layout_name => $layout_infos) {
          foreach ($layout_infos as $rank_elem => $true_value) {
            $destination = $dom_dests->createElement('Destination');
            $destination = $destinations->appendChild($destination);

            $destination->setAttribute('tid', $tid);
            $destination->setAttribute('Position', $target_name);
            $destination->setAttribute('DocumentLayout', $layout_name);
            $destination->setAttribute('DestinationRank', $rank_elem);

            $destination_path = $dom_dests->createElement('DestinationPath');
            $destination_path = $destination->appendChild($destination_path);
            $destination_path_text = $dom_dests->createTextNode($term);
            $destination_path->appendChild($destination_path_text);
          }
        }
      } else {
        $destination = $dom_dests->createElement('Destination');
        $destination = $destinations->appendChild($destination);

        $destination->setAttribute('tid', $tid);
        $destination->setAttribute('Position', $target_name);

        $destination_path = $dom_dests->createElement('DestinationPath');
        $destination_path = $destination->appendChild($destination_path);
        $destination_path_text = $dom_dests->createTextNode($term);
        $destination_path->appendChild($destination_path_text);
      }
    }
  }
  
  print $dom_dests->saveXML(); 
}

/**
 * Check if Wallymport can process folder.
 * 
 * @param $importer_name
 * The importer who will process the file
 * 
 * @return
 *   Response about the success or failure of import.
 */
function wallymport_check_process_folder($importer_name) {
  // Try to allocate enough time to run import process.
  if (function_exists('set_time_limit')) {
    @set_time_limit(60);
  }
  $returns = array();
  // Fetch the cron semaphore
  $semaphore = variable_get('wallymport_process_folder_semaphore', FALSE);

  if ($semaphore) {
    if (time() - $semaphore > 60) {
      // Either cron has been running for more than an hour or the semaphore
      // was not reset due to a database error.
      watchdog('Wallymport', 'Process folder task has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);

      // Release cron semaphore
      variable_del('wallymport_process_folder_semaphore');
    } else {
      // Cron is still running normally.
      watchdog('Wallymport', 'Attempting to re-run process folder task while it is already running.', array(), WATCHDOG_WARNING);
    }

    $returns[] = array('error' => TRUE, 'error_msg' => t('Process folder task has been running for more than an hour and is most likely stuck.'));
  } else {
    // Register shutdown callback
    register_shutdown_function('wallymport_process_folder_cleanup');

    // Lock cron semaphore
    variable_set('wallymport_process_folder_semaphore', time());

    // Call the function calling the RSS feeds
    $importer = wallymport_getimporterbyname($importer_name);
    if ($importer != NULL){
      $returns = wallymport_process_folder($importer);
    } else {
      //Unknown importer
      $returns[] = array('error' => TRUE, 'error_msg' => t('Unknown importer'));
    }
    // Record cron time
    variable_set('wallymport_process_folder_last', time());
    // watchdog('Wallymport', 'Process folder task completed.', array(), WATCHDOG_NOTICE);

    // Release cron semaphore
    variable_del('wallymport_process_folder_semaphore');
    
  }
  $content = '';
  foreach ($returns as $return){
    $return['date'] = time();
    $content .= theme('wallymport_logs', $return);
  } 
  return $content;
}

/**
 * Check if Wallymport can process folder.
 * 
 * @param $importer_name
 * The importer who will process the file
 * 
 * @return
 *   Response about the success or failure of import.
 */
function wallymport_check_process_file($importer_name, $file_name) {
  // Try to allocate enough time to run import process.
  if (function_exists('set_time_limit')) {
    @set_time_limit(60);
  }
  $returns = array();
  // Fetch the cron semaphore
  $semaphore = variable_get('wallymport_process_folder_semaphore', FALSE);

  if ($semaphore) {
    if (time() - $semaphore > 60) {
      // Either cron has been running for more than an hour or the semaphore
      // was not reset due to a database error.
      watchdog('Wallymport', 'Process folder task has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);

      // Release cron semaphore
      variable_del('wallymport_process_folder_semaphore');
    } else {
      // Cron is still running normally.
      watchdog('Wallymport', 'Attempting to re-run process folder task while it is already running.', array(), WATCHDOG_WARNING);
    }
    $returns[] = array('error' => TRUE, 'error_msg' => t('Process folder task has been running for more than an hour and is most likely stuck.'));
  } else {
    // Register shutdown callback
    register_shutdown_function('wallymport_process_folder_cleanup');

    // Lock cron semaphore
    variable_set('wallymport_process_folder_semaphore', time());
    
    // Call the function calling the RSS feeds
    
    $importer = wallymport_getimporterbyname($importer_name);
    if ($importer != NULL){
      $returns = wallymport_process_file($importer, $file_name);
    } else {
      //Unknown importer
      $returns[] = array('error' => TRUE, 'error_msg' => t('Unknown importer'));
    }
    // Record cron time
    variable_set('wallymport_process_folder_last', time());
    // watchdog('Wallymport', 'Process folder task completed.', array(), WATCHDOG_NOTICE);

    // Release cron semaphore
    variable_del('wallymport_process_folder_semaphore');
    
    /**
    * @todo Remove print in production mode OR check the "log" mode or import settings.
    */
    
  }
  $content = '';
  foreach ($returns as $return){
    $return['date'] = time();
    $content .= theme('wallymport_logs', $return);
  }
  return $content;
}

/**
 * Shutdown function for Wallymport process folder cleanup.
 */
function wallymport_process_folder_cleanup() {
  // See if the semaphore is still locked.
  if (variable_get('wallymport_process_folder_semaphore', FALSE)) {
    watchdog('Wallymport', 'Process folder task run exceeded the time limit and was aborted.', array(), WATCHDOG_WARNING);

    // Release semaphore
    variable_del('wallymport_process_folder_semaphore');
  }
}

/**
 * Process all zip files from the import folder. 
 * Page Callback of the processing of the import folder and call for each XML element the wallymport_page_process_file().
 * 
 * @param $importer
 *   Importer choose to process file
 * 
 * @return errors, logs
 */
function wallymport_process_folder($importer){

  $returns = NULL;
  
  $folder = $importer->source_directory_path;
  $format = 'xml';
  if ($importer->zip == 1){
    $format = 'zip';
  }
  $files = file_scan_directory($folder, '.*\.'. $format .'$', array('.', '..', 'CVS'), 0, FALSE, 'name', 0);// get list of all files
  
  if (count($files) == 0 ) {
    $error_msg = t('No input files found.');
    drupal_set_header('HTTP/1.1 517 '.$error_msg);
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  }
  ksort($files);
  if ($returns == NULL){
    // Process each files from folder.
    foreach ($files as $file) {
      //Unzip the file if its zipped
      $xml_file = wallymport_preprocess_file($file, $importer, $returns);
      if ($xml_file != NULL){
        //Process the file
        $return = wallymport_page_process_file($xml_file, $importer);
        if ($return['error'] == FALSE){
          if (!file_move($file->filename, $importer->done_directory_path)) {
            $error_msg = t('An error occured during file copy to done directory.');
            drupal_set_header('HTTP/1.1 517 '.$error_msg);
          } else {
            $file_location = $importer->done_directory_path.'/'.$file->name;
          }
        } else {
          if (!file_move($file->filename, $importer->error_directory_path)) {
            $error_msg = t('An error occured during file copy to error directory.');
            drupal_set_header('HTTP/1.1 517 '.$error_msg);
          } else {
            $file_location = $importer->error_directory_path.'/'.$file->name;
          }
        }
        
        if ($error_msg) {
          $return['error'] = TRUE;
          $return[0]['log'][] = $error_msg;
        }
        
        file_delete($xml_file);
        $returns[] = $return;
        $return['log']['extref'] = $return['log']['node']['current']->field_externalreference[0]['value'];
        unset($return[0]['log']['node']);
        wallymport_save_log($importer, time(), $file_location, serialize($return));
      }
    }
  }
  return $returns;
}

/**
 * Save logs in db
 * 
 * @param $importer_name
 *   Importer_name of the importer choose to process file
 * @param $date
 * @param $file_location
 * @param $log
 * @return errors, logs
 */
function wallymport_save_log($importer, $date, $file_location, $log) {
  if ($importer->keep_log == 1) {
    $logs = new stdClass();
    $logs->importer_name = $importer->name;
    $logs->date = $date;
    $logs->location = $file_location;
    $logs->log = $log;
    drupal_write_record('wallymport_logs', $logs);
  }
}

/**
 * Process all zip files from the import folder. 
 * Page Callback of the processing of the import folder and call for each XML element the wallymport_page_process_file().
 * 
 * @param $importer_name
 *   Importer_name of the importer choose to process file
 * @param $file_name
 *   File name
 * @return errors, logs
 */
function wallymport_process_file($importer, $file_name){
  $returns = NULL;
  
  $folder = $importer->source_directory_path;

  $file = new stdClass();  
  $file->name = $file_name;
  $file->filename = $folder."/".$file_name;
  $file->basename = $file_name;

  if (!file_exists($file->filename)) {
    $error_msg = t('Input file doesn\'t exists');
    $return = array('error' => TRUE, 'error_msg' => $error_msg);
    $returns[] = $return;
    drupal_set_header('HTTP/1.1 517 '.$error_msg);
    wallymport_save_log($importer, time(), $file->filename, serialize($return));
  }

  if ($returns == NULL) {
    $xml_file = wallymport_preprocess_file($file, $importer, $returns);
    if ($xml_file != NULL & $returns == NULL){
      //Process the file
      $return = wallymport_page_process_file($xml_file, $importer);
      if ($return['error'] == FALSE){
        if (!file_move($file->filename, $importer->done_directory_path)) {
          $error_msg = t('An error occured during file copy to done directory.');
          drupal_set_header('HTTP/1.1 517 '.$error_msg);
        } else {
          $file_location = $importer->done_directory_path.'/'.$file->name;
        }
      } else {
        if (!file_move($file->filename, $importer->error_directory_path)) {
          $error_msg = t('An error occured during file copy to error directory.');
          drupal_set_header('HTTP/1.1 517 '.$error_msg);
        } else {
          $file_location = $importer->error_directory_path.'/'.$file->name;
        }
      }
      file_delete($xml_file);
      $returns[] = $return;
      $return['log']['extref'] = $return['log']['node']['current']->field_externalreference[0]['value'];
      unset($return[0]['log']['node']);
      wallymport_save_log($importer, time(), $file_location, serialize($return));
    }
  }

  return $returns;
}

/**
 * Return the form containing the preview iframe and the select box to choose the destination preview
 */
function wallymport_preview_form(&$form_state, $cache_name, $dest = 'disabled') {
  global $base_url;
  $prev_js = '$(document).ready(function() {
            var temp = "'.$base_url.'/node/'.$cache_name.'/preview2/"+$("#edit-select-preview").val();
            $("#prev_iframe").attr("src", temp);
            
            $("#edit-select-preview").change(function () {
              temp = "'.$base_url.'/node/'.$cache_name.'/preview2/"+$(this).val();
              $("#prev_iframe").attr("src", temp);
            });
          });';

  drupal_add_js($prev_js, 'inline');
  drupal_get_messages();
  $prenode = new Prenode($cache_name);

  if (!empty($prenode->form_state)){
    $options = array('no_dest' => 'Node', );
    foreach ($prenode->form_state[$prenode->form_state['type']]['#node']->field_destinations as $delta => $dest){
      if ($delta !== 'field_destinations_add_more'){
        $dest_name = taxonomy_get_term($dest['tid'])->name;
        $options += array($delta => $dest_name.' - Target : '.$dest['target'].' - Layout : '.$dest['layout'].' - Rank : '.$dest['rank'], );
      }
    }
    $form['select_preview'] = array(
      '#type' => 'select',
      '#title' => t('Preview destination'),
      '#default_value' => 'no_dest',
      '#options' => $options,
      '#attributes' => array('prenode' => $cache_name),
    );
    $form['#suffix'] = theme('wallyedit_preview_id', array('cache name' => $cache_name, 'dest' => 'no_dest')).drupal_get_js();
  } else {
    $form['#suffix'] = theme('wallyedit_nopreview');
  }

  return $form;
}

/**
 * Import files receive by POST
 * 
 * @param $importer_name
 *  $importer choosed to process de file
 *  
 * @return $result of the post
 * 
 * */
function wallymport_post($importer_name){
  $returns = NULL;
  $importer = wallymport_getimporterbyname($importer_name);
  if ($importer == NULL){
    $error_msg  = t('This importer does not exist');
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  } elseif ($importer->processed_by_post != 1){
    $error_msg = t('This importer does not accept POST');
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  } else {
    $nb_file = 0;
    $object_file = new stdClass();
    
    //Get the file
    foreach ($_FILES as $key => $input){
      $object_file->name = $input['name'];
      $object_file->filename = $input['tmp_name'];
      $object_file->basename = $input['tmp_name'];
      $nb_file ++;
    }
    if ($nb_file == 0){
      $temp = variable_get('wallymport_preview_temp', file_directory_temp());
      $file_name = 'wally_curl_input_'.rand();
      $file_path = $temp.'/'.$file_name.'.'.$format;
      $fwrite = TRUE;

      $input = fopen('php://input', 'r');
      $file = fopen($file_path, 'w');
      while (!feof($input)) {
        $fwrite = fwrite($file, fread($input, 1024));
        if (!fwrite)
        break;
      }
      fclose($input);
      //$object_file=$file;
      $object_file->name = $file_name;
      $object_file->filename = $file_path;
      $object_file->basename = $file_path;

      fclose($file);

      $nb_file = 1;
    }

    if ($nb_file > 1){
      $error_msg = 'There is more than one file in the POST';
      $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
    } elseif ($nb_file == 0){
      $error_msg = 'There is no file in the POST';
      $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
    } else {
      $xml_file = wallymport_preprocess_file($object_file, $importer, $returns);
      if ($xml_file != NULL & $returns == NULL){
        //Proccess xml
        $returns[] = wallymport_page_process_file($xml_file, $importer);
        //Move file 
        if (!$returns[0]['error']){
          if (!file_move($object_file->filename, $importer->done_directory_path)) {
            $returns[0]['error_msg'][] = t('An error occured during file copy to done directory.');
          } 
        } else {
          if (!file_move($object_file->filename, $importer->error_directory_path)) {
            $returns[0]['error_msg'][] = t('An error occured during file copy to done directory.');
          }
        }
        file_delete($xml_file);
      }
    }
  }
  $js = '<script>
$("div.wallymport_result ul").hide();
$("div#wallyedit_preview h1").hide();
$("div.wallymport_result .logs").click(function(){
  $("div.wallymport_result ul").toggle();
});
</script>';
  $content = '';
  foreach ($returns as $return){
    $return['date'] = time();
    $content .= theme('status_messages').theme('wallymport_logs', $return).$return['content'].$js;
  }
  print $content;
}

/**
 * Process one file.
 * 
 * @param stdObject $file
 *   File object to be processed.
 * @param importer
 *   The importer object used for the import
 * @param array $returns
 *   Results of the import.
 * @return $xml_file (name of the xml file to process)
 */
function wallymport_preprocess_file($file, &$importer, &$returns){
  if ($importer->zip == 1){
    $xml_file = wallymport_preprocess_zip($file, $importer, $returns);
  } else {
    $xml_file = $file->filename;
  }
  return $xml_file;
}

/**
 * Process one zip file.
 * 
 * @param stdObject $file
 *   File object to be processed.
 * @param importer
 *   The importer object used for the import
 * @param array $returns
 *   Results of the import.
 * @return $xml_file (name of the xml file to process)
 */
function wallymport_preprocess_zip($file, &$importer, &$returns){
  $xml_file = NULL;
  $zip_error = FALSE;
  $error_msg = FALSE;
  // Unzip input file to the temp directory
  $zip = new ZipArchive;

  $res = $zip->open($file->filename);
  if ($res === TRUE) {
    $file_name = strstr($file->name, '.zip') ? str_replace('.zip', '', $file->name) : $file->name;
    $temp_subdir = $importer->temp_directory_path.'/'.$file_name;
    file_check_directory_recursive($temp_subdir, 1);
    if (is_dir($temp_subdir)) {
      $importer->temp_subdir = $temp_subdir;
      $zip->extractTo($temp_subdir);
      // Search for XMLs
      $import_files = file_scan_directory($temp_subdir, '.*\.xml$', array('.', '..', 'CVS'), 0, FALSE, 'name', 0);
      
      if (count($import_files) == 0) {
        $zip_error = TRUE;
        $error_msg = t('No XML file found in the import: !file. The ZIP must contains only files, no folder.', array('!file' => $file->basename));
        $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
      } elseif (count($import_files) > 1) {
        $zip_error = TRUE;
        $error_msg = t('There is more than one XML file found in the import: !file CODE X9', array('!file' => $file->basename));
        $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
      } else {
        // Yeah .. ready to ROCK & ROLL
        $import_file = reset($import_files);
        $xml_file = $import_file->filename;
      }
      $zip->close();
    } else {
      $zip_error = TRUE;
      $error_msg = t('Input file !file could not be unzipped to !subdir. Error code !res CODE X10', array('!file' => $file->filename, '!subdir' => $temp_subdir, '!res' => $res));
      $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
    }
  } else {
    $zip_error = TRUE;
    $error_msg = t('Cant UnZip file: !file CODE X11', array('!file' => $file->filename));
    $returns[] = array('error' => TRUE, 'error_msg' => $error_msg);
  }
  if ($zip_error) {
    if (!file_move($file->filename, $importer->error_directory_path)) {
      $error_msg .= ' '.t('An error occured during file copy to error directory CODE X12.');
    }
    drupal_set_header('HTTP/1.1 517 '.$error_msg);
  }

  return $xml_file;
}

/**
 * Process a xml file or a folder containg an xml file.
 * The function load the XML file, validate it with the xsd defined in the module's settings
 * and call the recursive process wimprt_process_packages()
 *
 * @param $xml_file
 *   The path to a XML file to be proccesed.
 * @param importer
 *   The importer object used for the import
 * @return
 *   array with logs
 */
function wallymport_page_process_file($xml_file, $importer){
  $handle = fopen($xml_file, "r");
  
  if (!$handle) {
    $error_msg = t('The XML file (!xml_file) isn\'t readable', array('!xml_file' => $xml_file));
    $return = array('error' => TRUE, 'error_msg' => $error_msg);
  } else {
    $contents = fread($handle, filesize($xml_file));
    $contents = wallymport_convertEntities($contents);

    $dom = new DomDocument();
    $dom->LoadXML($contents);
    $log = array();
    $return = array('error' => FALSE);
    if (!$dom->schemaValidate($importer->xsd_path)){
      dsm('XML not VALIDATED');
      $error_msg = t('The XML file (!xml_file) isn\'t validate by the XSD file', array('!xml_file' => $xml_file));
      $return = array('error' => TRUE, 'error_msg' => $error_msg);
    } else {
      foreach ($dom->childNodes as $child){
        $type = $child->nodeName;
        $function_exist = FALSE;
        foreach ($importer->importer_functions as $importer_function){
          if (function_exists($importer_function.'_process_'.$type)){
            $return = call_user_func($importer_function."_process_".$type, $dom, &$log, $importer);
            $function_exist = TRUE;
            break;
          }
        }
        if ($function_exist == FALSE & function_exists('wimprt_process_'.$type)){
          $return = call_user_func("wimprt_process_".$type, $dom, &$log, $importer);
        }
        if ($return['log']['error'] == TRUE){
          $return = array('error' => TRUE, 'error_msg' => $return[0]['log']['error_msg']);
        }
      }
    }
  }
  return $return;
}

/**
 * Convert HTML Entites in acceptable XML Entites (See http://www.developpez.net/forums/d238024/java/general-java/xml/caracteres-speciaux/)
 *
 * @param $str
 *   the string that represent the xml
 *
 * @return
 *   the converted string
 */
function wallymport_convertEntities($str){
  $xml = array('&#8364;','&#8217;','&#233;', '&#34;','&#38;','&#38;','&#60;','&#62;','&#160;','&#161;','&#162;','&#163;','&#164;','&#165;','&#166;','&#167;','&#168;','&#169;','&#170;','&#171;','&#172;','&#173;','&#174;','&#175;','&#176;','&#177;','&#178;','&#179;','&#180;','&#181;','&#182;','&#183;','&#184;','&#185;','&#186;','&#187;','&#188;','&#189;','&#190;','&#191;','&#192;','&#193;','&#194;','&#195;','&#196;','&#197;','&#198;','&#199;','&#200;','&#201;','&#202;','&#203;','&#204;','&#205;','&#206;','&#207;','&#208;','&#209;','&#210;','&#211;','&#212;','&#213;','&#214;','&#215;','&#216;','&#217;','&#218;','&#219;','&#220;','&#221;','&#222;','&#223;','&#224;','&#225;','&#226;','&#227;','&#228;','&#229;','&#230;','&#231;','&#232;','&#233;','&#234;','&#235;','&#236;','&#237;','&#238;','&#239;','&#240;','&#241;','&#242;','&#243;','&#244;','&#245;','&#246;','&#247;','&#248;','&#249;','&#250;','&#251;','&#252;','&#253;','&#254;','&#255;');
  $html = array('&euro;','&rsquo;','&eacute;','&quot;','&amp;','&amp;','&lt;','&gt;','&nbsp;','&iexcl;','&cent;','&pound;','&curren;','&yen;','&brvbar;','&sect;','&uml;','&copy;','&ordf;','&laquo;','&not;','&shy;','&reg;','&macr;','&deg;','&plusmn;','&sup2;','&sup3;','&acute;','&micro;','&para;','&middot;','&cedil;','&sup1;','&ordm;','&raquo;','&frac14;','&frac12;','&frac34;','&iquest;','&Agrave;','&Aacute;','&Acirc;','&Atilde;','&Auml;','&Aring;','&AElig;','&Ccedil;','&Egrave;','&Eacute;','&Ecirc;','&Euml;','&Igrave;','&Iacute;','&Icirc;','&Iuml;','&ETH;','&Ntilde;','&Ograve;','&Oacute;','&Ocirc;','&Otilde;','&Ouml;','&times;','&Oslash;','&Ugrave;','&Uacute;','&Ucirc;','&Uuml;','&Yacute;','&THORN;','&szlig;','&agrave;','&aacute;','&acirc;','&atilde;','&auml;','&aring;','&aelig;','&ccedil;','&egrave;','&eacute;','&ecirc;','&euml;','&igrave;','&iacute;','&icirc;','&iuml;','&eth;','&ntilde;','&ograve;','&oacute;','&ocirc;','&otilde;','&ouml;','&divide;','&oslash;','&ugrave;','&uacute;','&ucirc;','&uuml;','&yacute;','&thorn;','&yuml;');
  $str = str_replace($html, $xml, $str);
  $str = str_ireplace($html, $xml, $str);
  return $str;
}

/**
 * Get importers info
 *
 * @return
 *   an array of importers
 */
function wallymport_getimporters(){
  $result = db_query("SELECT * FROM {wallymport_importer}");
  $importers = NULL;
  while ($importer = db_fetch_object($result)){
    $importers[] = $importer;
  }
  return $importers;
}

/**
 * Get importer info
 *
 * @param iid
 * id of the importer
 * @return
 *   an array of importers
 */
function wallymport_getimporter($iid){
  $result = db_query("SELECT * FROM {wallymport_importer} WHERE iid = %d", $iid);
  $importer = NULL;
  while ($obj = db_fetch_object($result)){
    $importer = $obj;
  }
  return $importer;
}

/**
 * Get importer info
 *
 * @param iid
 * id of the importer
 * @return
 *   an array of importers
 */
function wallymport_getimporterbyname($name){
  $result = db_query("SELECT * FROM {wallymport_importer} WHERE name = '%s'", $name);
  $importer = NULL;
  while ($obj = db_fetch_object($result)){
    $importer = $obj;
    $modules = module_invoke_all('wallymport_importer');
    foreach ($modules as $module_importers){
      foreach ($module_importers as $module_importer){
        if ($module_importer['importer_type'] == $importer->importer_type){
          $importer->importer_functions = $module_importer['importer_functions'];
          break 2;
        }
      }
    }
  }
  return $importer;
}

/**
 * Previews cleanup at cron
 */
function wimprt_cron_previews_cleanup() {
  $list = db_query('SELECT name, data FROM {ctools_object_cache} WHERE name LIKE "wallymport_preview_%" AND FROM_UNIXTIME(updated) < NOW( ) - INTERVAL 1 HOUR', time() - 3600);
  $return = array();
  while ($elem = db_fetch_array($list)) {
    $data = unserialize($elem['data']);
    foreach ($data[$data['type']]['#node']->field_embededobjects_nodes as $embed) {
      if ($embed->type == 'wally_photoobject' && isset($embed->field_photofile[0]))
      wallytoolbox_delete_photofile($embed->field_photofile[0]);
    }

    db_query('DELETE FROM {ctools_object_cache} WHERE name = %d', $elem['name']);
    $return[] = t('Preview cache deleted for : @elem_name on !date', array('@elem_name' => $elem['name'], '!date' => date('Y-m-d H:i:s', time())));
  }
  return $return;
}

/**
 * Logs cleanup at cron
 */
function wimprt_cron_logs_cleanup() {
  $return = array();
  $removed_logs = db_fetch_array(db_query("SELECT COUNT(*) FROM {wallymport_logs} WHERE FROM_UNIXTIME(date) < NOW() - INTERVAL 3 DAY"));
  if (db_query("DELETE FROM {wallymport_logs} WHERE FROM_UNIXTIME(date) < NOW() - INTERVAL 3 DAY") && $removed_logs['COUNT(*)'] > 0) {
    $return[] = t('!num_logs logs removed.', array('!num_logs' => $removed_logs['COUNT(*)']));
  }
  return $return;
}

/**
 * Process an object element
 *
 * Call an apropriate function to process an object element
 * depending the attribute callback of the child element.
 *
 * The naming convention to load or create the node before his build is: wimprt_create_or_load_object_CALLBACK
 * 
 * The naming convention to build a node from a specific package callback is: wimprt_process_object_CALLBACK
 *
 * if no specific function found nothing is done.
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 * @param importer
 *   The importer object used for the import
 * @param $callback
 * @return
 *   The node object that has been build
 */
function wimprt_process_object($dom, &$log, $importer, $callback = NULL){

  $callback = wimprt_set_callback($dom, $callback);
  $node = wimprt_create_or_load($dom, $importer, 'object', $callback, $log);

  if (variable_get('wallymport_debug',0) or TRUE){
    $log['log'][] = 'process object: '.$dom->nodeName;
  }
  module_invoke_all('wimprt_process_object', $node, $dom, $log, 'before_process');
  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin

  $function_exist = FALSE;
  foreach ($importer->importer_functions as $importer_function){
    if (function_exists($importer_function.'_process_object_'.$callback)){
      call_user_func($importer_function.'_process_object_'.$callback, &$node, $dom, &$log, $importer);
      $function_exist = TRUE;
      break;
    } 
  }
  
  if (!$function_exist & function_exists("wimprt_process_object_".$callback)){
    call_user_func("wimprt_process_object_".$callback, &$node, $dom, &$log, $importer);
  }
  
  module_invoke_all('wimprt_process_object', $node, $dom, $log, 'after_process');

  if (!empty($node) && !$node->rejected){
    $node->doNotPullUp = TRUE;
    node_save($node);
  }
  $log['node'] = array('current' => $node,'next' => $log['node']);
  return $node;
}

/**
 * Call an apropriate function to process an type element depending the attribute type of the child element.
 *
 * The naming convention to load or create the node before his build is: wimprt_create_or_load_type_CALLCACK
 * The naming convention to build a node from a specific callback is: wimprt_process_type_CALLCACK
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 * @param importer
 *   The importer object used for the import
 * @param $callback
 * @return
 *   the node object that has been build
 */
function wimprt_process_type($dom, &$log, $importer, $callback = NULL){
  $callback = wimprt_set_callback($dom, $callback);
  $node = wimprt_create_or_load($dom, $importer,'type', $callback, $log);
  //@todo: place in walymportlog module
  if (variable_get('wallymport_debug',0) or TRUE){
    $log['log'][] = 'process type: '.$dom->nodeName;
  }
    
  module_invoke_all('wimprt_process_type', $node, $dom, $log, 'before_process');
  $callback = strtolower($callback);
  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  
  $function_exist = FALSE;
  foreach ($importer->importer_functions as $importer_function){
    if (function_exists($importer_function.'_process_type_'.$callback)){
      call_user_func($importer_function.'_process_type_'.$callback, &$node, $dom, &$log, $importer);
      $function_exist = TRUE;
      break;
    }
  }
  if ($function_exist == FALSE & function_exists("wimprt_process_type_$callback")){
    call_user_func("wimprt_process_type_".$callback, &$node, $dom, &$log, $importer);
  }

  module_invoke_all('wimprt_process_type', $node, $dom, $log, 'after_process');
  if (!empty($node) && !$node->rejected){
    node_save($node);
  }

  $log['node'] = array('current' => $node,'next' => $log['node']);

  return $node;
}

/**
 * Call an apropriate function to process an list of elements depending the attribute type of the child element.
 *
 * The naming convention to build a node from a specific package type is: wimprt_process_type_CALLCACK
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes.
 * @param importer
 *   The importer object used for the import
 * @param $callback
 * @return
 *   the array of nodes objects that has been build
 */
function wimprt_process_list($dom_element, &$log, $importer, $callback = NULL){
  $callback = wimprt_set_callback($dom_element, $callback);

  //@todo: place in walymportlog module  
  if (variable_get('wallymport_debug',0) or TRUE){
    $log['log'][] = 'process list: '.$dom_element->nodeName;
  }

  $array_of_nodes = array();
  module_invoke_all('wimprt_process_list', $array_of_nodes, $dom_element, $callback, $log, 'before_process');
 
  if ($dom_element->hasChildNodes) {
    foreach ($dom_element->childNodes as $dom_child){
      $element_name = $dom_child->nodeName;
      if ($element_name != '#text'){
        $function_exist = FALSE;
        foreach ($importer->importer_functions as $importer_function){
          if (function_exists($importer_function.'_process_'.$callback)){
            $array_of_nodes[] = call_user_func($importer_function.'_process_'.$callback, $dom_child, &$log, $importer, NULL);
            $function_exist = TRUE;
            break;
          } 
        }
        if ($function_exist == FALSE & function_exists("wimprt_process_".$callback)){
          $array_of_nodes[] = call_user_func("wimprt_process_".$callback, $dom_child, &$log, $importer, NULL);
        }
      }
    }
  }
  module_invoke_all('wimprt_process_list', $array_of_nodes, $dom_element, $callback, $log, 'after_process');

  $log['node'] = array('current' => $array_of_nodes);
  return $array_of_nodes;
}

/**
 * The default Callback function for processing a node
 *
 * @param $node
 *   The current node te be edited
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes.
 * @param $importer
 *  The importer used to import
 * @return
 *   The modified package node
 */
function wimprt_process_node_default(&$node, $dom, &$log, $importer){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){
    $name = strtolower($element->nodeName);

    if ($name != '#text'){
      $function_exist = FALSE;
      foreach ($importer->importer_functions as $importer_function){
        if (function_exists($importer_function.'_set_field_'.$name)){
          call_user_func($importer_function."_set_field_".$name, &$node, $element, &$log, $importer);
          $function_exist = TRUE;
          break;
        }
      }
      if (!$function_exist & function_exists('wimprt_set_field_'.$name)){
        call_user_func('wimprt_set_field_'.$name, &$node, $element, &$log, $importer);
      }  
    }
  }
  return $node;
}

/**
 * The default Callback function for processing a type
 *
 * @param $node
 *   The current node te be edited
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes.
 * @param importer
 *   The importer object used for the import
 * @return
 *   The modified type node
 */
function wimprt_process_type_default(&$node, $dom, &$log, $importer){
  //Beware of namespace colision
  foreach ($dom->childNodes as $element){
    $name = strtolower($element->nodeName);
    
    $function_exist = FALSE;
    foreach ($importer->importer_functions as $importer_function){
      if (function_exists($importer_function.'_set_field_'.$name)){
        call_user_func($importer_function.'_set_field_'.$name, &$node, $element, &$log, $importer);
        $function_exist = TRUE;
        break;
      } 
    }
    if ($function_exist == FALSE & function_exists("wimprt_set_field_".$name)){
      call_user_func("wimprt_set_field_".$name, &$node, $element, &$log, $importer);
    }
  }
}

/**
 * Determine the next callback function from the Dom element
 *
 * If a callback is passed don't change else try to determine the next callback:
 * - first try callbak associated with the xsi:type attribute.
 * - second try the tag name if the xsi:type attribute doesn't exist.
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $callback
 *   The callback passing as argument to the caller function
 *   
 * @return
 *   The next callback
 */
function wimprt_set_callback($dom, $callback = NULL){
  if (is_object($dom) && get_class($dom) == 'DOMElement'){
    if ($callback == NULL){
      if ($dom->hasAttribute('xsi:type')){
        $callback = $dom->getAttributeNode('xsi:type')->value;
      }
      else{
        $callback = $dom->nodeName;
      }
    }
  }
  return strtolower($callback);
}

/**
 * Determine if the node from the processed element should be create or update based on the dom.
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param importer
 *   The importer object used for the import
 * @param $objecttype
 *   Node type
 * @param $callback
 *   The callback of the process function to allow specific call of wimprt_create_or_load_object_CALLBACK
 * @param $log
 *
 * @return
 *   A node object
 */
function wimprt_create_or_load($dom, $importer, $objecttype, $callback,&$log){
  $node = new stdClass;
  $function_exist = FALSE;
  foreach ($importer->importer_functions as $importer_function){
    if (function_exists($importer_function.'_create_or_load_'.$objecttype."_".$callback)){
      $node = call_user_func($importer_function."_create_or_load_".$objecttype."_".$callback, $dom, &$log, $importer);
      $function_exist = TRUE;
      break;
    }
  }
  if ($function_exist == FALSE & function_exists("wimprt_create_or_load_".$objecttype."_".$callback)){
    $node = call_user_func("wimprt_create_or_load_".$objecttype."_".$callback, $dom, &$log, $importer);
  }
  return $node;
}

function wallymport_page_test($importeur){
  $content .= '<form enctype="multipart/form-data" action="/wallymport/post/'.$importeur.'/preview" method="POST">
        Choose a file to upload: <input name="uploadedfile" type="file" /><br />
        <input type="submit" value="Upload File" />
      </form>';

  return $content;
}

/**
 * @} End of "defgroup wallymport_process_default".
 */
