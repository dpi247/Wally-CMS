<?php
/**
 * @defgroup cckdestination Wally CCK Destination Functions
 * @{
 * In this module we define a new CCK field for destinatins (4 cascading select).  
 */

include_once('cckdestinations.features.inc');
include_once('cckdestinations.views_default.inc');

/**
 * Implementation of hook_perm()
 */
function cckdestinations_perm() {
  return array(
    'administer cckdestinations',
  );
}

/**
 * Implementation of hook_menu().
 */
function cckdestinations_menu() {
  $items = array();
  
  $items['admin/wally/cckdestinations/settings'] = array(
    'title' => t('CCKDestinations Settings'),
    'description' => t('Manage settings used for destinations (ranks, layouts, autocomplete, multiple destinations)'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cckdestinations_page_multiple_destinations_form'),
    'access arguments' => array('administer cckdestinations'),
    'file' => 'includes/cckdestinations.settings_admin.inc',
  );
  
  $items['admin/wally/cckdestinations/settings/multipledests'] = array(
    'title' => t('Multiple Destinations'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cckdestinations_page_multiple_destinations_form'),
    'access arguments' => array('administer cckdestinations'),
    'file' => 'includes/cckdestinations.settings_admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );
  
  $items['admin/wally/cckdestinations/settings/multipledests/delete'] = array(
    'title' => t('Delete'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cckdestinations_page_multiple_destinations_delete_form'),
    'access arguments' => array('administer cckdestinations'),
    'file' => 'includes/cckdestinations.settings_admin.inc',
    'type' => MENU_CALLBACK,
  );
  
  $items['admin/wally/cckdestinations/settings/rankslayouts'] = array(
    'title' => t('Ranks and Layouts'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cckdestinations_page_ranks_layouts_form'),
    'access arguments' => array('administer cckdestinations'),
    'file' => 'includes/cckdestinations.settings_admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );
  
  $items['admin/wally/cckdestinations/settings/autocomplete'] = array(
    'title' => t('Taxonomy Autocomplete'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cckdestinations_page_taxonomy_autocomplete_form'),
    'access arguments' => array('administer cckdestinations'),
    'file' => 'includes/cckdestinations.settings_admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  
  $items['admin/wally/cckdestinations/node'] = array(
    'title' => t('Content by destinations'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cckdestinations_node_admin_content'),
    'access arguments' => array('administer nodes'),
    'description' => 'View, edit, and delete your site\'s content with a destination filter.',
    'file' => 'includes/cckdestinations.node_admin.inc',
  );
  
  $items['admin/wally/cckdestinations/batch'] = array(
    'title' => t('Batch destinations change'),
    'page callback' => 'cckdestinations_batch_destinations',
    'access arguments' => array('administer nodes'),
    'description' => 'Change nodes destination in a batch process.',
    'file' => 'includes/cckdestinations.batch_dest.inc',
  );
  
  $items['cckdestinations/autocomplete'] = array(
    'title' => t('Autocomplete'),
    'page callback' => 'cckdestinations_autocomplete_load',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  
  $items['cckdestinations/js_add_more'] = array(
    'page callback' => 'cckdestinations_add_more_js',
    'access arguments' => array('administer nodes'),
    'file' => 'includes/cckdestinations.node_form.inc',
    'type' => MENU_CALLBACK,
  );
  
  $items['cckdestinations/remove'] = array(
    'title' => t('Remove destination'),
    'page callback' => 'cckdestinations_remove_ahah',
    'access arguments' => array('administer nodes'),
    'type' => MENU_CALLBACK
  );
  
  return $items;
}

/**
 * Implementation of hook_field_info().
 */
function cckdestinations_field_info(){
  return array(
    'destinationsfield' => array(
      'label' => t('Destinations'),
      'description' => t('Destinations for wally instances (triple )'),
    ),
  );
}

/**
 * Implementation of hook_action_info()
 */
function cckdestinations_action_info() {
  return array(
    'cckdestinations_batch_dest_change' => array(
      'type' => 'node',
      'description' => t('Change destination'),
      'configurable' => TRUE,
      'hooks'=> array('any'=>TRUE),
    ),
    'cckdestinations_batch_dest_add' => array(
      'type' => 'node',
      'description' => t('Add destination'),
      'configurable' => TRUE,
      'hooks'=> array('any'=>TRUE),
    ),
    'cckdestinations_batch_dest_remove' => array(
      'type' => 'node',
      'description' => t('Remove destination'),
      'configurable' => FALSE,
      'hooks'=> array('any'=>TRUE),
    ),
  );
}

/**
 * Implementation of hook_field_settings() for cck_destination
 * 
 * Create an form element to be used on the field settings form. Field
 * settings will be same for all shared instances of the same field. 
 * Also define how data will be stored into database
 * 
 * @param: $op
 *   - "database columns": Declare the columns that content.module should create
 *     and manage on behalf of the field. If the field module wishes to handle
 *     its own database storage, this should be omitted.
 *   - "views data": 
 * @param: $field
 *   The field on which the operation is to be performed.
 * 
 * @return Nothing
 */
function cckdestinations_field_settings( $op, $field ){
  switch( $op ) {
    case 'database columns':
      $columns['tid'] = array('type' => 'int', 'length' => 10, 'not null' => FALSE, 'sortable' => TRUE, 'default' => 0, 'index' => TRUE);
      $columns['target'] = array('type' => 'varchar', 'length' => 255, 'not null' => FALSE, 'sortable' => FALSE, 'default' => '');
      $columns['layout'] = array('type' => 'varchar', 'length' => 255, 'not null' => FALSE, 'sortable' => FALSE, 'default' => '');
      $columns['rank'] = array('type' => 'int', 'size' => 'normal', 'not null' => FALSE, 'sortable' => TRUE, 'default' => 0);
      $columns['time_rank'] = array('type' => 'int', 'size' => 'normal', 'not null' => FALSE, 'sortable' => TRUE, 'default' => 0);
      return $columns;
      break;
    case 'views data':
      module_load_include('inc', 'cckdestinations', 'views/cckdestinations.views');
      return cckdestinations_views_content_field_data($field);
      break;
  }
}

/**
 * Implementation of CCK hook_field().
 */
function cckdestinations_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {
    case 'validate':
      $hierarchies = wallyctools_get_hierarchies();
      foreach ($items as $item) {
        if (!isset($hierarchies[$item['tid']]['redacblocks'][$item['target']])) {
          return FALSE;
        }
      }
      return TRUE;
      break;
    case 'sanitize':
      foreach ($items as $delta => $item) {
        foreach ( $item as $col => $dat ) {
          $items[$delta]['safe_' . $col ] = check_plain($item[ $col ]);
        }
      }
      break;
    case 'presave':
      _cckdestinations_reorder_values($field, $items);
      _cckdestinations_set_new_time_ranks($node, $items);
      break;
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function cckdestinations_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'presave' :
      if(($node->type == 'wally_articlepackage' ||
        $node->type == 'wally_gallerypackage' ||
        $node->type == 'wally_pollpackage') &&
        isset($node->field_destinations)) {
          _cckdestinations_add_topic_for_destination($node);
          module_load_include('inc', 'wallycontenttypes', 'includes/wallycontenttypes.node_form');
          _wallycontenttypes_addtaxonomywheninserted($node, NULL, TRUE);
          $node->no_taxonomy_update = TRUE;
      }
      break;
  }
}
/**
 * Implementation of hook_taxonomy.
 */
function cckdestinations_taxonomy($op, $type, $array = NULL) {
  if ($type == 'term') {
    switch ($op) {
      case 'delete' :
        $dest_vid = variable_get('wallymport_destinationpath', 0);
        if ($array['vid'] == $dest_vid) {
          if (isset($array['topic_destination'])) {
            $term = (array)taxonomy_get_term($array['topic_destination']);
            $term['topic_destination'] = 0;
            taxonomy_save_term($term);
          }
          _cckdestinations_remove_destination_from_nodes($array['tid']);
        }
        break;
    }
  }
}

/**
 * Implementation of hook_content_is_empty().
 */
function cckdestinations_content_is_empty($item, $field) {
  if (isset($item['tid']) && !empty($item['tid']) && !is_numeric($item['tid']) && is_string($item['tid'])) {
    $extract_tid = cckdestinations_autocomplete_split_tags($item['tid']);
    $item['tid'] = $extract_tid[0];
  }

  if (!isset($item['tid']) || empty($item['tid']) || $item['tid'] == '0' || !is_numeric($item['tid'])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implementation of hook_widget_info().
 */
function cckdestinations_widget_info() {
  return array(
    'cckdestinations_widget' => array(
      'label' => t('Destination Select  fields'),
      'field types' => array('destinationsfield'),
      'multiple values' => CONTENT_HANDLE_MODULE,
      //'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of Form API's hook_elements().
 *
 * @Returns A skeleton Form API array that defines callbacks for the widget form.
 */
function cckdestinations_elements() {
  $elements = array(
    'cckdestinations_widget' => array(
      '#input' => TRUE,
      '#process' => array('cckdestinations_cckdestinations_widget_process'),
    ),
    'cckdestinations_autocomplete' => array(
      '#input' => TRUE,
      '#columns' => array('value'), 
      '#delta' => 0,
      '#process' => array('cckdestinations_autocomplete_process'),
      '#autocomplete_path' => FALSE,
    ),
    'select' => array(
      '#process' => array('cckdestinations_select_process'),
    ),
  );
  return $elements;
}

/**
 * Implementation of hook_form_alter()
 */
function cckdestinations_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'taxonomy_form_term') {
    if (module_exists('taxonomy_vocab_relate')) {
      $vid = $form['#vocabulary']['vid'];
      $related_vid = variable_get('taxonomy_vocab_relate_'. $vid, array());

      foreach ($related_vid as $rvid) {
        $relation_form = &$form['advanced']['relations_'. $rvid];
        $relation_form['#vid'] = $rvid;
      }
    }
  } elseif ($form_id == 'content_add_more_js') {
    if (isset($form['field_destinations'])) {
      $form_copy = $form['field_destinations'];
      unset($form_copy['field_destinations_add_more']);
      $temp_elem = array();

      foreach (element_children($form_copy) as $i) {
        $temp_elem[$i] = $form['field_destinations'][$i];
        unset($form['field_destinations'][$i]);
      }
      
      foreach (element_children($form_copy) as $i) {
        $form['field_destinations'][$temp_elem[$i]['#delta']] = $temp_elem[$i];
      }
    }
  } elseif (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {
    $type = content_types($form['#node']->type);
    if (!empty($type['fields'])) {
      if (isset($form['field_destinations'])) {
        $form['field_destinations']['#element_validate'][] = 'cckdestinations_form_field_destinations_validate';
        $form['field_destinations']['field_destinations_add_more']['#submit'][0] = 'cckdestinations_add_more_submit_proxy';
        $form['field_destinations']['field_destinations_add_more']['#ahah']['path'] = str_replace('//', '/', 'cckdestinations/js_add_more/'.$form['type']['#value'].'/field_destinations/'.$type['fields']['field_destinations']['display_settings']['parent'].'/field_destinations');
        $form['field_destinations']['#parents'] = array('field_destinations');
      }
    }
  }
}

function cckdestinations_form_field_destinations_validate ($element, $form_state, $form) {
  $values = $form_state['values'];
  $field_name = $element['#field_name'];
  $pack_type = $element['#type_name'];
  $field = content_fields($field_name, $pack_type);

  if (isset($form_state['parents'])) {
    module_load_include('inc', 'wallytoolbox', 'includes/wallytoolbox.helpers');
    $values = wallytoolbox_get_target_from_parents($values, $form_state['parents']);
  }

  if (isset($values[$field_name])) {
    $field_values = $values[$field_name];
  } elseif (isset($field['display_settings']['parent']) && isset($values[$field['display_settings']['parent']][$field_name])) {
    $field_values = $values[$field['display_settings']['parent']][$field_name];
  } else {
    $field_values = $values[$pack_type][$field_name];
  }
  unset($field_values['field_destinations_add_more']);

  $empty = TRUE;
  $hook_is_empty = $field['module'].'_content_is_empty';
  $check_double = array();
  foreach ($field_values as $delta => $field_value) {
    if (!$hook_is_empty($field_value, $field)) {
      $empty = FALSE;
      
      if (!in_array($field_value['tid'].':'.$field_value['target'], $check_double)) {
        $check_double[] = $field_value['tid'].':'.$field_value['target'];
      } else {
        $doubled_term = taxonomy_get_term($field_value['tid']);
        form_error($element, t('Destinations error : the same destination path (@term_name) has been used more than once with the same target.', array('@term_name' => $doubled_term->name)));
      }
    }
  }

  if ($empty) {
    form_error($element, t('Destination field is required.'));
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter()
 */
function cckdestinations_form_taxonomy_form_term_alter(&$form, &$form_state) {
  $dest_vid = variable_get('wallymport_destinationpath', 0);
  
  $form['#validate'][] = 'cckdestinations_form_taxonomy_form_term_alter_validate';

  if (isset($form['tid']) && $form['#vocabulary']['vid'] != $dest_vid) {
    cckdestinations_form_election_form($form, $form_state, $dest_vid);
  }
}

function cckdestinations_form_taxonomy_form_term_alter_validate(&$form, &$form_state) {
  $values = &$form_state['values'];
  
  if (strstr($values['name'], '/')) {
    form_set_error('name', t('The name of the taxonomy term can\'t contain any slashes ("/")'));
  }

  if ($values['op'] == $values['submit'] && isset($form['advanced']['election'])) {
    $vocabulary = $form['#vocabulary'];
    $term = $form['#term'];
    if ($values['topic_destination']) {
      $new_term = _cckdestinations_create_or_update_topic_destination($values, $term);
      
      /*if (is_array($new_term) && $values['recup_old']) {
         $recup_tids = array($term['tid']);
         if ($values['apply_to_child']) {
           $childrens = taxonomy_get_children($term['tid']);
           $recup_tids = array_merge($recup_tids, array_keys($childrens));
         }
       	_cckdestinations_apply_topic_destination_to_nodes($new_term, $recup_tids);
       }*/
    } else {
      _cckdestinations_remove_topic_destination($values, $vocabulary, $term);
    }
  }
}

function cckdestinations_form_election_form(&$form, &$form_state, $dest_vid) {
  ctools_include('dependent');
  ctools_add_js('dependent');

  $vocabulary = $form['#vocabulary'];
  $term = $form['#term'];
  $election_form = array(
    '#title' => t('Elect this term as destination'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => -20,
  );

  $default_topic_destination = (isset($term['topic_destination']) && $term['topic_destination'] != 0) ? $term['topic_destination'] : '0';
  $election_form['topic_destination'] = array(
    '#type' => 'checkbox',
    '#title' => t('Elect this term as destination'),
    '#default_value' => ($default_topic_destination != '0'),
    '#id' => 'topic-destination-checkbox',
  );

  $parent = $term['topic_destination'];
  $cur_dests = taxonomy_get_tree($dest_vid);
  foreach ($cur_dests as $dest) {
    if ($dest->tid == $default_topic_destination) {
      $elected_term = $dest;
      break;
    }
  }

  $default_parent = $elected_term ? $elected_term->parents[sizeof($elected_term->parents) - 1] : null;
  $exclude = ($default_topic_destination != '0') ? array($default_topic_destination) : array();
  $election_form['elected_parent'] = _taxonomy_term_select(t('Parent'), 'parent', $default_parent, $dest_vid, t('Parent term') .'.', FALSE, '<'. t('root') .'>', $exclude);
  unset($election_form['elected_parent']['#weight']);
  $election_form['elected_parent']['#process'][] = 'ctools_dependent_process';
  $election_form['elected_parent']['#dependency']['topic-destination-checkbox'] = array(1);

  /*$election_form['recup_old'] = array(
    '#type' => 'radios',
    '#title' => t(''),
    '#default_value' => 0,
    '#options' => array(t('Start from a empty destination'), t('Apply the change to nodes currently present in this topic')),
    '#prefix' => '<div id="edit-recup-old-wrapper">',
    '#suffix' => '</div>',
    '#process' => array('ctools_dependent_process', 'expand_radios'),
    '#dependency' => array('topic-destination-checkbox' => array(1)),
  );

  $election_form['apply_to_child'] = array(
    '#type' => 'checkbox',
    '#title' => t('Also apply to this term\'s children'),
    '#default_value' => 0,
    '#process' => array('ctools_dependent_process'),
    '#dependency' => array('radio:recup_old' => array('1')),
  );*/

  $form['advanced']['election'] = $election_form;
}

/**
 * Implémentation du hook_schema_alter.
 */
function cckdestinations_schema_alter (&$schema) {
  if ($schema['term_data']) {
    $schema['term_data']['fields']['topic_destination'] = array(
      'type' => 'int',
      'description' => 'Tells if a term has been elected as destination and gives the related tid.',
      'not null' => TRUE, 
      'default' => 0,
    );
  }
}

/**
 * Implementation of hook_ccimapping_productinfo_alter
 * Add the multiple destinations to product info
 */
function cckdestinations_ccimapping_productinfo_alter(&$dom, $op) {
  if ($op == 'before_send') {
    $multiple_dests = cckdestinations_get_multiple_dests();
    $budgettemplate = $dom->getElementsByTagName('budgettemplate')->item(0);
    foreach ($multiple_dests as $multi_dest) {
      $dom_level = NULL;
      if (is_numeric($multi_dest['parent']) && $multi_dest['parent'] != 0) {
        $parent_path = wallytoolbox_taxonomy_get_path_by_tid_or_term($multi_dest['parent']);
        $parents = explode('/', $parent_path);
        $depth = sizeof($parents);
        $parent = array_pop($parents);
        $levels = $budgettemplate->getElementsByTagName('level'.$depth);
        if ($levels->item(0)) {
          foreach ($levels as $level) {
            if ($level->getAttributeNode('name')->value == $parent) {
              $depth++;
              $dom_level = $level->appendChild($dom->createElement('level'.$depth));
              break;
            }
          }
        }
      }
      if (!$dom_level) {
        $dom_level = $budgettemplate->appendChild($dom->createElement('level1'));
      }

      $dom_level->setAttribute('name', $multi_dest['virtual']);
      $target_intersect = cckdestinations_multiple_dests_get_target_intersect($multi_dest['reals']);
      unset($target_intersect['none']);
      $first = TRUE;
      foreach ($target_intersect as $redack_machine_name => $redacblock) {
        $leaf = $dom_level->appendChild($dom->createElement('leaf'));
        $leaf->setAttribute('name', $redack_machine_name);
        //@todo hardcoding to remove
        if ($first) {
          $leaf->setAttribute('default', 'true');
          $first = FALSE;
        }
      }
    }
  }
}

function cckdestinations_add_more_submit_proxy($form, &$form_state) {
  module_load_include('inc', 'cckdestinations', 'includes/cckdestinations.node_form');
  cckdestinations_add_more_submit($form, $form_state);
}

/**
 * Process callback for widget
 *
 * @return A Forms API array that defines the widget's editing form.
 */
function cckdestinations_cckdestinations_widget_process($element, $edit, &$form_state, $form) {
  $defaults = $element['#value'];
  $field = content_fields($element['#field_name'], $element['#type_name']);
  $vocabulary_id = variable_get('wallymport_destinationpath', 0);
  $options_and_classe = cckdestinations_get_classes_and_options();

  $element['tid'] = array(
    '#title'            => t( 'Destination Path' ),
    '#type'             => 'select',
    '#default_value'    => $defaults['tid'],
    '#options'          => array(array('Not Set')) + $options_and_classe['tid']['#options'],
    '#required'         => FALSE,
    '#weight'           => 1,
    '#theme'            => 'cckdestinations_cascading_select',
    '#attributes'       => array('class' => 'tid'),
    '#vid'              => $vocabulary_id,
  );

  $element['target'] = array(
    '#title'            => t( 'Target' ),
    '#type'             => 'select',
    '#default_value'    => $defaults['target'],
    '#options'          => $options_and_classe['target']['#options'],
    '#classes'          => $options_and_classe['target']['#classes'],
    '#required'         => FALSE,
    '#weight'           => 3,
    '#theme'            => 'cckdestinations_cascading_select',
    '#attributes'       => array('class' => 'target'),
  );
  
  $element['layout'] = array(
    '#title'            => t( 'Layout' ),
    '#type'             => 'select',
    '#default_value'    => $defaults['layout'],
    '#options'          => $options_and_classe['layout']['#options'],
    '#classes'          => $options_and_classe['layout']['#classes'],
    '#required'         => FALSE,
    '#weight'           => 4,
    '#theme'            => 'cckdestinations_cascading_select',
    '#attributes'       => array('class' => 'layout'),
  );
  
  $rank_values = array();
  $rank_classes = array();
  $rank_limit = wally_variable_get('cckdestinations_rank_limit', '10');

  if (!cckdestinations_content_is_empty($defaults, array()) && ($defaults['target'] != 'none') && isset($defaults['rank']) && $defaults['rank'] != '' && isset($defaults['time_rank']) && $defaults['time_rank'] != '') {
    $default_value=current(explode('DNC',$defaults['rank']));
    $default_value=next(explode('DNC',$defaults['rank'])).$default_value;
    $defaults['rank'] = $default_value;
    $rank_values['DNC'.$defaults['rank']] = t('Do Not Change (Actual : ').$defaults['rank'].')';
    $rank_classes['DNC'.$defaults['rank']] = t('Class DNC');
  }
  
  for ($i=0; $i<=$rank_limit; $i++) {
    $rank_values[$i] = t('Rank ').$i;
    $rank_classes[$i] = t('Class R').$i;
  }

  $element['rank'] = array(
    '#title'            => t( 'Rank' ),
    '#type'             => 'select',
    '#default_value'    => array_key_exists('DNC'.$defaults['rank'], $rank_values) ? 'DNC'.$defaults['rank'] : $defaults['rank'],
    '#options'          => $rank_values,
    '#classes'          => $rank_classes,
    '#required'         => FALSE,
    '#weight'           => 5,
  );
  
  $element['time_rank'] = array(
    '#title'            => t( 'Time Rank' ),
    '#type'             => 'hidden',
    '#value'            => $defaults['time_rank'],
    '#required'         => FALSE,
    '#weight'           => 5,
  );

  if (isset($defaults['tid']) && $defaults['tid']) {
    $field_name = $element['#field_name'];
    $pack_type = $element['#type_name'];
    $delta = $element['#delta'];
    $parent = isset($form[$pack_type]['#field_info'][$field_name]['display_settings']['parent']) ? $form[$pack_type]['#field_info'][$field_name]['display_settings']['parent'] : $form['#field_info'][$field_name]['display_settings']['parent'];
    $parents = array(
      $parent,
      $field_name,
    );
    $element['delete'] = array(
      '#title'            => t('Delete'),
      '#type'             => 'submit',
      '#value'            => t('Remove destination'),
      '#ahah'             => array(
        'path'            => 'cckdestinations/remove/'.$pack_type.'/'.$delta.'/'.implode('/', $parents),
        'wrapper'         => 'field-destinations-items',
        'method'          => 'replace',
        'effect'          => 'fade',
      ),
      '#weight'           => 6,
    );
  }
  
  $element['#after_build'][] = 'cckdestinations_cckdestinations_widget_after_build';

  return $element;
}

function cckdestinations_cckdestinations_widget_after_build ($form, $form_state) {
  $field_name = $form['#field_name'];
  $pack_type = $form['#type_name'];
  $delta = $form['#delta'];
  $field = content_fields($field_name, $pack_type);

  $values = $form_state['values'];
  $field_values = isset($values[$pack_type][$field_name]) ? $values[$pack_type][$field_name] : $values[$field_name];
  if (isset($field_values[$delta]) && !empty($field_values[$delta])) {
    $hook_is_empty = $field['module'].'_content_is_empty';
    if ($hook_is_empty($field_values[$delta], $field)) {
      foreach (element_children($form) as $key) {
        if (isset($form[$key]['#needs_validation'])) {
          unset($form[$key]['#needs_validation']);
        }
      }
    }
  }
  return $form;
}

function cckdestinations_batch_dest_change_form($context) {
  return cckdestinations_batch_dest_form($context);
}

function cckdestinations_batch_dest_add_form($context) {
  return cckdestinations_batch_dest_form($context);
}

function cckdestinations_batch_dest_change_submit($form, $form_state) {
  return cckdestinations_batch_dest_submit($form, $form_state);
}

function cckdestinations_batch_dest_add_submit($form, $form_state) {
  return cckdestinations_batch_dest_submit($form, $form_state);
}

function cckdestinations_batch_dest_form($context) {
  $form = array();

  module_load_include("inc", 'content', 'includes/content.node_form');
  $destinations = content_fields('field_destinations');
  $form['destinations'] = (array) content_field_form($form, $form_state, $destinations);
  $form['destinations']['#weight'] = 3;
  unset($form['destinations']['field_destinations'][1]);
  unset($form['destinations']['field_destinations']['field_destinations_add_more']);
  unset($form['destinations']['#weight']);
  unset($form['destinations']['field_destinations'][0]['_weight']);
  unset($form['destinations']['field_destinations']['#theme']);
  $form['destinations']['field_destinations']['#type'] = 'fieldset';
  $form['destinations']['field_destinations']['#title'] = t('New destination');
  $form['destinations']['field_destinations']['#tree'] = FALSE;
  
  return $form;
}

function cckdestinations_batch_dest_submit($form, $form_state){
  $returns = array();
  
  $returns['new_dest'] = array(
    'tid' => $form_state['values']['tid'],
    'target' => $form_state['values']['target'],
    'layout' => $form_state['values']['layout'],
    'rank' => $form_state['values']['rank'],
  );
  
  return $returns;
}

/**
 * Process of changing a destination from a list of nodes.
 * 
 * @param array $nodes
 *   Array of nid.
 */
function cckdestinations_batch_dest_change($node, $context, $a, $b) {
  $node = node_load($node->nid);
  cckdestinations_force_dnc($node);
  $tid = $context['view']['arguments'][0];
  $target = $context['view']['arguments'][1];
  $posted_dest = $context['new_dest'];

  foreach ($node->field_destinations as $delta => $dest) {
    if ($dest['tid'] == $tid && $dest['target'] == $target) {
      $node->field_destinations[$delta]['tid'] = $posted_dest['tid'];
      $node->field_destinations[$delta]['target'] = $posted_dest['target'];
      $node->field_destinations[$delta]['layout'] = $posted_dest['layout'];
      $node->field_destinations[$delta]['rank'] = $posted_dest['rank'];
      break;
    }
  }

  node_save($node);
}

/**
 * Process of removing a destination from a list of nodes.
 * 
 * @param array $nodes
 *   Array of nid.
 */
function cckdestinations_batch_dest_remove($node, $context, $a, $b) {
  $node = node_load($node->nid);
  $tid = $context['view']['arguments'][0];
  $target = $context['view']['arguments'][1];
  
  if (count($node->field_destinations) > 1) {
    foreach ($node->field_destinations as $delta => $dest) {
      if ($dest['tid'] == $tid && $dest['target'] == $target) {
        unset($node->field_destinations[$delta]);
        break;
      }
    }
    cckdestinations_force_dnc($node);
    node_save($node);
  } else {
    drupal_set_message(t('Node "@title" (nid: @nid) has only this destination, impossible to remove!', array('@title' => $node->title, '@nid' => $node->nid)), 'error');
  }
}

/**
 * Process of adding a destination to a list of nodes.
 * 
 * @param array $nodes
 *   Array of nid.
 */
function cckdestinations_batch_dest_add($node, $context, $a, $b) {
  $node = node_load($node->nid);
  cckdestinations_force_dnc($node);
  $posted_dest = $context['new_dest'];
  $new_dest = array(
    'tid' => $posted_dest['tid'],
    'target' => $posted_dest['target'],
    'layout' => $posted_dest['layout'],
    'rank' => $posted_dest['rank'],
  );
  $node->field_destinations[] = $new_dest;
  node_save($node);
}

/**
 * Helper function to provide #options and #class to cckDestinations fields
 * 
 * 
 * @return an array with  "target" and "layout" key both are array with #options 
 * and #classes keys to put in the form definition
 */
function cckdestinations_get_classes_and_options(){
  $result['tid']['#options'] = array();
  $result['target']['#options'] = array();
  $result['target']['#classes'] = array();
  $result['layout']['#options'] = array();
  $result['layout']['#classes'] = array();

  $hierarchies = wallyctools_get_hierarchies();
  foreach($hierarchies as $tid => $hierarchie){
    // Target
    foreach($hierarchie['redacblocks'] as $redacblock_id => $redacblock){
      // Layout
      foreach($redacblock['layouts'] as $layout_id => $name){
        $result['tid']['#options'][$tid] = array($tid => $hierarchie['hierarchic_name']);
        $result['target']['#options'][$tid.$redacblock_id] = array($redacblock_id => $redacblock['title']);
        $result['target']['#classes'][$tid.$redacblock_id] = array($redacblock_id => $tid);
        $result['layout']['#options'][$tid.$redacblock_id.$layout_id] = array($layout_id => $name['name']);
        $result['layout']['#classes'][$tid.$redacblock_id.$layout_id] = array($layout_id => $tid.$redacblock_id);
      }
    }
  }

  return $result;
}

/**
 * Implementation of hook_theme() for cascading select.
 * 
 * Call to cckdestinations_cascading_select_options() for theming "option". 
 *
 * @return HTML select form element. 
 */
function theme_cckdestinations_cascading_select($element) {
  $select = '';
  $size = $element['#size'] ? ' size="'. $element['#size'] .'"' : '';
  _form_set_class($element, array('form-select'));
  $multiple = $element['#multiple'];
  return theme('form_element', $element, '<select name="'. $element['#name'] .''. ($multiple ? '[]' : '') .'"'. ($multiple ? ' multiple="multiple" ' : '') . drupal_attributes($element['#attributes']) .' id="'. $element['#id'] .'" '. $size .'>'. cckdestinations_cascading_select_options($element) .'</select>');
}

/**
 * Specific theming function for Options on Cascading Selects.
 * 
 * Purpose is to add a html class attribute: sub_xxxx so, jquery can
 * act on these specials options (hide or show). 
 *
 * @return HTML options form elements. 
 */
function cckdestinations_cascading_select_options($element, $choices = NULL) {
  $choices = $element['#options'];
  $classes = $element['#classes'];

  $module_path = drupal_get_path('module', 'cckdestinations') .'/';
  drupal_add_js($module_path .'js/cckdestinations.js');

  // array_key_exists() accommodates the rare event where $element['#value'] is NULL.
  // isset() fails in this situation.
  $value_valid = isset($element['#value']) || array_key_exists('#value', $element);
  $value_is_array = is_array($element['#value']);
  foreach ($choices as $k => $c) {
    $key = array_keys($c);
    $key = $key[0];
    $choice = $c[$key];

    if ($classes[$k]) {
      $class = 'class="sub_'.$classes[$k][$key].'" ';
    }
  
    if (is_array($choice)) {
      $options .= '<optgroup label="'. $key .'">';
      $options .= form_select_options($element, $choice);
      $options .= '</optgroup>';
    }
    elseif (is_object($choice)) {
      $options .= form_select_options($element, $choice->option);
    }
    else {
      $key = (string)$key;
      if ($value_valid && (!$value_is_array && (string)$element['#value'] === $key || ($value_is_array && in_array($key, $element['#value'])))) {
        $selected = ' selected="selected"';
      }
      else {
        $selected = '';
      }
      $option = '<option '.$class.'title="'.check_plain($k).'" value="'. check_plain($key) .'"'. $selected .'>'. check_plain($choice) .'</option>\n';
      $options .= $option;
      
    }
  }
  return $options;
}

/**
 * FAPI theme for an individual text elements.
 */
function theme_cckdestinations_widget($element) {
  return $element['#children'];
}

/**
 * Implementation of hook_widget().
 */
function cckdestinations_widget(&$form, &$form_state, $field, $items, $delta = 0, $sub_level = FALSE) {
  if ($sub_level) {
    $element = array(
      '#type' => $field['widget']['type'],
      '#default_value' => isset($items[$delta]) ? $items[$delta] : '',
    );
  } else {
    if (isset($items['field_destinations_add_more'])) {
      unset($items['field_destinations_add_more']);
    }

    //$filled_items = cckdestinations_content_set_empty($field, $items);
    $filled_items = array();
    $function = $field['module'] .'_content_is_empty';
    foreach ((array)$items as $delta => $item) {
      if (!$function($item, $field)) {
        $filled_items[$delta] = $item;
      }
    }

    // Adaptation of "content_multiple_value_form" function form CCK
    $field_name = $field['field_name'];
    $hook_is_empty = $field['module'] .'_content_is_empty';

    $deltas_items = $filled_items;
    unset($deltas_items['item_count']);
    unset($items['item_count']);
    $deltas = array_keys($deltas_items);

    if (count($deltas) == 1 && $hook_is_empty($items[min(array_keys($items))], $field)) {
      $minimum_item_count = 0;
    } else {
      $minimum_item_count = count($deltas);
    }
    $current_item_count = isset($form_state['values']['field_destinations']['item_count'][$field_name])
                          ? $form_state['values']['field_destinations']['item_count'][$field_name]
                          : $minimum_item_count;

    if (count($deltas) > 1 || $current_item_count >= 1) {
      $deltas[] = !empty($deltas) ? max($deltas) + 1 : 1;
    }

    if (count($deltas) < $current_item_count) {
      $deltas[] = !empty($deltas) ? max($deltas) + 1 : 1;
    }
    
    if (count($deltas) == 0) {
      $deltas[] = 0;
    }

    $title = check_plain(t($field['widget']['label']));
    $description = content_filter_xss(t($field['widget']['description']));

    $form_element = array(
      '#theme' => 'content_multiple_values',
    );

    $function = $field['widget']['module'] .'_widget';

    foreach ($deltas as $delta) {
      if ($element = $function($form, $form_state, $field, $items, $delta, TRUE)) {
        $defaults = array(
          '#title' => ($field['multiple'] >= 1) ? '' : $title,
          '#description' => ($field['multiple'] >= 1) ? '' : $description,
          '#required' => $delta == 0 && $field['required'],
          '#weight' => $delta,
          '#delta' => $delta,
          '#columns' => array_keys($field['columns']),
          '#field_name' => $field_name,
          '#type_name' => $field['type_name'],
        );

        // Add an input field for the delta (drag-n-drop reordering), which will
        // be hidden by tabledrag js behavior.
        // We name the element '_weight' to avoid clashing with column names
        // defined by field modules.
        $element['_weight'] = array(
          '#type' => 'weight',
          '#delta' => 100,//max($deltas), // this 'delta' is the 'weight' element's property
          '#default_value' => isset($items[$delta]['_weight']) ? $items[$delta]['_weight'] : $delta,
          '#weight' => 100,
        );

        $form_element[$delta] = array_merge($element, $defaults);
      }
    }

    // Add AHAH add more button, if not working with a programmed form.
    if ($field['multiple'] == 1 && empty($form['#programmed'])) {
      // Make sure the form is cached so ahah can work.
      $form['#cache'] = TRUE;
      $content_type = content_types($field['type_name']);
      $field_name_css = str_replace('_', '-', $field_name);

      $form_element[$field_name .'_add_more'] = array(
        '#type' => 'submit',
        '#name' => $field_name .'_add_more',
        '#value' => t('Add another item'),
        '#weight' => $field['widget']['weight'] + $max + 1,
        // Submit callback for disabled JavaScript. drupal_get_form() might get
        // the form from the cache, so we can't rely on content_form_alter()
        // including this file. Therefore, call a proxy function to do this.
        '#submit' => array('content_add_more_submit_proxy'),
        '#ahah' => array(
          'path' => 'content/js_add_more/'. $content_type['url_str'] .'/'. $field_name,
          'wrapper' => $field_name_css .'-items',
          'method' => 'replace',
          'effect' => 'fade',
        ),
        // When JS is disabled, the content_add_more_submit handler will find
        // the relevant field using these entries.
        '#field_name' => $field_name,
        '#type_name' => $field['type_name'],
      );

      // Add wrappers for the fields and 'more' button.
      $form_element['#prefix'] = '<div id="'. $field_name_css .'-items">';
      $form_element['#suffix'] = '</div>';
      $form_element[$field_name .'_add_more']['#prefix'] = '<div class="content-add-more clear-block">';
      $form_element[$field_name .'_add_more']['#suffix'] = '</div>';
    }
    
    $element = $form_element;
  }
  
  return $element;
}

/**
 * Helper function to filter out empty values.
 *
 * On order to keep marker rows in the database, the function ensures
 * that the right number of 'all columns NULL' values is kept.
 *
 * @param array $field
 * @param array $items
 * @return array
 *   returns filtered and adjusted item array
 */
function cckdestinations_content_set_empty($field, $items) {
  // Filter out empty values.
  $filtered = array();
  $function = $field['module'] .'_content_is_empty';
  foreach ((array) $items as $delta => $item) {
    if (!$function($item, $field)) {
      $filtered[$delta] = $item;
    }
  }

  // Make sure we store the right number of 'empty' values.
  $empty = array();
  foreach (array_keys($field['columns']) as $column) {
    $empty[$column] = NULL;
  }
  $pad = $field['multiple'] > 1 ? $field['multiple'] : 1;
  $filtered = array_pad($filtered, $pad, $empty);

  return $filtered;
}

/**
 * Implementation of CCK's hook_field_formatter_info().
 *
 * @return Information about available field formatters.
 */
function cckdestinations_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t( 'Default Formater' ),
      'field types' => array( 'destinationsfield' ),
    ),
    'batch' => array(
      'label' => t( 'Batch Listing Formater' ),
      'field types' => array( 'destinationsfield' ),
    ),
    'tid' => array(
      'label' => t( 'Term Only Formater' ),
      'field types' => array( 'destinationsfield' ),
    ),
    'target' => array(
      'label' => t( 'Target Only Formater' ),
      'field types' => array( 'destinationsfield' ),
    ),
    'layout' => array(
      'label' => t( 'Layout Only Formater' ),
      'field types' => array( 'destinationsfield' ),
    ),
    'rank' => array(
      'label' => t( 'Rank Only Formater' ),
      'field types' => array( 'destinationsfield' ),
    ),
  );
}

/**
 * Implementation of hook_theme().
 *
 * @return Array of theme callback
 */
function cckdestinations_theme() {
  return array(
    'cckdestinations_widget' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_formatter_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_formatter_batch' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_formatter_tid' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_formatter_target' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_formatter_layout' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_formatter_rank' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_formatter_time_rank' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_cascading_select' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_node_filters' => array(
      'arguments' => array('form' => NULL),
      'file' => 'cckdestinations.admin.inc',
    ),
    'cckdestinations_autocomplete' => array(
      'arguments' => array('element' => NULL),
    ),
    'cckdestinations_page_multiple_destinations_form' => array(
      'arguments' => array('form' => array()),
    ),
    'cckdestinations_page_multiple_destinations_table_reals' => array(
      'arguments' => array('element' => array()),
    ),
    'cckdestinations_page_multiple_destinations_table_parent' => array(
      'arguments' => array('element' => array()),
    ),
  );
}

/**
 * Implementation of CCK's hook_field_formatter_default().
 *
 * @return HTML for destination form element
 */
function theme_cckdestinations_formatter_default($element = NULL) {
  if(empty($element['#item'])) {
    return '';
  }

  $stuff = $element['#item'];
  $flds = array('tid', 'target', 'layout', 'rank', 'time_rank');
  $sep = '';
  $ret='<div class="cckdestinationsgroup">';
  foreach($flds as $fld) {
    /*if(!empty($stuff['safe_' . $fld ])) {
      $ret .= $sep . '<span class="' . $fld . '">' . $stuff['safe_' . $fld ] . '</span>';
      $sep = "<br />\n";
    }*/
    $ret .= theme('cckdestinations_formatter_'.$fld, $element);
  }
  $ret .= '</div>';
  
  return $ret;
}

/**
 * Implementation of CCK's hook_field_formatter_default().
 *
 * @return HTML for destination form element
 */
function theme_cckdestinations_formatter_batch($element = NULL) {
  if(empty($element['#item'])) {
    return '';
  }

  $item = $element['#item'];
  $term = taxonomy_get_term($item['tid']);
  $ret = '<div class="cckdestinationsgroup">';
  $ret .= '<b>'.t('Destination').' '.$item['#delta'].' : </b><br>';
  $ret .= t('Term').' : '.$term->name.' | ';
  $ret .= t('Target').' : '.$item['target'].' | ';
  $ret .= t('Layout').' : '.$item['layout'].' | ';
  $ret .= t('Rank').' : '.$item['rank'];
  $ret .= '</div>';
  
  return $ret;
}

/**
 * Implementation of CCK's hook_field_formatter().
 *
 * @return HTML for destination form element
 */
function theme_cckdestinations_formatter_tid($element = NULL) {
  if(empty($element['#item'])) {
    return '';
  }

  $stuff = $element['#item'];

  $flds = array('tid');
  $sep = '';
  $ret='<div class="cckdestinations">';
  foreach($flds as $fld) {
    if(!empty($stuff['safe_' . $fld ])) {
      $ret .= $sep . '<span class="' . $fld . '">' . taxonomy_get_term($stuff['safe_' . $fld ])->name . '</span>';
      $sep = "<br />\n";
    }
  }
  $ret .= '</div>';
  return $ret;
}

/**
 * Implementation of CCK's hook_field_formatter for target element.  
 */
function theme_cckdestinations_formatter_target($element = NULL) {
  if(empty($element['#item'])) {
    return '';
  }

  $stuff = $element['#item'];

  $flds = array('target');
  $sep = '';
  $ret='<div class="cckdestinations">';
  foreach($flds as $fld) {
    if(!empty($stuff['safe_' . $fld ])) {
      $ret .= $sep . '<span class="' . $fld . '">' . $stuff['safe_' . $fld ] . '</span>';
      $sep = "<br />\n";
    }
  }
  $ret .= '</div>';
  return $ret;
}

/**
 * Implementation of CCK's hook_field_formatter for layout element.  
 */
function theme_cckdestinations_formatter_layout($element = NULL) {
  if(empty($element['#item'])) {
    return '';
  }

  $stuff = $element['#item'];

  $flds = array('layout');
  $sep = '';
  $ret='<div class="cckdestinations">';
  foreach($flds as $fld) {
    if(!empty($stuff['safe_' . $fld ])) {
      $ret .= $sep . '<span class="' . $fld . '">' . $stuff['safe_' . $fld ] . '</span>';
      $sep = "<br />\n";
    }
  }
  $ret .= '</div>';
  return $ret;
}

/**
 * Implementation of CCK's hook_field_formatter for rank element.  
 */
function theme_cckdestinations_formatter_rank($element = NULL) {
  if(empty($element['#item'])) {
    return '';
  }

  $stuff = $element['#item'];

  $flds = array('rank');
  $sep = '';
  $ret='<div class="cckdestinations">';
  foreach($flds as $fld) {
    if(isset($stuff['safe_' . $fld])) {
      $ret .= $sep . '<span class="' . $fld . '">' . $stuff['safe_' . $fld ] . '</span>';
      $sep = "<br />\n";
    }
  }
  $ret .= '</div>';
  return $ret;
}

/**
 * Implementation of CCK's hook_field_formatter for rank element.  
 */
function theme_cckdestinations_formatter_time_rank($element = NULL) {
  if(empty($element['#item'])) {
    return '';
  }

  $stuff = $element['#item'];
  $flds = array('time_rank');
  $sep = '';
  $ret='<div class="cckdestinations">';
  foreach($flds as $fld) {
    if(!empty($stuff['safe_' . $fld ])) {
      $ret .= $sep . '<span class="' . $fld . '">' . date('Y-m-d H:i:s', $stuff['safe_' . $fld ]) . '</span>';
      $sep = "<br />\n";
    }
  }
  $ret .= '</div>';
  return $ret;
}

/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement task and task_handler plugins.
 */
function cckdestinations_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return 'plugins/'.$plugin;
  }
}

function cckdestinations_token_list($type = 'all') {
  $tokens=array();
  
  if ($type == 'node') {
    $tokens['cckdest']['cckdest:destination_term'] = t("Main Destination Term");
    $tokens['cckdest']['cckdest:destination_term_path'] = t("Main Destination Term path");
    $tokens['cckdest']['cckdest:destination_term_id'] = t("Main Destination Term id");
    if(module_exists('transliteration'))
    {
      $tokens['cckdest']['cckdest:destination_term_path-translit'] = t("Main Destination Term path - translitaration");
    }
    
  }
  return $tokens;
}

function cckdestinations_token_values($type, $object = NULL, $options = array()) {
  $tokens=array();
  if ($type == 'node') {
    // tokens par défaut :
    $tokens['cckdest:destination_term'] = "";
    $tokens['cckdest:destination_term_path'] = "";
    $tokens['cckdest:destination_term_id'] = 0;
    $tokens['cckdest:destination_term_path-translit'] = "";
    if(is_null($object))
      return $tokens;
    // récupération de la destination principale
    $term = null;
    if(isset($object->field_destinations) && is_array($object->field_destinations) && isset($object->field_destinations[0]['tid']) && is_numeric($object->field_destinations[0]['tid'])){
      $term_id = $object->field_destinations[0]['tid'];
      //$term->vid = variable_get('wallymport_destinationpath', 0);
      if(!intval($term_id))
        return $tokens;
      $term = taxonomy_get_term($term_id);
      if(!$term)
        return $tokens;
      $path = wallytoolbox_taxonomy_get_path_by_tid_or_term($term->tid);
      // Remplissage des tokens.
      $tokens['cckdest:destination_term'] = strtolower($term->name);
      $tokens['cckdest:destination_term_path'] = explode('/',$path); // quand la clé contient "path" il faut retourner un array
      $tokens['cckdest:destination_term_id'] = strtolower($term->tid);
      if(module_exists('transliteration'))
        $tokens['cckdest:destination_term_path-translit'] = explode('/',transliteration_get(strtolower($path))); // quand la clé contient "path" il faut retourner un array
    }

  }
  return $tokens;
}

function cckdestinations_token_help($types = 'all', $prefix = '[', $suffix = ']') {
  token_include();
  $full_list = token_get_list($types);

  $headers = array(t('Token'), t('Replacement value'));
  $rows = array();
  foreach ($full_list as $key => $category) {
    if($key!='global'){
      $rows[] = array(array('data' => drupal_ucfirst($key) .' '. t('tokens'), 'class' => 'region', 'colspan' => 2));
      foreach ($category as $token => $description) {
        $row = array();
        $row[] = $prefix . $token . $suffix;
        $row[] = $description;
        $rows[] = $row;
      }
    }
  }

  $output = theme('table', $headers, $rows, array('class' => 'description'));
  return $output;
}

/**
 * Value for a cckdestinations autocomplete field
 *
 * returns the taxonomy tree for term ids
 */
function cckdestinations_autocomplete_value($element, $edit = FALSE) {
  $field_key = $element['#name'];
  $terms = array();

  if (count($element['#default_value']) && !empty($element['#default_value'])) {
    if ($element['#multiple']) {
      foreach ($element['#default_value'] as $delta => $entry) {
        $extracted_tid = cckdestinations_autocomplete_tags_get_tids($entry, $element['#vid'], $element['#multiple']);
        if (!empty($extracted_tid) && isset($extracted_tid['existing_tids'])) {
          $entry = $extracted_tid['existing_tids'];
        }
        $terms[] = taxonomy_get_term($entry);
      }
    } else {
      $entry = $element['#default_value'];
      $extracted_tid = cckdestinations_autocomplete_tags_get_tids($entry, $element['#vid'], $element['#multiple']);
      if (!empty($extracted_tid) && isset($extracted_tid['existing_tids'])) {
        $entry = $extracted_tid['existing_tids'];
      }
      $terms[] = taxonomy_get_term($entry);
    }
  }
  $value = cckdestinations_autocomplete_merge_tags($terms, $element['#vid'], $element['#multiple']);
  
  if (!empty($value)) {
    return array($field_key => $value);
  } else {
    return NULL;
  }
}

function cckdestinations_select_process($element, $edit, $form_state, $form) {
  if (isset($element['#theme'])) {
    if (!$element['#vid'] && isset($element['#options'][0]->option) && is_array($element['#options'][0]->option)) {
      $options_keys = array_keys($element['#options'][0]->option);
      if (is_numeric($options_keys[0])) {
        $tmp_term = taxonomy_get_term($options_keys[0]);
        $element['#vid'] = $tmp_term->vid;
      }
    }

    if ($element['#vid'] && sizeof($element['#options']) > wally_variable_get('cckdestinations_taxonomy_limit', 10)) {
      $element['#type'] = 'cckdestinations_autocomplete';
      $element['#value_callback'] = 'cckdestinations_autocomplete_value';
      $element['#processed'] = FALSE;
      $element['#process'] = array('cckdestinations_autocomplete_process');
      unset($element['#theme']);
      unset($element['#options']);
      unset($element['#value']);
      $form_id = str_replace('-', '_', $form['#id']);
      _form_builder_handle_input_element($form_id, $element, $form_state, $form);
    }
  }

  return $element;
}

/**
 * Process an individual element.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 */
function cckdestinations_autocomplete_process($element, $edit, $form_state, $form) {
  $field_key  = $element['#name'];
  $multiple = $element['#multiple'] ? 'multiple' : 'unique';

  $element[$field_key] = array(
    '#type' => 'textfield',
    '#default_value' => isset($element['#value'][$field_key]) ? $element['#value'][$field_key] : '',
    '#autocomplete_path' => 'cckdestinations/autocomplete/'. $element['#vid'].'/'.$multiple,
    '#title' => $element['#title'],
    '#required' => $element['#required'],
    '#description' => $element['#description'],
    '#field_name' => $element['#field_name'],
    '#type_name' => $element['#type_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
    '#maxlength' => 255,
    '#vid' => $element['#vid'],
    '#parents' => $element['#parents'],
    '#array_parents' => $element['#array_parents'],
    '#name' => $element['#name'],
    '#multiple' => $element['#multiple'],
    '#attributes' => $element['#attributes'],
  );
  
  if (empty($element[$field_key]['#element_validate'])) {
    $element[$field_key]['#element_validate'] = array();
  }
  array_unshift($element[$field_key]['#element_validate'], 'cckdestinations_autocomplete_validate');
  return $element;
}

/**
 * Validation function for the cckdestinations_autocomplete element
 *
 * parses input, handles new terms and sets the values as needed for storing the data
 */
function cckdestinations_autocomplete_validate($element, &$form_state) {
  $field_key  = $element['#columns'][0];
  $value = $element['#value'];
  $extracted_ids = cckdestinations_autocomplete_tags_get_tids($value, $element['#vid'], $element['#multiple']);
  form_set_value($element, $extracted_ids['existing_tids'], $form_state);
}

/**
 * Retrieve a pipe delimited string of autocomplete suggestions
 * 
 * @param String Fieldname
 * @param Integer TID of a parent (optional)
 * @param BOOLEAN whether a multiple field or not
 * @param STRING typed input
 */
function cckdestinations_autocomplete_load($vid, $multiple, $string = '') {
  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  // This regexp allows the following types of user input:
  // this, "somecmpany, llc", "and ""this"" w,o.rks", foo bar

  // If the menu system has splitted the search text because of slashes, glue it back.
  if (func_num_args() > 3) {
    $args = func_get_args();
    $string .= '/'. implode('/', array_slice($args, 2));
  }
  
  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $array = drupal_explode_tags($string);
  $matches = array();
  
  // Fetch last tag
  $last_string = trim(array_pop($array));

  if ($multiple == 'unique' && empty($array)) {
    $load = TRUE;
  } elseif ($multiple == 'multiple' && $last_string != '') {
    $load = TRUE;
  } else {
    $load = FALSE;
  }

  if ($load) {
    $display_limit = wally_variable_get('cckdestinations_display_limit', 10);

    // Get current list of tids
    $current_tids = cckdestinations_autocomplete_tags_get_tids($string, $vid);
    $current_tids = isset($current_tids['existing_tids']) ? $current_tids['existing_tids'] : array();

    $result = db_query_range(db_rewrite_sql("SELECT t.name, t.tid FROM {term_data} t
      LEFT JOIN {term_synonym} s ON t.tid = s.tid
      WHERE t.vid = %d 
      AND (LOWER(t.name) LIKE LOWER('%%%s%%') OR LOWER(s.name) LIKE LOWER('%%%s%%'))", 't', 'tid'),
    $vid, $last_string, $last_string, 0, $display_limit + count($current_tids));
    $prefix = count($array) ? '"'. implode('", "', $array) .'", ' : '';

    while (($tag = db_fetch_object($result)) && (count($matches) < $display_limit)) {
      if (!in_array($tag->tid, $current_tids)) { // Do not propose a term already given
        $tag_help = $tag->name;
        $tag_hierarchy = wallytoolbox_taxonomy_get_path_by_tid_or_term($tag->tid);
        $tag_help .= ' ('.$tag_hierarchy.')';
        
        $n = $tag->name;
        $n .= ($multiple == 'unique') ? ' ('.$tag_hierarchy.')' : '';
        $n .= ' ['.$tag->tid.']';
        // Commas and quotes in terms are special cases, so encode 'em.
        if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {
          $n = '"'. str_replace('"', '""', $tag->name) .'"';
        }
        
        // In the matches array, the key will be displayed after clicking
        // and the value will be displayed is the select list
        $matches[$prefix . $n] = check_plain($tag_help);
      }
    }
  }

  drupal_json($matches);
}

/**
 * Get TIDs for freetagging tags
 *  Free tagging vocabularies do not send their tids in the form,
 *  so we'll detect them here and process them independently.
 * @param $typed_input A string containing all comma separated tags. As the user typed it.
 */
function cckdestinations_autocomplete_tags_get_tids($typed_input, $vid, $multiple = TRUE) {
  // This regexp allows the following types of user input:
  // this, "somecmpany, llc", "and ""this"" w,o.rks", foo bar
  $typed_terms = cckdestinations_autocomplete_split_tags($typed_input);
  
  $result = array();
  foreach ($typed_terms as $typed_term) {
    if ($typed_term == "") { continue; }
    
    // See if the term exists in the chosen vocabulary
    // and return the tid.
    $term_ok = FALSE;
    if ($term = taxonomy_get_term($typed_term)) {
      if ($term->vid == $vid) {
        if ($multiple) {
          $result['existing_tids'][$term->tid] = $term->tid;
        } else {
          $result['existing_tids'] = $term->tid;
        }
        $term_ok = TRUE;
      }
    }
    
    if (!$term_ok) {
      $result['non_existing_terms'][] = array(
        'tid' => $typed_term,
        'vid' => $vid,
      );
    }
  }

  return $result;
}

/**
 * Helper function to split the tags
 */
function cckdestinations_autocomplete_split_tags($typed_input) {
  $regexp = '/\[(?P<digit>\d+)\]/';
  preg_match_all($regexp, $typed_input, $matches);
  return $matches[1];
}

/**
 * Helper function to merge the tags, to prefill the fields when editing a node.
 */
function cckdestinations_autocomplete_merge_tags($terms, $vid, $multiple = TRUE) {
  $typed_terms = array();
  if (!empty($terms)) {
    foreach ($terms as $term) {
      // Extract terms belonging to the vocabulary in question.
      if ($term->vid == $vid) {
        //if ($tid && in_array($term->tid,drupal_map_assoc(array_keys((taxonomy_get_children($tid,$vid)))))) {
          // Commas and quotes in terms are special cases, so encode 'em.
          $name = $term->name;
          if (!$multiple) {
            $tag_hierarchy = wallytoolbox_taxonomy_get_path_by_tid_or_term($term->tid);
            $name .= ' ('.$tag_hierarchy.')';
          }
          if (preg_match('/,/', $term->name) || preg_match('/"/', $term->name)) {
            $name = '"'. preg_replace('/"/', '""', $name) .'"';
          }
          $typed_terms[] = $multiple ? '"'.$name.' ['.$term->tid.']"' : $name.' ['.$term->tid.']';
       // }
      }
    }
  }
  
  return implode(', ', $typed_terms);
}

/**
 * Construct default values for the autocomplete field
 */
function cckdestinations_autocomplete_default_values($element) {
  
}

function theme_cckdestinations_autocomplete($element) {
  return $element['#children'];
}

/**
 * Menu callback for AHAH removal of a widget.
 */
function cckdestinations_remove_ahah($type_name_url, $rem_delta) {
  $field_name = 'field_destinations';
  module_load_include('module', 'content');
  module_load_include('inc', 'content', 'includes/content.node_form');
  
  $type = content_types($type_name_url);
  $field = content_fields($field_name, $type['type']);

  if (empty($_POST['form_build_id'])) {
    // Invalid request.
    print drupal_to_js(array('status' => FALSE, 'data' => ''));
    exit;
  }
  
  // Retrieve the cached form.
  $form_state = array('submitted' => FALSE);
  $form_build_id = $_POST['form_build_id'];
  $form = form_get_cache($form_build_id, $form_state);
  if (!$form) {
    // Invalid form_build_id.
    print drupal_to_js(array('status' => FALSE, 'data' => ''));
    exit;
  }
  
  // We don't simply return a new empty widget to append to existing ones, because
  // - ahah.js won't simply let us add a new row to a table
  // - attaching the 'draggable' behavior won't be easy
  // So we resort to rebuilding the whole table of widgets including the existing ones,
  // which makes us jump through a few hoops.

  // The form that we get from the cache is unbuilt. We need to build it so that
  // _value callbacks can be executed and $form_state['values'] populated.
  // We only want to affect $form_state['values'], not the $form itself
  // (built forms aren't supposed to enter the cache) nor the rest of $form_data,
  // so we use copies of $form and $form_data.
  $form_copy = $form;
  $form_state_copy = $form_state;

  $form_copy['#post'] = array();
  module_load_include('inc', 'wallyedit', 'wallyedit.forms');
  form_builder($_POST['form_id'], $form_copy, $form_state_copy);
  // Just grab the data we need.
 
  $form_state['values'] = $form_state_copy['values'];
  
  // Reset cached ids, so that they don't affect the actual form we output.
  form_clean_id(NULL, TRUE);

  $q = $_GET['q'];
  $path = array_slice(explode('/', $q), 4);
  $path = isset($form[$type_name_url]) ? array_merge(array($type_name_url), $path) : $path;
  
  $form_element = $form;
  foreach($path as $path_item){
    $form_element = $form_element[$path_item];
  }
  $parents = isset($form_element['#parents']) ? $form_element['#parents'] : array($field_name);
  $form_state_ref = $form_state['values'];
  if (!isset($form_state_ref[$parents[0]]['field_destinations']) && $parents[0] != 'field_destinations') {
    $parents[0] = 'group_destinations';
  }
  
  $_POST_ref = $_POST;
  foreach($parents as $path_item) {
    $form_state_array[] = $form_state_ref[$path_item];
    $form_state_ref = &$form_state_ref[$path_item];
    $_POST_ref = &$_POST_ref[$path_item];
  }

  /**********************/
  // Sort the $form_state['values'] we just built *and* the incoming $_POST data
  // according to d-n-d reordering.
  
  unset($form_state_ref[$field['field_name'].'_add_more']);
  foreach ($_POST_ref as $delta => $item) {
    $form_state_ref[$delta]['_weight'] = $item['_weight'];
  }
  
  $node_t = (object)$form_state_array[count($form_state_array) - 2];
  $form_t = array();
  $form_t['#node'] = $node_t;
  
  unset($form_state_ref[$rem_delta]);
  unset($_POST_ref[$rem_delta]);

  // Build our new form element for the whole field, asking for one more element.
  $form_state_ref['item_count'] = array($field_name => count($_POST_ref));
  
  $temp = array();
  $temp['values'][$field_name] = $form_state_ref;
  $form_element = content_field_form($form_t, $temp, $field);
  
  unset($form_state_ref['item_count']);
  $new_keys = array_keys($form_state_ref);
  $form_element_copy = $form_element[$field_name];
  unset($form_element_copy[$field_name.'_add_more']);
  $actual_keys = element_children($form_element_copy);
  $min_actual_keys = min($actual_keys);
  $max_actual_keys = max($actual_keys);
  $temp_elem = array();
  for ($i = $min_actual_keys; $i <= $max_actual_keys; $i++) {
    $temp_elem[$i] = $form_element[$field_name][$i];
    unset($form_element[$field_name][$i]);
  }
  for ($i = $min_actual_keys; $i <= $max_actual_keys; $i++) {
    if (isset($new_keys[$i])) {
      $form_element[$field_name][$new_keys[$i]] = $temp_elem[$i];
    }
  }

  // Let other modules alter it.
  $a = array();
  $data = &$form_element;
  $data['__drupal_alter_by_ref'] = array(&$a);
  drupal_alter('form', $data, 'cckdestinations_remove_ahah');

  // Add the new element at the right place in the (original, unbuilt) form.
  $form_element[$field_name]['#parents'] = $parents;
  $redirect_path = $path;
  if (strstr($form['form_id']['#value'], 'wallyedit')) {
    unset($redirect_path[0]);
  }
  $form_element[$field_name][$field_name.'_add_more']['#submit'][0] = 'cckdestinations_add_more_submit_proxy';
  $form_element[$field_name][$field_name.'_add_more']['#ahah']['path'] = 'cckdestinations/js_add_more/'.$type_name_url.'/'.$field_name.'/'.implode('/', $redirect_path);
  
  module_load_include('inc', 'wallytoolbox', 'includes/wallytoolbox.helpers');
  wallytoolbox_add_elem_at_target($form, $form_element[$field_name], $path);

  /**********************/
  // Save the new definition of the form.
  $form_state['values'] = array();
  form_set_cache($form_build_id, $form, $form_state);
  
  $form_state = array('submitted' => FALSE);
  $form += array(
    '#post' => $_POST,
    '#programmed' => FALSE,
  );
  $form = form_builder($_POST['form_id'], $form, $form_state);
  
  // Render the new output.
  $field_form = $form;
  foreach($path as $path_item){
    $field_form = $field_form[$path_item];
  }

  $field_form['#parents'] = $parents;
  $field_form[$field_form['#field_name'].'_add_more']['#submit'][0] = 'cckdestinations_add_more_submit_proxy';
  $field_form[$field_form['#field_name'].'_add_more']['#ahah']['path'] = 'cckdestinations/js_add_more/'.$type_name_url.'/'.$field_name.'/'.implode('/', $parents);
  
  // Prevent duplicate wrapper.
  unset($field_form['#prefix'], $field_form['#suffix']);

  // If a newly inserted widget contains AHAH behaviors, they normally won't
  // work because AHAH doesn't know about those - it just attaches to the exact
  // form elements that were initially specified in the Drupal.settings object.
  // The new ones didn't exist then, so we need to update Drupal.settings
  // by ourselves in order to let AHAH know about those new form elements.
  $javascript = drupal_add_js(NULL, NULL);
  $output_js = isset($javascript['setting']) ? '<script type="text/javascript">jQuery.extend(Drupal.settings, '. drupal_to_js(call_user_func_array('array_merge_recursive', $javascript['setting'])) .');</script>' : '';

  $output = theme('status_messages') . drupal_render($field_form) . $output_js;

  // Using drupal_json() breaks filefield's file upload, because the jQuery
  // Form plugin handles file uploads in a way that is not compatible with
  // 'text/javascript' response type.
  $GLOBALS['devel_shutdown'] =  FALSE;
  print drupal_to_js(array('status' => TRUE, 'data' => $output));
  exit;
}

/**
 * Get all mappings virtual dest/real destinations from DB
 */
function cckdestinations_get_multiple_dests() {
  static $multi_dests = array();
  static $processed = FALSE;
  if (!$processed) {
    $db_multi_dests = db_query("SELECT * FROM {cckdestinations_multiple_destinations}");
    while($multi_dest = db_fetch_array($db_multi_dests)) {
      while (is_string($multi_dest['reals'])) {
        $multi_dest['reals'] = unserialize($multi_dest['reals']);
      }
      $multi_dests[$multi_dest['virtual']] = $multi_dest;
    }
    $processed = TRUE;
  }
  return $multi_dests;
}

/**
 * Find the common target for a list of destinations
 */
function cckdestinations_multiple_dests_get_target_intersect($dests) {
  $hierarchies = wallyctools_get_hierarchies();
  $redacblocks = array();
  foreach ($dests as $tid => $dest) {
    $redacblocks[] = $hierarchies[$tid]['redacblocks'];
  }
  if (sizeof($redacblocks) > 1) {
    $intersect = call_user_func_array('array_intersect_assoc', $redacblocks);
  } else {
    $intersect = $redacblocks[0];
  }
  return $intersect;
}

/**
 * Check wether a given destination is virtual and return the real destinations if it is
 */
function cckdestinations_is_virtual($dest_name) {
  $multi_dests = cckdestinations_get_multiple_dests();
  if (array_key_exists($dest_name, $multi_dests)) {
    return $multi_dests[$dest_name]['reals'];
  }
  return FALSE;
}

function cckdestinations_force_dnc(&$node) {
  if (isset($node->field_destinations) && !empty($node->field_destinations)) {
    foreach ($node->field_destinations as $delta => $dest) {
      $node->field_destinations[$delta]['rank'] = 'DNC'.$dest['rank'];
    }
  }
}

/**
 * Calculate the new time rank of a node.
 * 
 * @param object $node
 *   The node.
 * @param array &$items
 *   The cckdestinations fields.
 */
function _cckdestinations_set_new_time_ranks($node, &$items) {
  $rank_limit = wally_variable_get('cckdestinations_rank_limit', 10);

  $pub_date = isset($node->field_publicationdate[0]['value']) ? strtotime($node->field_publicationdate[0]['value']) : time();
  
  foreach ($items as $delta => $item) {
    if (!cckdestinations_content_is_empty($item, array()) && ($item['target'] != 'none')) {
      if (strstr($item['rank'], 'DNC') && isset($item['time_rank']) && !empty($item['time_rank'])) {
        $items[$delta]['rank'] = substr($item['rank'], 3);
      } else {
        $defaults = array(
          'sort_method' => 'absolute',
          'behavior' => 'top',
          'reserved' => 5,
          'delta_t' => 1,
        );
        $dest_settings = wally_variable_get('cckdestinations_destination_'.$item['tid'].'_'.$item['target'], $defaults);
        $sort_method = $dest_settings['sort_method'];
        
        if (strstr($item['rank'], 'DNC')) {
          $item['rank'] = substr($item['rank'], 3);
        }

        if ($sort_method == 'interval') {
          $items[$delta]['time_rank'] = $pub_date + ($item['rank'] * 60 * 60 * $dest_settings['delta_t']);
        } else {
          // Set params for this destination
          $behavior = $dest_settings['behavior'];
          $reserved = $dest_settings['reserved'];
          $temp_time_rank = 0;
          $rank = $item['rank'];

          // Get destination view results without the current node
          $view_infos = wallyctools_get_view_info_from_redacblock($item['target']);
          $view = views_get_view($view_infos['view_name']);
          $conf = array(
            'override_pager_settings' => TRUE,
            'nodes_per_page' => $reserved + 2,
            'offset' => 0,
            'use_pager' => FALSE,
            'pager_id' => 0,
            'more_link' => FALSE,
            'url' => FALSE,
          );
          $temp_results = array();
          if (wallyctools_prepare_view_for_redacblock($view, $view_infos['view_id'], $item['target'], array($item['tid']), $conf)) {
            $view->execute();
            $temp_results = $view->result;
            $view->destroy();
          }

          $current_results = array();

          foreach ($temp_results as $result) {
            if ($result->nid != $node->nid) {
              $current_results[] = $result;
            }
          }

          if ($rank == 0) {
            if ($behavior == 'bottom') {
              $rank = $reserved + 1;
            } else {
              $rank = 1;
            }
          } elseif ($rank > $reserved) {
            $rank = $reserved + 1;
          }

          $items[$delta]['time_rank'] = $current_results[$rank - 1]->node_data_field_destinations_field_destinations_time_rank + 30;
          if (sizeof($current_results) >= $reserved) {
            $current_results[$rank - 1]->node_data_field_destinations_field_destinations_time_rank = $items[$delta]['time_rank'];
  
            for ($i = ($rank - 1); $i > 0; $i--) {
              if ($current_results[$i - 1]->node_data_field_destinations_field_destinations_time_rank < ($current_results[$i]->node_data_field_destinations_field_destinations_time_rank + 20)) {
                $elem_nid = $current_results[$i - 1]->nid;
                $elem_node = node_load($elem_nid);
                $new_time_rank[$elem_nid] = $current_results[$i]->node_data_field_destinations_field_destinations_time_rank + 30;
                $current_results[$i - 1]->node_data_field_destinations_field_destinations_time_rank = $new_time_rank[$elem_nid];
  
                foreach ($elem_node->field_destinations as $elem_delta => $dest) {
                  $dest['rank'] = 'DNC'.$dest['rank'];
                  if ($dest['tid'] == $item['tid'] && $dest['target'] == $item['target']) {
                    $dest['time_rank'] = $new_time_rank[$elem_nid];
                  }
                  $elem_node->field_destinations[$elem_delta] = $dest;
                }
                
                node_save($elem_node);
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Reorder the elements of the destination field
 */
function _cckdestinations_reorder_values($field, &$items) {
  if (isset($items) && !empty($items)) {
    $items = _content_sort_items($field, $items);
  }
}

/**
 * Remove the destination associated to a term from all nodes when a term is removed
 * 
 * @param array $term
 *   The deleted term.
 */
function _cckdestinations_remove_destination_from_nodes($tid) {
  $db_nids = db_query('SELECT nid FROM content_field_destinations WHERE field_destinations_tid = %d', $tid);
  while ($array_nid = db_fetch_array($db_nids)) {
    $nid = $array_nid['nid'];
    $node = node_load($nid);
    
    foreach ($node->field_destinations as $dest_id => $cur_dest) {
      if ($cur_dest['tid'] == $tid)
        unset($node->field_destinations[$dest_id]);
    }
    
    cckdestinations_force_dnc($node);
    node_save($node);
  }
}

/**
 * Create (or update) a destination term as a clone of a taxonomy term.
 * 
 * @param array &$values
 *   The form values given by the form of a taxonomy term.
 * @param array $term
 *   The original term that will be cloned.
 */
function _cckdestinations_create_or_update_topic_destination(&$values, $term) {
  $bad_car = array('_', ' ', '\'');
  $dest_vid = variable_get('wallymport_destinationpath', 0);

  $new_term = $term;
  $new_term['vid'] = $dest_vid;
  $new_term['featid'] = $new_term['vid'] .'_'. str_replace($bad_car, '-', strtolower($new_term['name']));
  $new_term['topic_destination'] = $term['tid'];
  $new_term['parent'] = array($values['elected_parent']);

  unset($new_term['tid']);
  $cur_dests = taxonomy_get_tree($dest_vid);
  foreach ($cur_dests as $dest) {
    if ($dest->featid == $new_term['featid']) {
      $new_term['tid'] = $dest->tid;
      break;
    }
  }
  $new_term['tid'] = isset($new_term['tid']) ? $new_term['tid'] : null;

  switch (taxonomy_save_term($new_term)) {
    case SAVED_NEW:
      drupal_set_message(t('Created new term %term.', array('%term' => $values['name'])));
      watchdog('taxonomy', 'Created new term %term.', array('%term' => $values['name']), WATCHDOG_NOTICE, l(t('edit'), 'admin/content/taxonomy/edit/term/'. $values['tid']));
      break;
    case SAVED_UPDATED:
      drupal_set_message(t('Updated term %term.', array('%term' => $values['name'])));
      watchdog('taxonomy', 'Updated term %term.', array('%term' => $values['name']), WATCHDOG_NOTICE, l(t('edit'), 'admin/content/taxonomy/edit/term/'. $values['tid']));
      break;
  }

  if ($new_term['tid']) {
    $values['topic_destination'] = $new_term['tid'];
    return $new_term;
  } else {
    return FALSE;
  }
}

/**
 * Delete the cloned taxonomy term from the destinations.
 * 
 * @param array &$values
 *   The form values given by the form of a taxonomy term.
 * @param array $term
 *   The original term.
 */
function _cckdestinations_remove_topic_destination(&$values, $vocabulary, $term) {
  if ($term['topic_destination']) {
    if (taxonomy_del_term($term['topic_destination'])) {
      path_set_alias('taxonomy/term/'.$term['tid'], 'taxonomy/term/'.$term['topic_destination'], 0, '');
      _cckdestinations_remove_destination_from_nodes($term['topic_destination']);
      taxonomy_check_vocabulary_hierarchy((array)$vocabulary, (array)$term);
      drupal_set_message(t('Deleted term %name.', array('%name' => $term['name'])));
      watchdog('taxonomy', 'Deleted term %name.', array('%name' => $term['name']), WATCHDOG_NOTICE);
      return TRUE;
    } else {
      return FALSE;
    }
  }
}

/**
 * Apply retroaction to old nodes when a taxonomy term is elected as destination.
 * 
 * @param array $new_term
 *   The new destination term, created as a clone of a taxonomy term.
 * @param array $recup_tids
 *   List of topics (array of tid) to which the retroaction must be applied.
 */
function _cckdestinations_apply_topic_destination_to_nodes($new_term, $recup_tids) {
  $nids = array();
  $new_dest = array(
    'target' => 'default_destination_block',
    'layout' => 'medium',
    'rank' => '0',
  );
  
  $content_types = content_types();
  foreach ($content_types as $content_type) {
    if (isset($content_type['fields']['field_destinations']))
      $nids = array_merge($nids, wallytoolbox_taxonomy_get_nodes($recup_tids, 'or', 0, FALSE, $content_type['type']));
  }
  
  foreach ($nids as $nid) {
    $dest_exists = FALSE;
    $node = node_load($nid);
    cckdestinations_force_dnc($node);
    
    foreach ($node->field_destinations as $cur_dest) {
      if ($cur_dest['tid'] == $new_term['tid'])
        $dest_exists = TRUE;
    }
    
    if (!$dest_exists) {
      $new_dest['tid'] = $new_term['tid'];
      $node->field_destinations[] = $new_dest;
      node_save($node);
    }
  }
}

/**
 * When a node has a destination which is an elected taxonomy term, we add the original taxonomy term as a tag to this node.
 * 
 * @param object &$node
 *   The node.
 */
function _cckdestinations_add_topic_for_destination(&$node) {
  if (!$node->no_taxonomy_update) {
    switch ($node->type){
      case 'wally_articlepackage':
        $objectnode = node_load($node->field_mainstory[0]['nid']);
        break;
      case 'wally_gallerypackage':
        $objectnode = node_load($node->field_mainobject[0]['nid']);
        break;
      case 'wally_pollpackage':
        $objectnode = node_load($node->field_mainpoll[0]['nid']);
        break;
    }

    $current_tags = array();
    foreach ($objectnode->taxonomy as $tax)
      $current_tags[] = $tax->tid;
    
    $destinations = $node->field_destinations;
    foreach ($destinations as $dest) {
      $dest_term = taxonomy_get_term($dest['tid']);
      if (isset($dest_term->topic_destination) && $dest_term->topic_destination != 0 && !in_array($dest_term->topic_destination, $current_tags)) {
        $assoc_term = taxonomy_get_term($dest_term->topic_destination);
        $assoc_voc = taxonomy_vocabulary_load($assoc_term->vid);
        $field = strstr($assoc_voc->name, 'Keywords') ? 'field_tags' : 'field_'.strtolower(str_replace(' ', '_', $assoc_voc->name));
        $objectnode->{$field}[]['value'] = $assoc_term->tid;
        cckdestinations_force_dnc($node);
        node_save($objectnode);
      }
    }
  }
}
