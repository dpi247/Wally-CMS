<?php
/**
 * @defgroup wallytoolbox Wally ToolBox functions
 * @{
 * In this module we define functions that could be used in any of 
 * the wally modules. These function aren't linked to a specific context
 * and could be use anywhere. 
 */

// module_load_include('inc', 'wallytoolbox', 'includes/wally_gmap');

/**
 * Implementation of hook_menu().
 */
function wallytoolbox_menu() {
  $items = array();
  
  $items['admin/wally/wallytoolbox/supercron'] = array(
    'title'             => t('Wally Toolbox "Supercon" Settings'),
    'page callback'     => 'drupal_get_form',
    'page arguments'		=> array('wallytoolbox_supercron_settings'),
    'access arguments'  => array('manage cache'),
    'description'       => t('Allows administrators to set paramaters for this module to function properly.'),
    'file'              => 'includes/wallytoolbox.admin.inc',
  );
  
  $items['admin/wally/wallytoolbox/supercron/output/%'] = array(
    'page callback'    => 'wallytoolbox_supercron_output',
    'page arguments'   => array(5),
    'access arguments' => array('manage cache'),
    'type'             => MENU_CALLBACK,
    'file'             => 'includes/wallytoolbox.admin.inc',
  );
  
  $items['admin/wally/wallytoolbox/supercron/call/%'] = array(
    'page callback'    => 'wallytoolbox_supercron_call',
    'page arguments'   => array(5),
    'access arguments' => array('manage cache'),
    'type'             => MENU_CALLBACK,
    'file'             => 'includes/wallytoolbox.admin.inc',
  );
  
  $items['admin/wally/wallytoolbox/plugins'] = array(
    'title'            => t('Flow plugins'),
    'page callback'    => 'wallytoolbox_page_callback',
    'access arguments' => array('view flow plugins'),
    'type'             => MENU_CALLBACK,
  );
  
  return $items;
}

/**
 *  Implémentation du hook_theme(); 
 */
function wallytoolbox_theme(&$var) {
 return array(
    'wallytoolbox_supercron_settings' => array(
      'arguments' => array('form' => NULL),
    ),
  );
}

/**
 * Implementation of hook_form_FORM_ID_alter()
 * 
 * Add submit callback to refresh the wallytoolbox_content_types_cache table after saving a page contents.
 */
function wallytoolbox_form_panels_panel_context_edit_content_alter(&$form, $form_state) {
  wallytoolbox_refresh_cache_list();
}

/**
 * Implementation of hook_form_alter()
 */
function wallytoolbox_form_alter(&$form, $form_state, $form_id) {
  if (strstr($form_id, '_content_type_')) {
    $form_to_alter = FALSE;
    if (strstr($form_id, '_content_type_edit_form')) {
      // The form id respects the standard structure, easy to recognize
      $form_to_alter = TRUE;
    } else {
      // The form id has another structure, we have to search through all available plugins
      $plugins = panels_common_get_allowed_types('panels_page');
      $edit_forms = array();
      foreach ($plugins as $plugin) {
        foreach ($plugin as $subtype) {
          if (isset($subtype['edit form'])) {
            if (is_array($subtype['edit form'])) {
              // This is in case of multistep forms
              $keys = array_keys($subtype['edit form']);
              $edit_forms[] = $keys[0];
            } else {
              $edit_forms[] = $subtype['edit form'];
            }
          }
        }
      }

      if (in_array($form_id, $edit_forms))
        $form_to_alter = TRUE;
    }
    
    if ($form_to_alter) {
      // We add a rule field to every CTools content type configuration form.
      $form['wally_rule'] = array (
        '#type'             => 'textfield',
        '#title'            => t('Refresh time (minutes)'),
        '#description'      => t('This is the frequency with which the hook_refresh_block will be called for this content.'),
        '#default_value'    => isset($form_state['conf']['wally_rule']) ? $form_state['conf']['wally_rule'] : 15,
      );
      
      $form['#validate'][] = 'wallytoolbox_content_type_form_validate';
      $form['#submit'][] = 'wallytoolbox_content_type_form_submit';
    }
  }
}

function wallytoolbox_page_callback(){
  ctools_include('plugins');
  
  $module = 'wallytoolbox';
  $type = 'flow';
  
  $owner = $module;
  $api = $type;
  
  //DONNE LES INFOS DES PLUGINS FOURNIS PAR LES MODULES
  dsm(ctools_get_plugins($module, $type));
  dsm(ctools_get_plugins($module, $type, 'json'), 'specific_plugin_info');
  
  //DONNE LES INFO SUR LA DEFINITION DU TYPE DU PLUGIN -INFOS SUR FLOW ...-
  dsm(ctools_plugin_get_info($module, $type));
  
  //QUELS MODULES IMPLEMENTE CE PLUGIN AVEC QUELLE VERSION ?
  dsm(ctools_plugin_api_info($owner, $api, 0, 99), API_INFO);

  return ctools_plugin_get_function();
}

/**
 * NOT REQUIRED BUT USED TO SER THE DEFAULT VALUE FOR EACH PLUGIN
 * Set default value for the information about each plugin of  the flow type
 * $owner_ctools_plugin_$type()
 */
function wallytoolbox_ctools_plugin_flow(){
  return array(
    'cache' => FALSE,
    'process' => 'wallytoolbox_flow_process',
  );
}

/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement task and task_handler plugins.
 */
function wallytoolbox_ctools_plugin_directory($module, $plugin) {
  if ($module == 'wallytoolbox' && !empty($plugin))
    return "plugins/".$plugin;
}

/**
 * Implementation of hook_ctools_plugin_api().
 */
function wallytoolbox_ctools_plugin_api() {
  return array(
    'version' => 2,
  );
}

/**
 * APPELLEE LORS DE ctools_plugin_load_includes()
 * pcq renseignée en tant que process dans wallytoolbox_ctools_plugin_flow()
 * qui elle même pour tous les plugins appelle ctools_plugin_process()
 */
function wallytoolbox_flow_process(&$plugin, $info){
  $function_base = $plugin['module'] . '_' . $plugin['name'] . '_flow_';
  
  if (!isset($plugin['settings form']) && function_exists($function_base . 'settings_form'))
    $plugin['settings form'] = $function_base . 'settings_form';
  
  if (!isset($plugin['settings form submit']) && function_exists($function_base . 'settings_form_submit'))
    $plugin['settings form submit'] = $function_base . 'settings_form_submit';

  if (!isset($plugin['settings form validate']) && function_exists($function_base . 'settings_form_validate'))
    $plugin['settings form validate'] = $function_base . 'settings_form_validate';

  if (!isset($plugin['build']) && function_exists($function_base . 'build'))
    $plugin['build'] = $function_base . 'build';
}

/**
 * Return all the types that can be handeld by one or more flow plugins
 * 
 * @return
 *   An array of types 
 */
function wallytoolbox_get_available_flow_type() {
  ctools_include('plugins');
  
  $available_types = array();
  $plugins = ctools_get_plugins('wallytoolbox', 'flow');

  foreach($plugins as $plugin){
    foreach($plugin['types'] as $type){
      $available_types[$type] = $type;
    }
  }
  
  return $available_types;
}

function wallytoolbox_get_plugins_that_handle_type($type) {
  ctools_include('plugins');
  
  $plugins=ctools_get_plugins('wallytoolbox', 'flow');
  foreach($plugins as $plugin_name=>$plugin){
    if (in_array($type,$plugin['types'])) {
      $available_types[$plugin_name] = $plugin;
    }
  }
  
  return $available_types;
}

function wallytoolbox_get_plugin_by_name($plugin_name) {
  ctools_include('plugins');
  $module = 'wallytoolbox';
  $type = 'flow';
  
  $plugin = ctools_get_plugins($module, $type, $plugin_name);
  return $plugin;
}

/**
 * Determine if a flow has a setting form.
 *
 * Some content types simply have their content and no options. This function
 * lets a UI determine if it should display an edit link or not.
 */
function wallytoolbox_has_settings_form_of_plugin($plugin) {
  ctools_include('plugins');
  if (empty($plugin['settings form']) ) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Determine if a flow has a setting form and if true, return the $form object.
 *
 * Some content types simply have their content and no options. This function
 * lets a UI determine if it should display an edit link or not.
 */
function wallytoolbox_get_settings_form_of_plugin($plugin, &$form, &$form_state) {
  ctools_include('plugins');
  if (empty($plugin['settings form']) ) {
    return FALSE;
  }
  
  if (!empty($plugin['settings form validate'])) {
    $form['#validate'][] = $plugin['settings form validate'];
  }

  if ($function = ctools_plugin_get_function($plugin, 'settings form')) {
     return $function($form, $form_state);
  }

  return FALSE;
}

/**
 * Validation for the refresh rule added to CTools content types.
 */
function wallytoolbox_content_type_form_validate(&$form, &$form_state) {
  $values = $form_state['values'];

  if (isset($values['wally_rule']) && !is_numeric($values['wally_rule'])) {
    form_set_error('wally_rule', t('The refresh time isn\'t a numeric value'));
  } elseif (isset($values['wally_rule']) && ($values['wally_rule'] < 0 || $values['wally_rule'] >= 60)) {
    form_set_error('wally_rule', t('The refresh time must be greater or equal to 0 and smaller than 60 minutes'));
  }
}

/**
 * Submit for the refresh rule added to CTools content types.
 */
function wallytoolbox_content_type_form_submit(&$form, &$form_state) {
  $conf = $form_state['conf'];
  $conf_keys = array_keys($conf);
  if (is_object($conf[$conf_keys[0]])) {
    $form_state['conf'][$conf_keys[0]]->wally_rule = $form_state['values']['wally_rule'];
  } else {
    $form_state['conf']['wally_rule'] = $form_state['values']['wally_rule'];
  }
}

/**
 * Error handler
 */
function wallytoolbox_handle_errors($errno, $errstr, $errfile, $errline, $args) {
  if($errno == 1){
    watchdog('php', 'Fatal error: @errstr in @errfile at line @errline', array('@errstr' => $errstr, '@errfile' => $errfile, '@errline' => $errline), WATCHDOG_ERROR);
  }
}

/**
 * Unsets all persistent variables beginning with the given string.
 *
 * @param $name
 *   The name of the variable to undefine.
 *
 * @see variable_get(), variable_set(), variable_del()
 */
function wallytoolbox_variable_del_like($name) {
  global $conf, $db_prefix;

  db_query("DELETE FROM {variable} WHERE name LIKE '%s%'", $name);

  unset($conf[$name]);

  // The write-through rebuild optimization isn't compatible with SimpleTest.
  // Because array-based prefixes don't work with SimpleTest, we can assume
  // that a non-string prefix indicates lack of SimpleTest operations.
  if (is_string($db_prefix) && strpos($db_prefix, 'simpletest') === 0) {
    cache_clear_all('variables', 'cache');
  }
  
  variable_cache_rebuild();
}

/**
 * A true boolean conversion function.
 * 
 * @param $v
 *   The value to be converted
 * @param $del
 *   default value return if conversion fail.
 *
 * @return
 *   boolean "true" or "false"
 */
function wallytoolbox_toboolean($v, $def=NULL) {
  if ($v===FALSE) return FALSE;
  if ($v===TRUE) return TRUE;
  if ($v=="true") return TRUE;
  if ($v=="false") return FALSE;
  if ($v==0) return FALSE;
  if ($v==1) return TRUE;
  return $def;
}

function wallytoolbox_set_microtime_step() {
  static $begin_time = 0;
  static $first = TRUE;

  if ($first) {
    $begin_time = microtime(TRUE);
    $first = FALSE;
  } else {
    $end_time = microtime(TRUE);
    $t = $end_time - $begin_time;
    $micro = sprintf('%06d', ($t - floor($t)) * 1000000);
    $d = new DateTime(date('Y-m-d H:i:s.'.$micro, $t));

    dsm($d->format('H:i:s.u'));
  }
}

/**
 * Search for taxonomy terms for a specific "path". 
 *
 * @param $path
 *   The taxonomy term path to match ( /term1/term2/term3 ). 
 * @param $voc
 *   The taxonomy vocabulary used for filtering on a single vocabulary.
 *   If not set, will seach into all vocabularies.
 *
 * @return
 *   an array of taxonomy term object
 */
function wallytoolbox_taxonomy_get_term_by_path($path, $voc=null) {
	$t = explode("/", trim($path,"/"));
	$t = $t[count($t)-1];

	if ($voc) {
		$db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s') AND t.vid = %s", trim($t), $voc);
	} else {
		$db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s')", trim($t));
	}

	$result = array();

	// Reverse building of path for founded terms.
	while ($term = db_fetch_object($db_result)) {
		$ppath = "";
		$parents = taxonomy_get_parents_all($term->tid);
		foreach ($parents as $parent){ 
		  $ppath = strtolower($parent->name)."/".$ppath;
		}
		if (trim($ppath,"/") == strtolower(trim($path,"/"))){ 
		  $result[] = $term;
		}
	}
	return ($result ? $result : null);
}

/**
 * Return the parents hierarchy of a taxonomic term according to the vocabulary structure.
 * Example: if given the tid of the term "Belgium", returns "News/World/Belgium".
 * 
 * @param string $term
 *   A taxonomy term ID or name. If it is a name, the chosen term will
 * be the one matching the $vid, if given, or the first in the results
 * list.
 * @param string $vid
 *   The vocabulary ID.
 * 
 * @return
 *   A string containing the parents hierarchy, separated by "/".
 */
function wallytoolbox_taxonomy_get_path_by_tid_or_term($term, $vid = '', $add_voc = FALSE) {
  $return = '';
  
  if (!is_numeric($term)) {
    $terms_list = taxonomy_get_term_by_name($term);
    if ($vid != '') {
      foreach ($terms_list as $term_elem) {
        if ($term_elem->vid == $vid) {
          $tid = $term_elem->tid;
          break;
        }
      }
    } else {
      $tid = $terms_list[0]->tid;
    }
  } else {
    $tid = $term;
  }
  
  $tax_list = taxonomy_get_parents_all($tid);
  foreach (array_reverse($tax_list) as $tax_elem) {
    $return .= $tax_elem->name.'/';
  }
  if ($add_voc) {
    $voc = taxonomy_vocabulary_load($tax_list[0]->vid);
    $return = $voc->name.'/'.$return;
  }
  
  return substr($return, 0, strlen($return)-1);
}

/**
 * Get vocabulary vid from vocabulary name 
 *
 * @param $name
 *   That's the taxonomy vocabulary name.
 *   
 * @return
 *   Taxonomy VID 
 */
function wallytoolbox_taxonomy_getvocabularyvidbyname($name){
  $result = db_query("SELECT v.vid 
  					  FROM {vocabulary} v 
  					  WHERE v.name = '%s'",$name);
  $vid = NULL;
  while ($vocabulary = db_fetch_object($result)){
    $vid = $vocabulary->vid;
  }
  return $vid;
}

/**
 * Create vocabulary from vocabulary name 
 *
 * @param $name
 *   That's the taxonomy vocabulary name.
 *   
 * @return
 *   Taxonomy VID of the created vocabulary. 
 */

function wallytoolbox_taxonomy_createvocabularybyname($name){
  $edit = array();
  $vid = NULL;
  if(wallytoolbox_taxonomy_getvocabularyvidbyname($name) == NULL){
    $edit['name'] = $name;
    $edit['description'] = '';
    $edit['help'] = '';
    $edit['relations'] = 1;
    $edit['hierarchy'] = 0;
    $edit['multiple'] = 0;
    $edit['required'] = 0;
    $edit['tags'] = 0;
    $edit['module'] = 'taxonomy';
    $edit['weight'] = 0; 
    $status = taxonomy_save_vocabulary($edit);
    $vid = $edit['vid'];
  }
  return $vid;
}

/**
 * Unbind all terms of a vocabulary to the node 
 *
 * @param $name
 *   That's the taxonomy vocabulary name.
 * @param $nid
 *   nid of the node
 */
function wallytoolbox_taxonomy_unbindalltermofnodefromavocabulary($name,&$node,$vid = NULL){
   
  $terms_of_voc = taxonomy_node_get_terms_by_vocabulary($node, $vid);
  foreach($terms_of_voc as $term_key => $term_value){
    db_query("DELETE FROM {term_node} WHERE nid = %d AND tid = %d", $node->nid,$term_key);
    unset($node->taxonomy[$term_key]);
  }
   
  if ($vid == variable_get('wallymport_freetagtaxonomy', NULL)){
    $node->field_free_tags = array();
  } elseif ($vid == variable_get('wallymport_concept', NULL)){
    $node->field_concepts = array();
  } elseif ($vid == variable_get('wallymport_iptc', NULL)){
    $node->field_iptc = array();
  }
}

/**
 * Add a taxonomy term into a vocabulary without 
 * need to store a node.
 *
 * @param $name
 *   That's the taxonomy term name. 
 * @param $vid
 *   The Taxonomy Vocabulary to store the term. 
 * @param $description
 *   Description of the term to be stored.
 * @param $weight
 *   Weight of the term into vocabulary (default 0).
 * @param $parent
 *   Parent term if needed (default null).
 * 
 * @return
 *   Taxonomy TID of the created term. 
 */
function wallytoolbox_add_taxonomy_term($name, $vid, $description = '', $weight = 0, $parent = null){
  $form_values = array();
  $form_values['name'] = $name;
  $form_values['description'] = $description;
  $form_values['vid'] = $vid;
  $form_values['weight'] = $weight;
  if ($parent){ 
    $form_values['parent'] = $parent;
  }
  @taxonomy_save_term($form_values);
  return $form_values['tid'];
}


/**
 * Get all nodes associated with a array of taxonomy term.  
 *  
 * @param $tid
 *   An array of term IDs to match. 
 * @param $operator
 *   Could be 'or' or 'and' (default 'or') 
 * @param $depth
 *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative integer or "all". 
 * @param $pager 
 *   Whether the nodes are to be used with a pager (the case on most Drupal pages) or not (in an XML feed, for example).
 * @param $type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * @param $order
 *   Order close for TID (SSL format). See @link http://api.drupal.org/api/drupal/includes--database.inc/group/database/6 Data Base abstraction layer @endlink for table aliases.
 * 
 * @return
 *   Array of Node ID. 
 */
function wallytoolbox_taxonomy_get_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $type = null, $order = 'n.sticky DESC, n.created DESC'){

  $r = array();

  if (count($tids) > 0) {
    
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    
    foreach ($tids as $index => $tid) {
      $term = taxonomy_get_term($tid);
      if (isset($term->vid)) {
        $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
        $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
      }
    }
    
    if ($operator == 'or') {
      $args = !empty($descendant_tids) ? call_user_func_array('array_merge', $descendant_tids) : '';
      $placeholders = db_placeholders($args, 'int');
      $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
    } else {
      $joins = '';
      $wheres = '';
      $args = array();
      foreach ($descendant_tids as $index => $tids) {
        $joins .= ' INNER JOIN {term_node} tn' . $index . ' ON n.vid = tn' . $index . '.vid';
        $wheres .= ' AND tn' . $index . '.tid IN (' . db_placeholders($tids, 'int') . ')';
        $args = array_merge($args, $tids);
      }
      $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.created  FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
    }

    if ($type) {
      $sql = $sql . ' AND n.type = "'.$type.'"';
      $sql_count = $sql_count . ' AND n.type = "'.$type.'"';
    }

    // add Order Clause
    $sql = $sql . ' ORDER BY ' . $order; 

    $sql = db_rewrite_sql($sql);
    $sql_count = db_rewrite_sql($sql_count);

    if ($pager) {
      $results = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);
    } else {
      $results = db_query($sql, $args);
    }

    while ($result = db_fetch_object($results)) {
      $r[] = $result->nid;
    }

  }
  return $r;
}

/**
 * Find all term objects related to a given term ID.
 */
function wallytoolbox_taxonomy_get_related($tid, $key = 'tid', $bidirect = FALSE) {
  if ($bidirect) {
    return taxonomy_get_related($tid, $key);
  } else {
    if ($tid) {
      $result = db_query('SELECT t.*, tid1, tid2 FROM {term_relation}, {term_data} t WHERE t.tid = tid2 AND tid1 = %d AND t.tid != %d ORDER BY weight, name', $tid, $tid);
      $related = array();
      while ($term = db_fetch_object($result)) {
        $related[$term->$key] = $term;
      }
      return $related;
    }
    else {
      return array();
    }
  }
}

/**
 * Get all nodes where cckfield match a value. 
 *
 * @param $param
 *   An associative array containing:
 *   - key: An existing cck_field name with the prfix "field_" 
 *   - value: The value to match specified cck_field
 * @param $node_type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * 
 * @return
 *   An array of nodes
 */
function wallytoolbox_get_node_by_cckfield($param,$node_type=null){

	$nodes = array();
	foreach ($param as $key => $value) {
		$sql="
			SELECT node.nid AS nid
			 FROM {node} node 
			 LEFT JOIN {content_".$key."} node_data_".$key." ON node.vid = node_data_".$key.".vid
			 WHERE (node_data_".$key.".".$key."_value = '%s')
			";

		// Fetch all node from CCK field table.
		if ($result = db_query($sql, $value)) {
			while ($item = db_fetch_object($result)) {
				if ($node = node_load($item->nid)) {
					if ($node_type) {
						if ($node->type == $node_type) {
							$nodes[$node->nid] = $node;
						}
					} else {
						$nodes[$node->nid] = $node;
					}
				} 
			}
		}
	}
	
	$result = array(); 
	foreach($nodes as $node) $result[]=$node;

	if (count($result)) { 
		return $result;
	} else {
		return null;
	}
}

/**
 * Get all nodes where taxonomy tid and node type match value. 
 *
 * @param $tid
 *   tid of the taxonomy term
 * @param $node_type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * 
 * @return
 *   An array of nodes
 */
function wallytoolbox_get_node_by_tid($tid,$type){
   $result = db_query("SELECT n.nid
  					  FROM {node} n
  					  LEFT OUTER JOIN {term_node} t ON t.nid = n.nid
  					  WHERE n.type = '%s'
  					  AND t.tid = %d",$type,$tid);
  $nodes = NULL;
  while ($obj = db_fetch_object($result)){
    $nodes[] = node_load(array('nid' => $obj->nid));
  }
  return $nodes;
}

/**
 * Get nid from packages who reference the current node.
 *
 * @param $node
 *   Node currently processed(TextObject, AudioObject, DigitalObject,PhotoObject, Videoobject, PollObject)
 *
 * @return
 *   Array() of array() of nid
 */
function wallytoolbox_get_node_by_reference($node) {
  $rows = array();
  if ($node->type == 'wally_linktype'){
   $res = db_query("SELECT DISTINCT (
		tr.nid
		) 
		FROM {content_field_links_list} tr
		WHERE {tr.field_links_list_nid} =%d
		UNION
		SELECT DISTINCT (
		tok.nid
		) AS temp_nid
		FROM {content_type_wally_articlepackage} tok
		LEFT JOIN {content_field_linkedobjects tup} ON tok.nid = tup.nid
		LEFT JOIN {content_field_links_list tik} ON tik.nid = tup.field_linkedobjects_nid
		WHERE tik.field_links_list_nid =%d
		    ", $node->nid,$node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  } else {
    if ($node->type == 'wally_textobject' || $node->type == 'wally_audioobject' || $node->type == 'wally_digitalobject' || $node->type == 'wally_photoobject' || $node->type == 'wally_videoobject'){
      if ($res = db_query("SELECT DISTINCT(nid) FROM {content_field_embededobjects} WHERE field_embededobjects_nid = %d", $node->nid)){
        while ($row = db_fetch_array($res)) {
          if (!in_array($row, $rows)) $rows[] = $row;
        }
      }
      if ($node->type == 'wally_textobject'){
        $res = db_query("SELECT DISTINCT(nid) FROM {content_type_wally_articlepackage} WHERE field_mainstory_nid = %d", $node->nid);
        while ($row = db_fetch_array($res)) {
          if (!in_array($row, $rows)) $rows[] = $row;
        }
      } else {
        if ($res2 = db_query("SELECT DISTINCT(nid) FROM {content_type_wally_gallerypackage} WHERE field_mainobject_nid = %d", $node->nid)) {
          while ($row = db_fetch_array($res2)) {
            if (!in_array($row, $rows)) $rows[] = $row;
          }
        }
      }
    } elseif ($node->type == 'wally_pollobject' || $node->type == 'poll'){
      $res = db_query("SELECT DISTINCT(nid) FROM {content_type_wally_pollpackage} WHERE field_mainpoll_nid = %d", $node->nid);
      while ($row = db_fetch_array($res)) {
        if (!in_array($row, $rows)) $rows[] = $row;
      }
    }
  }
  return $rows;
}

/**
 * Transform a DOMDocument, DOMNode, DOMElement, wathever, in an array.
 */
function dom2array($node) {
  $res = array();
  if($node->nodeType == XML_TEXT_NODE){
      $res = $node->nodeValue;
  }
  else{
      if($node->hasAttributes()){
          $attributes = $node->attributes;
          if(!is_null($attributes)){
              $res['@attributes'] = array();
              foreach ($attributes as $index=>$attr) {
                  $res['@attributes'][$attr->name] = $attr->value;
              }
          }
      }
      if($node->hasChildNodes()){
          $children = $node->childNodes;
          for($i=0;$i<$children->length;$i++){
              $child = $children->item($i);
              $res[$child->nodeName][] = dom2array($child);
          }
      }
  }
  return $res;
}

/**
 * Recursively remove a dir.
 */
function rrmdir($dir) { 
  if ($dir && isset($dir) && is_dir($dir)) { 
    $objects = scandir($dir); 
    foreach ($objects as $object) { 
      if ($object != "." && $object != "..") { 
        if (filetype($dir."/".$object) == "dir") rrmdir($dir."/".$object); else unlink($dir."/".$object); 
      } 
    } 
    reset($objects); 
    rmdir($dir); 
  } 
}

/**
 * Transform a stdClass object to another class
 */
function dirty_cast($obj, $to_class, $require = FALSE) {
  if ($require) {
    require_once $require;
  }
  
  if(class_exists($to_class)) {
    $obj_in = serialize($obj);
    $obj_out = 'O:' . strlen($to_class) . ':"' . $to_class . '":' . substr($obj_in, $obj_in[2] + 7);
    return unserialize($obj_out);
  }
  else {
    return false;
  }
}

/**
 * Recursively compare two arrays.
 * For two arrays ($a and $b), arrayRecursiveDiff($a, $b) is not equal to arrayRecursiveDiff($b, $a)
 */
function arrayRecursiveDiff($aArray1, $aArray2) {
  $aReturn = array();

  foreach ($aArray1 as $mKey => $mValue) {
    if (array_key_exists($mKey, $aArray2)) {
      if (is_array($mValue)) {
        $aRecursiveDiff = arrayRecursiveDiff($mValue, $aArray2[$mKey]);
        if (count($aRecursiveDiff)) { $aReturn[$mKey] = $aRecursiveDiff; }
      } elseif (is_object($mValue) && is_object($aArray2[$mKey])) {
        $aRecursiveDiff = arrayRecursiveDiff((array)$mValue, (array)$aArray2[$mKey]);
        if (count($aRecursiveDiff)) { $aReturn[$mKey] = $aRecursiveDiff; }
      } else {
        if ($mValue != $aArray2[$mKey]) {
          $aReturn[$mKey] = $mValue;
        }
      }
    } else {
      $aReturn[$mKey] = $mValue;
    }
  }
  return $aReturn;
}

/**
 * Return all available destinations in an array following the
 * structure :
 * 
 * array[destination_path_tid][position][layout][rank] = TRUE;
 */
function wallytoolbox_destinations_items_array(){
  $all_dests = cckdestinations_get_classes_and_options();
  $rank_limit = variable_get('cckdestinations_rank_limit', '10');
  for ($i=0; $i<=$rank_limit; $i++) {
    $ranks_list[] = $i;
  }
  $array_dests = array();

  foreach ($all_dests['tid']['#options'] as $tid=>$term_infos) {
    $array_dests[$tid] = array();
    foreach ($all_dests['target']['#options'] as $target_name=>$target_infos) {
      if (substr($target_name, 0, strlen($tid)) == $tid && !is_numeric(substr($target_name, strlen($tid), 1))) {
        $target = substr($target_name, strlen($tid));
        $array_dests[$tid][$target] = array();
        foreach ($all_dests['layout']['#options'] as $layout_name=>$layout_infos) {
          if (substr($layout_name, 0, strlen($target_name)) == $target_name) {
            $layout = $layout_infos[substr($layout_name, strlen($target_name))];
            $array_dests[$tid][$target][$layout] = array();
            foreach ($ranks_list as $rank_elem) {
              $array_dests[$tid][$target][$layout][$rank_elem] = TRUE;
            }
          }
        }
      }
    }
  }
  
  return $array_dests; 
}
		
/**
 * Adds a META TAG to the process template queue.
 * 
 * @param $attributes
 *   Array of meta key keyword & key value. 
 *   If key keyword is one of "http-equiv, name, property"
 *   the Meta is updated in case of 2 calls.
 * @param $content
 *   Content of the meta tag.
 *   
 * @return
 * 	Return an array of meta.
 */
function wallytoolbox_add_meta($attributes = array(), $content = NULL) {

	static $wally_meta = array();
	$meta_key = NULL; 

	// Supported "Meta Keys" are : http-equiv, name, property. 
	foreach ($attributes as $attribute_name => $attribute_value) {
		switch (strtolower($attribute_name)) {
			case "name":
			case "http-equiv":
			case "property":
				$meta_key = strtolower($attribute_name)."_".$attribute_value;
				$wally_meta[$meta_key] = array( $attribute_name => $attribute_value, "content" => $content); 
				break;
			default:
				$wally_meta[] = array( $attribute_name => $attribute_value, "content" => $content); 
				break; 
		}
	}
	return $wally_meta;
}

/**
 * Generate HTML tag for meta tags.
 */
function wallytoolbox_get_meta() {

  if (!isset($wally_meta)) {
    $wally_meta = wallytoolbox_add_meta(array(), NULL);
  }

  if (empty($wally_meta)) {
    return '';
  }

  $output = '';
  
  foreach ($wally_meta as $meta_k => $meta) {
    if (!$meta) {
      continue;
    }
    $output .= "<meta ";
		foreach($meta as $data_k => $data_v) {
			$output .= " ".$data_k."=\"".$data_v."\"";
		}
    $output .= " />\n";
  }
  
  return $output;
}

/**
 * Hook preprocess for meta tags.
 */
function wallytoolbox_preprocess_page(&$variables) {
  $variables['meta'] = wallytoolbox_get_meta();	
}

/**
 * Implementation of hook_menu_link_alter()
 */
function wallytoolbox_menu_link_alter(&$item, $menu){
  if($item['module']=='taxonomy_menu' && !isset($item['updated'])){
    $item['hidden']=1;
  }
}

/**
 * Flush the page cache for the given internal url.
 */
function wallytoolbox_flush_all_pages($internal_urls = '*', $flush_aliases = FALSE, $flush_type = 'drupal') {
  global $base_url;
  $varnish_pages_to_flush = array();
  
  if (is_string($internal_urls))
    $internal_urls = array($internal_urls);
  
  foreach ($internal_urls as $internal_url) {
    $url_to_flush = array();
    $url_to_flush[] = $internal_url;
    
    if ($internal_url != '*' && $flush_aliases) {
      $aliases = wallytoolbox_get_all_aliases($internal_url);
      foreach ($aliases as $alias)
        $url_to_flush[] = $alias;
    }
  
    foreach($url_to_flush as $url) {
      if ($flush_type == 'drupal' || $flush_type == 'both') {
        if ($url == '*') {
          cache_clear_all($url, 'cache_page');
        } else {
          cache_clear_all($base_url.'/'.$url, 'cache_page');
        }
      }
      if ($flush_type == 'varnish' || $flush_type == 'both') {
        if ($url == '*' && module_exists('warnish')) {
          warnish_purge_all_pages();
        } else {
          $varnish_pages_to_flush[] = $url;
        }
      }
    }
    
    if (strstr($internal_url, 'home')) {
      if ($flush_type == 'drupal' || $flush_type == 'both') {
        cache_clear_all($base_url.'/'.variable_get('site_frontpage', 'home'), 'cache_page', TRUE);
        cache_clear_all($base_url.'/', 'cache_page');
      }
      if ($flush_type == 'varnish' || $flush_type == 'both') {
        $varnish_pages_to_flush[] = variable_get('site_frontpage', 'home');
        $varnish_pages_to_flush[] = '/';
      }
    }
  }
  
  if (!empty($varnish_pages_to_flush) && module_exists('warnish'))
    warnish_purge_page($varnish_pages_to_flush);
}

/**
 * Return an array of all existing aliases for an internal url.
 */
function wallytoolbox_get_all_aliases($internal_url) {
  $db_aliases = db_query('SELECT dst FROM {url_alias} WHERE src = "%s" ORDER BY pid DESC', $internal_url);
  $return_aliases = array();

  while ($db_alias = db_fetch_array($db_aliases)) {
    $return_aliases[] = $db_alias['dst'];
  }

  if(count($return_aliases) == 0){
    $return_aliases[] = $internal_url;
  }

  return $return_aliases;
}

/**
 * Get the latest created alias for an internal URL
 * @param $internal_url {String} Internal URL, it can't begin with "/" or "http://".
 * @return {String} The alias if found, $internal_url if not.
 */
function wallytoolbox_get_main_alias($internal_url){
  if(is_null($internal_url) || trim($internal_url) == "")
    return $internal_url;
  $db_aliases = @db_query('SELECT dst FROM {url_alias} WHERE src = "%s" ORDER BY pid DESC LIMIT 0,1', $internal_url);
  if(!$db_aliases)
    return $internal_url;
  $db_alias = db_fetch_array($db_aliases);
  if(!$db_alias)
    return $internal_url;
  return $db_alias['dst'];
}

/**
 * Delete the Drupal file and remove the physical file of a photo.
 * 
 * @param array $photofile
 *   A Drupal file array.
 */
function wallytoolbox_delete_photofile($photofile) {
  if (isset($photofile['filepath'])) {
    $filepath = $photofile['filepath'];
    file_delete($filepath);
    db_query('DELETE FROM files WHERE filepath = "%s"', $filepath);
  }
}

/**
 * Implementation of hook_cron().
 */ 
function wallytoolbox_cron(){
  $return = '<b>'.t('Run').' '.date('Y-m-d H:i:s').' :</b></br>';
  
  // Check if the table is not empty, and build it if necessary
  $count = db_fetch_array(db_query('SELECT COUNT(*) FROM {wallytoolbox_content_types_cache}'));
  if ($count['COUNT(*)'] == '0') {
    wallytoolbox_refresh_cache_list();
  }
  
  // Select blocks where last run is too old according to their refresh time
  $blocks_list = db_query('SELECT * FROM {wallytoolbox_content_types_cache} WHERE enabled = 1 AND rule <> 0 AND last_run < %d - rule ORDER BY weight ASC, cid ASC', time());
  while ($block = db_fetch_array($blocks_list)) {
    while (is_string($block['settings'])) {
      $block['settings'] = unserialize($block['settings']);
    }
    $block_infos = explode(':', $block['cid']);
    $block_infos = array(
      'page' => $block_infos[0],
      'type' => $block_infos[1],
      'subtype' => $block_infos[2],
      'panel' => $block_infos[3],
      'pid' => $block_infos[4],
    );
    // Invoke hook_refresh_block
    $output = module_invoke_all('refresh_block', $block_infos, $block['settings']);
    if (!empty($output)) {
      $block['output'] .= serialize($output);
      db_query('UPDATE {wallytoolbox_content_types_cache} SET output = "%s" WHERE cid = "%s"', $block['output'], $block['cid']);
    }
    $block['last_run'] = time();
    db_query('UPDATE {wallytoolbox_content_types_cache} SET last_run = %d WHERE cid = "%s"', $block['last_run'], $block['cid']);
    $return .= $block['cid'].'</br>';
  }
  
  print $return;
}

/**
 * Get all blocks and put them in the wallytoolbox_content_types_cache table.
 */
function wallytoolbox_refresh_cache_list() {
  // Get all blocks, from DB or features
  list($panels, $handlers) = wallytoolbox_get_panels_and_handlers();
  
  // Get previous settings from DB to save the cron config
  $blocks_list_db = db_query('SELECT * FROM {wallytoolbox_content_types_cache}');
  $blocks_list = array();
  while ($temp_block = db_fetch_array($blocks_list_db))
    $blocks_list[$temp_block['cid']] = $temp_block;
  
  // Restart from an empty table
  db_query('TRUNCATE TABLE wallytoolbox_content_types_cache');
  
  // Transform the list to get the same structure as the table and add an entry to the table
  foreach ($handlers as $page_name => $page_handlers) {
    if (is_array($page_handlers) && !empty($page_handlers)) {
      foreach ($page_handlers as $handler) {
        $block = array();
        $config = $handler->configuration;
        $block['cid'] = $page_name.':'.$handler->type.':'.$handler->subtype.':'.$handler->panel.':'.$handler->pid;
        
        $check_existing = db_result(db_query('SELECT cid FROM {wallytoolbox_content_types_cache} WHERE cid = "%s"', $block['cid']));
        if (!$check_existing) {
          if (isset($blocks_list[$block['cid']])) {
            $block['output'] = $blocks_list[$block['cid']]['output'];
            $block['last_run'] = $blocks_list[$block['cid']]['last_run'];
            $block['enabled'] = $blocks_list[$block['cid']]['enabled'];
            $block['weight'] = $blocks_list[$block['cid']]['weight'];
            $block['rule'] = $blocks_list[$block['cid']]['rule'];
          } else {
            $conf_keys = array_keys($config);
            if (is_object($config[$conf_keys[0]])) {
              $wally_rule = isset($config[$conf_keys[0]]->wally_rule) ? $config[$conf_keys[0]]->wally_rule : 0;
            } else {
              $wally_rule = isset($config['wally_rule']) ? $config['wally_rule'] : 0;
            }
            $block['rule'] = 60*$wally_rule;
          }

          $block['settings'] = $config;

          drupal_write_record('wallytoolbox_content_types_cache', $block);
        }
      }
    }
  }
}

/**
 * Get a list of all blocks set in all pages
 */
function wallytoolbox_get_panels_and_handlers() {
  $pages = page_manager_get_tasks_by_type('page');
  $handlers = array();
  $panels = array();
  foreach ($pages as $page_name => $page) {
    $cached_page = page_manager_get_page_cache($page_name);
    $handlers[$page_name] = isset($cached_page->handlers->conf['display']) ? $cached_page->handlers->conf['display'] : array();
    foreach ($cached_page->handlers as $handler_name => $handler) {
      $cached_panels = panels_edit_cache_get('panel_context:' . $page_name . ':' . $handler->name);
      $panels[$handler_name][] = $cached_panels;
      foreach ($cached_panels->display->content as $display_content)
        $handlers[$page_name][] = $display_content;
    }
  }
  
  return array($panels, $handlers);
}

function wallytoolbox_flow_to_array_init_array($feed_infos = array()) {
  $array_packages = array();
  $array_packages['Packages']['Package'] = array();
  $array_packages['Packages']['__log'] = array();
  $array_packages['Packages']['__log']['success'] = TRUE;
  $array_packages['Packages']['__log']['msg'] = '';
  $array_packages['Packages']['__settings'] = $feed_infos;
  return $array_packages;
}

/**
 * Initialise an array following the schema of a Wallymport articlepackage.
 * Only required fields are initialised.
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_flow_to_array_new_package() {
  $array_item = array();
  $array_item['PackageID'] = '';
  $array_item['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $array_item['EmbargoDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $array_item['Language'] = '';
  $array_item['PackageTitle']['value'] = '';
  $array_item['ExternalReference']['value'] = '';
  $array_item['ProductID']['value'] = '';
  $array_item['Destinations'] = array();
  $array_item['Destinations']['Destination'] = array();
  $array_item['Destinations']['Destination']['DestinationRank'] = '';
  $array_item['Destinations']['Destination']['Position'] = '';
  $array_item['Destinations']['Destination']['DocumentLayout'] = '';
  $array_item['Destinations']['Destination']['DestinationPath']['value'] = '';
  $array_item['Editions'] = array();
  $array_item['Editions']['Edition']['EditionID'] = 'all';
  $array_item['Editions']['Edition']['value'] = 'true';
  $array_item['Channels'] = array();
  $array_item['Channels']['Channel']['Name'] = '';
  $array_item['Summary']['value'] = '';
  $array_item['ExternalURI']['value'] = 'http://';
  $array_item['__log'] = array();
  $array_item['__log']['success'] = TRUE;
  $array_item['__log']['msg'] = '';
  return $array_item;
}

/**
 * Initialise an array following the schema of a Wallymport textobject.
 * Only required fields are initialised (+ the taxonomy field).
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_flow_to_array_new_textobject() {
  $textobject = array();
  $textobject['type'] = 'TextObjectType';
  $textobject['ObjectID'] = '';
  $textobject['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $textobject['Title']['value'] = '';
  $textobject['ExternalReference']['value'] =  '';
  $textobject['Taxonomy'] = array();
  $textobject['Taxonomy']['Vocabulary'] = array();
  $textobject['Taxonomy']['Vocabulary']['VocabularyName'] = 'Default';
  $textobject['Taxonomy']['Vocabulary']['VocabularyType'] = 'free';
  $textobject['Taxonomy']['Vocabulary']['Term'] = array();
  $textobject['TextBody']['value'] = '';
  return $textobject;
}

/**
 * Initialise an array following the schema of a Wallymport photoobject.
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_flow_to_array_new_photoobject() {
  $photoobject = array();
  $photoobject['type'] = 'PhotoObjectType';
  $photoobject['ObjectID'] = '';
  $photoobject['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $photoobject['Title']['value'] = '';
  $photoobject['ExternalReference']['value'] = '';
  $photoobject['FileURI']['value'] = 'http://';
  $photoobject['FileSize']['value'] = '';
  return $photoobject;
}

/**
 * Initialise an array following the schema of a Wallymport videoobject.
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_flow_to_array_new_videoobject() {
  $videoobject = array();
  $videoobject['type'] = 'VideoObjectType';
  $videoobject['ObjectID'] = '';
  $videoobject['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $videoobject['Title']['value'] = '';
  $videoobject['ExternalReference']['value'] = '';
  $videoobject['FileURI']['value'] = 'http://';
  $videoobject['FileSize']['value'] = '';
  return $videoobject;
}

function wallytoolbox_flow_to_array_struct_term($struct_array) {
  $new_struct = array('Vocabulary' => array());
  $vocabularies = taxonomy_get_vocabularies();
  
  if (isset($struct_array['Markers']['Location']) && !empty($struct_array['Markers']['Location'])) {
    $loc_voc = $vocabularies[variable_get('wallymport_location', 0)];
    $temp_tax = array(
      'VocabularyName' => 'Markers',
      'VocabularyDescription' => $loc_voc->description,
      'VocabularyType' => 'categorized',
      'Term' => array(),
    );
    foreach ($struct_array['Markers']['Location'] as $marker) {
      $temp_term = array();
      $temp_term['type'] = 'LocationType';
      if (is_numeric($marker)) {
        if ($term = taxonomy_get_term($marker)) {
          $temp_term['Name'] = $term->name;
        }
      } else {
        $temp_term['Name'] = $marker['LocationName']['value'];
        $temp_term['Address'] = $marker['Address'];
        $temp_term['LocationGeo'] = $marker['LocationGeo'];
      }
      $temp_tax['Term'][] = $temp_term;
    }
    $new_struct['Vocabulary'][] = $temp_tax;
  }
  
  if (isset($struct_array['Locations']['Location']) && !empty($struct_array['Locations']['Location'])) {
    $temp_tax = array(
      'VocabularyName' => 'Locations',
      'VocabularyDescription' => $loc_voc->description,
      'VocabularyType' => 'categorized',
      'Term' => array(),
    );
    foreach ($struct_array['Locations']['Location'] as $location) {
      $temp_term = array();
      $temp_term['type'] = 'LocationType';
      if (is_numeric($location)) {
        if ($term = taxonomy_get_term($location)) {
          $temp_term['Name'] = $term->name;
        }
      } else {
        $temp_term['Name'] = $location['LocationName']['value'];
        $temp_term['Address'] = $location['Address'];
        $temp_term['LocationGeo'] = $location['LocationGeo'];
      }
      $temp_tax['Term'][] = $temp_term;
    }
    $new_struct['Vocabulary'][] = $temp_tax;
  }
  
  if (isset($struct_array['Entities']['Entity']) && !empty($struct_array['Entities']['Entity'])) {
    $ent_voc = $vocabularies[variable_get('wallymport_entity', 0)];
    $temp_tax = array(
      'VocabularyName' => 'Entities',
      'VocabularyDescription' => $ent_voc->description,
      'VocabularyType' => 'categorized',
      'Term' => array(),
    );
    foreach ($struct_array['Entities']['Entity'] as $entity) {
      $temp_term = array();
      $temp_term['type'] = 'EntityType';
      if (is_numeric($entity)) {
        if ($term = taxonomy_get_term($entity)) {
          $temp_term['Name'] = $term->name;
        }
      } else {
        $temp_term['Name'] = $entity['EntityTitle']['value'];
        $temp_term['EntityDescription'] = $entity['EntityDescription'];
        $temp_term['EntityServices'] = $entity['EntityServices'];
      }
      $temp_tax['Term'][] = $temp_term;
    }
    $new_struct['Vocabulary'][] = $temp_tax;
  }
  
  if (isset($struct_array['Persons']['Person']) && !empty($struct_array['Persons']['Person'])) {
    $per_voc = $vocabularies[variable_get('wallymport_person', 0)];
    $temp_tax = array(
      'VocabularyName' => 'Persons',
      'VocabularyDescription' => $per_voc->description,
      'VocabularyType' => 'categorized',
      'Term' => array(),
    );
    foreach ($struct_array['Persons']['Person'] as $person) {
      $temp_term = array();
      $temp_term['type'] = 'PersonType';
      if (is_numeric($person)) {
        if ($term = taxonomy_get_term($person)) {
          $temp_term['Name'] = $term->name;
        }
      } else {
        $temp_term['Name'] = $person['PersonName']['value'];
        $temp_term['PersonLastName'] = $person['PersonLastName'];
        $temp_term['PersonFirstName'] = $person['PersonFirstName'];
        $temp_term['PersonNickName'] = $person['PersonNickName'];
        $temp_term['PersonBirthDate'] = $person['PersonBirthDate'];
        $temp_term['PersonSex'] = $person['PersonSex'];
        $temp_term['PersonEmail'] = $person['PersonEmail'];
        $temp_term['PersonWebSite'] = $person['PersonWebSite'];
        $temp_term['PersonPhoneNumber'] = $person['PersonPhoneNumber'];
      }
      $temp_tax['Term'][] = $temp_term;
    }
    $new_struct['Vocabulary'][] = $temp_tax;
  }
  
  if (isset($struct_array['Authors']['Person']) && !empty($struct_array['Authors']['Person'])) {
    $temp_tax = array(
      'VocabularyName' => 'Authors',
      'VocabularyDescription' => $per_voc->description,
      'VocabularyType' => 'categorized',
      'Term' => array(),
    );
    foreach ($struct_array['Authors']['Person'] as $author) {
      $temp_term = array();
      $temp_term['type'] = 'PersonType';
      if (is_numeric($author)) {
        if ($term = taxonomy_get_term($author)) {
          $temp_term['Name'] = $term->name;
        }
      } else {
        $temp_term['Name'] = $author['PersonName']['value'];
        $temp_term['PersonLastName'] = $author['PersonLastName'];
        $temp_term['PersonFirstName'] = $author['PersonFirstName'];
        $temp_term['PersonNickName'] = $author['PersonNickName'];
        $temp_term['PersonBirthDate'] = $author['PersonBirthDate'];
        $temp_term['PersonSex'] = $author['PersonSex'];
        $temp_term['PersonEmail'] = $author['PersonEmail'];
        $temp_term['PersonWebSite'] = $author['PersonWebSite'];
        $temp_term['PersonPhoneNumber'] = $author['PersonPhoneNumber'];
      }
      $temp_tax['Term'][] = $temp_term;
    }
    $new_struct['Vocabulary'][] = $temp_tax;
  }
  
  // Free tags and categorized keywords
  if (isset($struct_array['Taxonomy']['Vocabulary']) && !empty($struct_array['Taxonomy']['Vocabulary'])) {
    $free_voc = variable_get('wallymport_freetagtaxonomy', 0);
    $conc_voc = variable_get('wallymport_concept', 0);
    $iptc_voc = variable_get('wallymport_iptc', 0);
    
    $free_temp_tax = array();
    $free_temp_tax['VocabularyName'] = 'Tags';
    $free_temp_tax['VocabularyDescription'] = $vocabularies[$free_voc]->description;
    $free_temp_tax['VocabularyType'] = 'free';
    $free_temp_tax['Term'] = array();
    
    $conc_temp_tax = array();
    $conc_temp_tax['VocabularyName'] = 'Concepts';
    $conc_temp_tax['VocabularyDescription'] = $vocabularies[$conc_voc]->description;
    $conc_temp_tax['VocabularyType'] = 'free';
    $conc_temp_tax['Term'] = array();
    
    $iptc_temp_tax = array();
    $iptc_temp_tax['VocabularyName'] = 'IPTC';
    $iptc_temp_tax['VocabularyDescription'] = $vocabularies[$iptc_voc]->description;
    $iptc_temp_tax['VocabularyType'] = 'categorized';
    $iptc_temp_tax['Term'] = array();
    
    foreach ($struct_array['Taxonomy']['Vocabulary'] as $vocabulary) {
      switch ($vocabulary['VocabularyType']) {
        case $free_voc :
          $free_temp_tax['Term'][$vocabulary['Term']['value']] = array(
            'Name' => $vocabulary['VocabularyName'],
          );
          break;
        case $conc_voc :
          $conc_temp_tax['Term'][$vocabulary['Term']['value']] = array(
            'Name' => $vocabulary['VocabularyName'],
          );
          break;
        case $iptc_voc :
          $iptc_temp_tax['Term'][$vocabulary['Term']['value']] = array(
            'Name' => wallytoolbox_taxonomy_get_path_by_tid_or_term($vocabulary['Term']['value']),
          );
          break;
      }
    }
    
    if (!empty($free_temp_tax['Term'])) {
      $new_struct['Vocabulary'][] = $free_temp_tax;
    }

    if (!empty($conc_temp_tax['Term'])) {
      $new_struct['Vocabulary'][] = $conc_temp_tax;
    }

    if (!empty($iptc_temp_tax['Term'])) {
      $new_struct['Vocabulary'][] = $iptc_temp_tax;
    }
  }
  
  if (empty($new_struct['Vocabulary'])) {
    unset($new_struct['Vocabulary']);
  }
  
  return $new_struct;
}

function wallytoolbox_node_to_array($node) {
  require_once drupal_get_path('module', 'wallytoolbox').'/plugins/flow/destinations.inc';
  $transformed_node['Packages']['Package'][0] = wallytoolbox_destinations_flow_transform_node($node);
  
  switch ($node->type){
    case 'wally_articlepackage' : $transformed_node['Packages']['Package'][0]['type'] = 'ArticlePackageType';break;
    case 'wally_gallerypackage' : $transformed_node['Packages']['Package'][0]['type'] = 'GalleryPackageType';break;
    case 'wally_pollpackage'    : $transformed_node['Packages']['Package'][0]['type'] = 'PollPackageType';break;
  }
  switch($node->comment){
    case 0 : $transformed_node['Packages']['Package'][0]['CommentsAllowed']['value'] = 'Disabled';break;
    case 1 : $transformed_node['Packages']['Package'][0]['CommentsAllowed']['value'] = 'Read Only';break;
    default :
      $transformed_node['Packages']['Package'][0]['CommentsAllowed']['value'] = 'Read-Write';
  }
  $packagelayout = taxonomy_get_term($node->field_packagelayout[0]['value']);
  $transformed_node['Packages']['Package'][0]['PackageLayout']['value'] = $packagelayout->name;
  
  if (isset($transformed_node['Packages']['Package'][0]['EmbeddedContent']['EmbeddedObjects']['Object'])){
    foreach ($transformed_node['Packages']['Package'][0]['EmbeddedContent']['EmbeddedObjects']['Object'] as $object_key => $object_value){
      switch ($object_value['type']){
        case 'wally_audioobject' : $transformed_node['Packages']['Package'][0]['EmbeddedContent']['EmbeddedObjects']['Object'][$object_key]['type'] = 'AudioObjectType';break;
        case 'wally_photoobject' : $transformed_node['Packages']['Package'][0]['EmbeddedContent']['EmbeddedObjects']['Object'][$object_key]['type'] = 'PhotoObjectType';break;
        case 'wally_pollobject'  : $transformed_node['Packages']['Package'][0]['EmbeddedContent']['EmbeddedObjects']['Object'][$object_key]['type'] = 'PollObjectType';break;
        case 'wally_textobject'  : $transformed_node['Packages']['Package'][0]['EmbeddedContent']['EmbeddedObjects']['Object'][$object_key]['type'] = 'TextObjectType';break;
        case 'wally_videoobject' : $transformed_node['Packages']['Package'][0]['EmbeddedContent']['EmbeddedObjects']['Object'][$object_key]['type'] = 'VideoObjectType';break;
      }
    }
  }
  
  return $transformed_node;
}

/**
 * Search an item for a desired element.
 * 
 * @param $dom_item
 *   The item in which the search is performed.
 * @param $name
 *   The name of the searched element.
 * @param $namespace
 *   Value of the namespace if used.
 * @param $second_choice
 *   If the element given by $name isn\'t found, you have a second chance.
 * @param $feed_name
 *   The name of the feed as recorded in the DB. Needed as default
 *   external reference value.
 * 
 * @return
 *   The element value or ''.
 */
function _wallytoolbox_checkifelementexists($dom_item, $name, $namespace = 'none', $second_choice = '', $feed_name = '', $prefix = '') {
  $return = '';
  $prefix = ($prefix != '') ? $prefix : $feed_name;
  if ($namespace != 'none' && is_object($dom_item)) {
    $return = $dom_item->getElementsByTagNameNS($namespace, $name)->item(0) ? $dom_item->getElementsByTagNameNS($namespace, $name)->item(0)->firstChild->wholeText : '';
    if ($second_choice != '') {
      if ($return == '') {
        $return = $dom_item->getElementsByTagNameNS($namespace, $second_choice)->item(0) ? $dom_item->getElementsByTagNameNS($namespace, $second_choice)->item(0)->firstChild->wholeText : '';
      }
      $return = $prefix.':::'.$return;
    }
  } elseif (is_object($dom_item)) {
    $return = $dom_item->getElementsByTagName($name)->item(0) ? $dom_item->getElementsByTagName($name)->item(0)->firstChild->wholeText : '';
    if ($second_choice != '') {
      if ($return == '') {
        $return = $dom_item->getElementsByTagName($second_choice)->item(0) ? $dom_item->getElementsByTagName($second_choice)->item(0)->firstChild->wholeText : '';
      }
      $return = $prefix.':::'.$return;
    }
  }
  return $return;
}

/**
 * @} End of "defgroup wallytoolbox".
 */
