<?php
/**
 * @defgroup wallytoolbox Wally ToolBox functions
 * @{
 * In this module we define functions that could be used in any of 
 * the wally modules. These function aren't linked to a specific context
 * and could be use anywhere. 
 */

// module_load_include('inc', 'wallytoolbox', 'includes/wally_gmap');

/**
 * Implementation of hook_menu().
 */
function wallytoolbox_menu() {
  $items = array();
  
  $items['admin/wally/wallytoolbox/supercron'] = array(
    'title'             => 'Wally Toolbox "Supercon" Settings',
    'page callback'     => 'drupal_get_form',
    'page arguments'		=> array('wallytoolbox_supercron_settings'),
    'access arguments'  => array('access administration pages'),
    'description'       => 'Allows administrators to set paramaters for this module to function properly.',
    'file'              => 'includes/wallytoolbox.admin.inc',
  );
  
  $items['admin/wally/wallytoolbox/supercron/output/%'] = array(
    'page callback'    => 'wallytoolbox_supercron_output',
    'page arguments'   => array(5),
    'access arguments' => array('access administration pages'),
    'type'             => MENU_CALLBACK,
    'file'             => 'includes/wallytoolbox.admin.inc',
  );
  
  $items['admin/wally/wallytoolbox/supercron/call/%'] = array(
    'page callback'    => 'wallytoolbox_supercron_call',
    'page arguments'   => array(5),
    'access arguments' => array('access administration pages'),
    'type'             => MENU_CALLBACK,
    'file'             => 'includes/wallytoolbox.admin.inc',
  );
  
  return $items;
}

/**
 *  ImplÃ©mentation du hook_theme(); 
 */
function wallytoolbox_theme(&$var) {
 return array(
    'wallytoolbox_supercron_settings' => array(
      'arguments' => array('form' => NULL),
    ),
  );
}

/**
 * Implementation of hook_form_FORM_ID_alter()
 * 
 * Add submit callback to refresh the wallytoolbox_content_types_cache table after saving a page contents.
 */
function wallytoolbox_form_panels_panel_context_edit_content_alter(&$form, $form_state) {
  wallytoolbox_refresh_cache_list();
}

/**
 * Implementation of hook_form_alter()
 */
function wallytoolbox_form_alter(&$form, $form_state, $form_id) {
  if (strstr($form_id, '_content_type_edit_form')) {
    // We add a rule field to every CTools content type configuration form.
    $form['wally_rule'] = array (
      '#type'             => 'textfield',
      '#title'            => t('Refresh time (minutes)'),
      '#description'			=> t('This is the frequency with which the hook_refresh_block will be called for this content.'),
      '#default_value'		=> isset($form_state['conf']['wally_rule']) ? $form_state['conf']['wally_rule'] : 15,
    );
    
    $form['#validate'][] = 'wallytoolbox_content_type_form_validate';
    $form['#submit'][] = 'wallytoolbox_content_type_form_submit';
  }
}

/**
 * Validation for the refresh rule added to CTools content types.
 */
function wallytoolbox_content_type_form_validate(&$form, &$form_state) {
  $values = $form_state['values'];
  
  if (isset($values['wally_rule']) && !is_numeric($values['wally_rule'])) {
    form_set_error('wally_rule', t('The refresh time isn\'t a numeric value'));
  } elseif (isset($values['wally_rule']) && ($values['wally_rule'] < 0 || $values['wally_rule'] >= 60)) {
    form_set_error('wally_rule', t('The refresh time must be greater or equal to 0 and smaller than 60 minutes'));
  }
}

/**
 * Submit for the refresh rule added to CTools content types.
 */
function wallytoolbox_content_type_form_submit(&$form, &$form_state) {
  $form_state['conf']['wally_rule'] = $form_state['values']['wally_rule'];
}

/**
 * Unsets all persistent variables beginning with the given string.
 *
 * @param $name
 *   The name of the variable to undefine.
 *
 * @see variable_get(), variable_set(), variable_del()
 */
function wallytoolbox_variable_del_like($name) {
  global $conf, $db_prefix;

  db_query("DELETE FROM {variable} WHERE name LIKE '%s%'", $name);

  unset($conf[$name]);

  // The write-through rebuild optimization isn't compatible with SimpleTest.
  // Because array-based prefixes don't work with SimpleTest, we can assume
  // that a non-string prefix indicates lack of SimpleTest operations.
  if (is_string($db_prefix) && strpos($db_prefix, 'simpletest') === 0) {
    cache_clear_all('variables', 'cache');
  }
  
  variable_cache_rebuild();
}

/**
 * A true boolean conversion function.
 * 
 * @param $v
 *   The value to be converted
 * @param $del
 *   default value return if conversion fail.
 *
 * @return
 *   boolean "true" or "false"
 */
function wallytoolbox_toboolean($v, $def=NULL) {
  if ($v===FALSE) return FALSE;
  if ($v===TRUE) return TRUE;
  if ($v=="true") return TRUE;
  if ($v=="false") return FALSE;
  if ($v==0) return FALSE;
  if ($v==1) return TRUE;
  return $def;
}

/**
 * Search for taxonomy terms for a specific "path". 
 *
 * @param $path
 *   The taxonomy term path to match ( /term1/term2/term3 ). 
 * @param $voc
 *   The taxonomy vocabulary used for filtering on a single vocabulary.
 *   If not set, will seach into all vocabularies.
 *
 * @return
 *   an array of taxonomy term object
 */
function wallytoolbox_taxonomy_get_term_by_path($path, $voc=null) {
	$t = explode("/", trim($path,"/"));
	$t = $t[count($t)-1];

	if ($voc) {
		$db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s') AND t.vid = %s", trim($t), $voc);
	} else {
		$db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s')", trim($t));
	}

	$result = array();

	// Reverse building of path for founded terms.
	while ($term = db_fetch_object($db_result)) {
		$ppath = "";
		$parents = taxonomy_get_parents_all($term->tid);
		foreach ($parents as $parent) $ppath = strtolower($parent->name)."/".$ppath;
		if (trim($ppath,"/")==strtolower(trim($path,"/"))) $result[] = $term;
	}
	return ($result ? $result : null);
}

/**
 * Return the parents hierarchy of a taxonomic term according to the vocabulary structure.
 * Example: if given the tid of the term "Belgium", returns "News/World/Belgium".
 * 
 * @param string $term
 *   A taxonomy term ID or name. If it is a name, the chosen term will
 * be the one matching the $vid, if given, or the first in the results
 * list.
 * @param string $vid
 *   The vocabulary ID.
 * 
 * @return
 *   A string containing the parents hierarchy, separated by "/".
 */
function wallytoolbox_taxonomy_get_path_by_tid_or_term($term, $vid = '', $add_voc = FALSE) {
  $return = '';
  
  if (!is_numeric($term)) {
    $terms_list = taxonomy_get_term_by_name($term);
    if ($vid != '') {
      foreach ($terms_list as $term_elem) {
        if ($term_elem->vid == $vid) {
          $tid = $term_elem->tid;
          break;
        }
      }
    } else {
      $tid = $terms_list[0]->tid;
    }
  } else {
    $tid = $term;
  }
  
  $tax_list = taxonomy_get_parents_all($tid);
  foreach (array_reverse($tax_list) as $tax_elem) {
    $return .= $tax_elem->name.'/';
  }
  if ($add_voc) {
    $voc = taxonomy_vocabulary_load($tax_list[0]->vid);
    $return = $voc->name.'/'.$return;
  }
  
  return substr($return, 0, strlen($return)-1);
}

/**
 * Add a taxonomy term into a vocabulary without 
 * need to store a node.
 *
 * @param $name
 *   That's the taxonomy term name. 
 * @param $vid
 *   The Taxonomy Vocabulary to store the term. 
 * @param $description
 *   Description of the term to be stored.
 * @param $weight
 *   Weight of the term into vocabulary (default 0).
 * @param $parent
 *   Parent term if needed (default null).
 * 
 * @return
 *   Taxonomy TID of the created term. 
 */
function wallytoolbox_add_taxonomy_term($name, $vid, $description = '', $weight = 0, $parent = null){
  $form_values = array();
  $form_values['name'] = $name;
  $form_values['description'] = $description;
  $form_values['vid'] = $vid;
  $form_values['weight'] = $weight;
  if ($parent) $form_values['parent'] = $parent;
  @taxonomy_save_term($form_values);
  return $form_values['tid'];
}


/**
 * Get all nodes associated with a array of taxonomy term.  
 *  
 * @param $tid
 *   An array of term IDs to match. 
 * @param $operator
 *   Could be 'or' or 'and' (default 'or') 
 * @param $depth
 *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative integer or "all". 
 * @param $pager 
 *   Whether the nodes are to be used with a pager (the case on most Drupal pages) or not (in an XML feed, for example).
 * @param $type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * @param $order
 *   Order close for TID (SSL format). See @link http://api.drupal.org/api/drupal/includes--database.inc/group/database/6 Data Base abstraction layer @endlink for table aliases.
 * 
 * @return
 *   Array of Node ID. 
 */
function wallytoolbox_taxonomy_get_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $type = null, $order = 'n.sticky DESC, n.created DESC'){

  $r = array();

  if (count($tids) > 0) {
    
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    
    foreach ($tids as $index => $tid) {
      $term = taxonomy_get_term($tid);
      if (isset($term->vid)) {
        $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
        $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
      }
    }
    
    if ($operator == 'or') {
      $args = !empty($descendant_tids) ? call_user_func_array('array_merge', $descendant_tids) : '';
      $placeholders = db_placeholders($args, 'int');
      $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
    } else {
      $joins = '';
      $wheres = '';
      $args = array();
      foreach ($descendant_tids as $index => $tids) {
        $joins .= ' INNER JOIN {term_node} tn' . $index . ' ON n.vid = tn' . $index . '.vid';
        $wheres .= ' AND tn' . $index . '.tid IN (' . db_placeholders($tids, 'int') . ')';
        $args = array_merge($args, $tids);
      }
      $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.created  FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
    }

    if ($type) {
      $sql = $sql . ' AND n.type = "'.$type.'"';
      $sql_count = $sql_count . ' AND n.type = "'.$type.'"';
    }

    // add Order Clause
    $sql = $sql . ' ORDER BY ' . $order; 

    $sql = db_rewrite_sql($sql);
    $sql_count = db_rewrite_sql($sql_count);

    if ($pager) {
      $results = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);
    } else {
      $results = db_query($sql, $args);
    }

    while ($result = db_fetch_object($results)) {
      $r[] = $result->nid;
    }

  }
  return $r;
}


/**
 * Get all nodes where cckfield match a value. 
 *
 * @param $param
 *   An associative array containing:
 *   - key: An existing cck_field name with the prfix "field_" 
 *   - value: The value to match specified cck_field
 * @param $node_type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * 
 * @return
 *   An array of nodes
 */
function wallytoolbox_get_node_by_cckfield($param,$node_type=null){

	$nodes = array();
	foreach ($param as $key => $value) {
		$sql="
			SELECT node.nid AS nid
			 FROM {node} node 
			 LEFT JOIN {content_".$key."} node_data_".$key." ON node.vid = node_data_".$key.".vid
			 WHERE (node_data_".$key.".".$key."_value = '%s')
			";

		// Fetch all node from CCK field table.
		if ($result = db_query($sql, $value)) {
			while ($item = db_fetch_object($result)) {
				if ($node = node_load($item->nid)) {
					if ($node_type) {
						if ($node->type == $node_type) {
							$nodes[$node->nid] = $node;
						}
					} else {
						$nodes[$node->nid] = $node;
					}
				} 
			}
		}
	}
	
	$result = array(); 
	foreach($nodes as $node) $result[]=$node;

	if (count($result)) { 
		return $result;
	} else {
		return null;
	}
}

/**
 * Get nid from packages who reference the current node.
 *
 * @param $node
 *   Node currently processed(TextObject, AudioObject, DigitalObject,PhotoObject, Videoobject, PollObject)
 *
 * @return
 *   Array() of array() of nid
 */
function wallytoolbox_get_node_by_reference($node) {
  $rows = array();

  if($node->type=='wally_textobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_articlepackage} WHERE field_mainstory_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  } elseif($node->type=='wally_audioobject' || $node->type=='wally_digitalobject' || $node->type=='wally_photoobject' || $node->type=='wally_videoobject'){
    if ($res=db_query("SELECT nid FROM {content_field_embededobjects} WHERE field_embededobjects_nid = %d", $node->nid)){
      while ($row = db_fetch_array($res)) {
        if (!in_array($row, $rows)) $rows[] = $row;
      }
    } else
    if ($res2=db_query("SELECT nid FROM {content_type_wally_gallerypackage} WHERE field_mainobject_nid = %d", $node->nid)) {
      while ($row = db_fetch_array($res2)) {
        if (!in_array($row, $rows)) $rows[] = $row;
      }
    }
  } elseif($node->type=='wally_pollobject' || $node->type=='poll'){
    $res=db_query("SELECT nid FROM {content_type_wally_pollpackage} WHERE field_mainpoll_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  }
  return $rows;
}

/**
 * Transform a DOMDocument, DOMNode, DOMElement, wathever, in an array.
 */
function dom2array($node) {
  $res = array();
  if($node->nodeType == XML_TEXT_NODE){
      $res = $node->nodeValue;
  }
  else{
      if($node->hasAttributes()){
          $attributes = $node->attributes;
          if(!is_null($attributes)){
              $res['@attributes'] = array();
              foreach ($attributes as $index=>$attr) {
                  $res['@attributes'][$attr->name] = $attr->value;
              }
          }
      }
      if($node->hasChildNodes()){
          $children = $node->childNodes;
          for($i=0;$i<$children->length;$i++){
              $child = $children->item($i);
              $res[$child->nodeName] = dom2array($child);
          }
      }
  }
  return $res;
}

/**
 * Recursively remove a dir.
 */
function rrmdir($dir) { 
  if ($dir && isset($dir) && is_dir($dir)) { 
    $objects = scandir($dir); 
    foreach ($objects as $object) { 
      if ($object != "." && $object != "..") { 
        if (filetype($dir."/".$object) == "dir") rrmdir($dir."/".$object); else unlink($dir."/".$object); 
      } 
    } 
    reset($objects); 
    rmdir($dir); 
  } 
}

/**
 * Return all available destinations in an array following the
 * structure :
 * 
 * array[destination_path_tid][position][layout][rank] = TRUE;
 */
function wallytoolbox_destinations_items_array(){
  $all_dests = cckdestinations_get_classes_and_options();
  $ranks_list = array('1', '2', '3', '4', '5');
  $array_dests = array();

  foreach ($all_dests['tid']['#options'] as $tid=>$term_infos) {
    $array_dests[$tid] = array();
    foreach ($all_dests['target']['#options'] as $target_name=>$target_infos) {
      if (substr($target_name, 0, strlen($tid)) == $tid && !is_numeric(substr($target_name, strlen($tid), 1))) {
        $target = substr($target_name, strlen($tid));
        $array_dests[$tid][$target] = array();
        foreach ($all_dests['layout']['#options'] as $layout_name=>$layout_infos) {
          if (substr($layout_name, 0, strlen($target_name)) == $target_name) {
            $layout = $layout_infos[substr($layout_name, strlen($target_name))];
            $array_dests[$tid][$target][$layout] = array();
            foreach ($ranks_list as $rank_elem) {
              $array_dests[$tid][$target][$layout][$rank_elem] = TRUE;
            }
          }
        }
      }
    }
  }
  
  return $array_dests; 
}
		
/**
 * Adds a META TAG to the process template queue.
 * 
 * @param $attributes
 *   Array of meta key keyword & key value. 
 *   If key keyword is one of "http-equiv, name, property"
 *   the Meta is updated in case of 2 calls.
 * @param $content
 *   Content of the meta tag.
 *   
 * @return
 * 	Return an array of meta.
 */
function wallytoolbox_add_meta($attributes = array(), $content = NULL) {

	static $wally_meta = array();
	$meta_key = NULL; 

	// Supported "Meta Keys" are : http-equiv, name, property. 
	foreach ($attributes as $attribute_name => $attribute_value) {
		switch (strtolower($attribute_name)) {
			case "name":
			case "http-equiv":
			case "property":
				$meta_key = strtolower($attribute_name)."_".$attribute_value;
				$wally_meta[$meta_key] = array( $attribute_name => $attribute_value, "content" => $content); 
				break;
			default:
				$wally_meta[] = array( $attribute_name => $attribute_value, "content" => $content); 
				break; 
		}
	}
	return $wally_meta;
}

/**
 * Generate HTML tag for meta tags.
 */
function wallytoolbox_get_meta() {

  if (!isset($wally_meta)) {
    $wally_meta = wallytoolbox_add_meta(array(), NULL);
  }

  if (empty($wally_meta)) {
    return '';
  }

  $output = '';
  
  foreach ($wally_meta as $meta_k => $meta) {
    if (!$meta) {
      continue;
    }
    $output .= "<meta ";
		foreach($meta as $data_k => $data_v) {
			$output .= " ".$data_k."=\"".$data_v."\"";
		}
    $output .= " />\n";
  }
  
  return $output;
}

/**
 * Hook preprocess for meta tags.
 */
function wallytoolbox_preprocess_page(&$variables) {
  $variables['meta'] = wallytoolbox_get_meta();	
}

/**
 * Implementation of hook_menu_link_alter()
 */
function wallytoolbox_menu_link_alter(&$item, $menu){
  if($item['module']=='taxonomy_menu' && !isset($item['updated'])){
    $item['hidden']=1;
  }
}

/**
 * Flush the page cache for the given internal url.
 */
function wallytoolbox_flush_all_pages($internal_urls = '*', $flush_aliases = FALSE, $flush_type = 'drupal') {
  global $base_url;
  $varnish_pages_to_flush = array();
  
  if (is_string($internal_urls))
    $internal_urls = array($internal_urls);
  
  foreach ($internal_urls as $internal_url) {
    $url_to_flush = array();
    $url_to_flush[] = $internal_url;
    
    if ($internal_url != '*' && $flush_aliases) {
      $aliases = wallytoolbox_get_all_aliases($internal_url);
      foreach ($aliases as $alias)
        $url_to_flush[] = $alias;
    }
  
    foreach($url_to_flush as $url) {
      if ($flush_type == 'drupal' || $flush_type == 'both') {
        if ($url == '*') {
          cache_clear_all($url, 'cache_page');
        } else {
          cache_clear_all($base_url.'/'.$url, 'cache_page');
        }
      }
      if ($flush_type == 'varnish' || $flush_type == 'both') {
        if ($url == '*') {
          warnish_purge_all_pages();
        } else {
          $varnish_pages_to_flush[] = $url;
        }
      }
    }
    
    if (strstr($internal_url, 'home')) {
      if ($flush_type == 'drupal' || $flush_type == 'both') {
        cache_clear_all($base_url.'/'.variable_get('site_frontpage', 'home'), 'cache_page', TRUE);
        cache_clear_all($base_url.'/', 'cache_page');
      }
      if ($flush_type == 'varnish' || $flush_type == 'both') {
        $varnish_pages_to_flush[] = variable_get('site_frontpage', 'home');
        $varnish_pages_to_flush[] = '/';
      }
    }
  }
  
  if (!empty($varnish_pages_to_flush))
    warnish_purge_page($varnish_pages_to_flush);
}

/**
 * Return an array of all existing aliases for an internal url.
 */
function wallytoolbox_get_all_aliases($internal_url) {
  $db_aliases = db_query("SELECT `dst` FROM `url_alias` WHERE `src` = '%s'", $internal_url);
  $return_aliases = array();
  
  while ($db_alias = db_fetch_array($db_aliases))
    $return_aliases[] = $db_alias['dst'];
  
  return $return_aliases;
}

/**
 * Delete the Drupal file and remove the physical file of a photo.
 * 
 * @param array $photofile
 *   A Drupal file array.
 */
function wallytoolbox_delete_photofile($photofile) {
  if (isset($photofile['filepath'])) {
    $filepath = $photofile['filepath'];
    file_delete($filepath);
    db_query('DELETE FROM files WHERE filepath = "%s"', $filepath);
  }
}

/**
 * Implementation of hook_cron().
 */ 
function wallytoolbox_cron(){
  $return = '<b>Run '.date('Y-m-d H:i:s').' :</b></br>';
  $count = db_fetch_array(db_query('SELECT COUNT(*) FROM {wallytoolbox_content_types_cache}'));
  if ($count['COUNT(*)'] == '0')
    wallytoolbox_refresh_cache_list();
  
  $blocks_list = db_query('SELECT * FROM {wallytoolbox_content_types_cache} WHERE enabled = 1 AND last_run < %d - rule ORDER BY weight ASC, cid ASC', time());
  while ($block = db_fetch_array($blocks_list)) {
    while (is_string($block['settings']))
      $block['settings'] = unserialize($block['settings']);
    $block_infos = explode(':', $block['cid']);
    $output = module_invoke_all('refresh_block', $block_infos, $block['settings']);
    $block['output'] .= serialize($output);
    $block['last_run'] = time();
    drupal_write_record('wallytoolbox_content_types_cache', $block, 'cid');
    $return .= $block['cid'].'</br>';
  }
  
  print $return;
}

/**
 * Get all blocks and put them in the wallytoolbox_content_types_cache table.
 */
function wallytoolbox_refresh_cache_list() {
  list($panels, $handlers) = wallytoolbox_get_panels_and_handlers();
  
  // Get previous settings from DB to save the cron config
  $blocks_list_db = db_query('SELECT * FROM {wallytoolbox_content_types_cache}');
  $blocks_list = array();
  while ($temp_block = db_fetch_array($blocks_list_db))
    $blocks_list[$temp_block['cid']] = $temp_block;
  
  // Restart from an empty table
  db_query('TRUNCATE TABLE wallytoolbox_content_types_cache');
  
  // Transform the list to get the same structure as the table and add an entry to the table
  foreach ($handlers as $page_name => $page_handlers) {
    if (is_array($page_handlers) && !empty($page_handlers)) {
      foreach ($page_handlers as $handler) {
        $block = array();
        $config = $handler->configuration;
        $block['cid'] = $page_name.':'.$handler->type.':'.$handler->subtype.':'.$handler->panel.':'.$handler->pid;
        
        if (isset($blocks_list[$block['cid']])) {
          $block['output'] = $blocks_list[$block['cid']]['output'];
          $block['last_run'] = $blocks_list[$block['cid']]['last_run'];
          $block['enabled'] = $blocks_list[$block['cid']]['enabled'];
          $block['weight'] = $blocks_list[$block['cid']]['weight'];
          $block['rule'] = $blocks_list[$block['cid']]['rule'];
        } else {
          $block['rule'] = isset($config['wally_rule']) ? 60*$config['wally_rule'] : 0;
        }
        
        $config['wally_rule'] = 0; // Just to be sure the rule parameter is setted before unset it
        unset($config['wally_rule']);
        $block['settings'] = $config;
        
        drupal_write_record('wallytoolbox_content_types_cache', $block);
      }
    }
  }
}

/**
 * Get a list of all blocks set in all pages
 */
function wallytoolbox_get_panels_and_handlers() {
  $pages = page_manager_get_tasks_by_type('page');
  $handlers = array();
  $panels = array();
  foreach ($pages as $page_name => $page) {
    $cached_page = page_manager_get_page_cache($page_name);
    $handlers[$page_name] = isset($cached_page->handlers->conf['display']) ? $cached_page->handlers->conf['display'] : array();
    foreach ($cached_page->handlers as $handler_name => $handler) {
      $cached_panels = panels_edit_cache_get('panel_context:' . $page_name . ':' . $handler->name);
      $panels[$handler_name][] = $cached_panels;
      foreach ($cached_panels->display->content as $display_content)
        $handlers[$page_name][] = $display_content;
    }
  }
  $return = array($panels, $handlers);
  
  return $return;
}

function wallytoolbox_flow_to_array_init_array() {
  $array_packages = array();
  $array_packages['Packages'] = array();
  return $array_packages;
}

/**
 * Initialise an array following the schema of a Wallymport articlepackage.
 * Only required fields are initialised.
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_flow_to_array_new_package() {
  $array_item = array();
  $array_item['Package']['PackageID'] = '';
  $array_item['Package']['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $array_item['Package']['EmbargoDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $array_item['Package']['Language'] = '';
  $array_item['Package']['PackageTitle']['value'] = '';
  $array_item['Package']['ExternalReference']['value'] = '';
  $array_item['Package']['ProductID']['value'] = '';
  $array_item['Package']['Destinations'] = array();
  $array_item['Package']['Destinations']['Destination'] = array();
  $array_item['Package']['Destinations']['Destination']['DestinationRank'] = '';
  $array_item['Package']['Destinations']['Destination']['Position'] = '';
  $array_item['Package']['Destinations']['Destination']['DocumentLayout'] = '';
  $array_item['Package']['Destinations']['Destination']['DestinationPath']['value'] = '';
  $array_item['Package']['Editions'] = array();
  $array_item['Package']['Editions']['Edition']['EditionID'] = 'all';
  $array_item['Package']['Editions']['Edition']['value'] = 'true';
  $array_item['Package']['Channels'] = array();
  $array_item['Package']['Channels']['Channel']['Name'] = '';
  $array_item['Package']['Summary']['value'] = '';
  $array_item['Package']['ExternalURI']['value'] = 'http://';
  $array_item['Package']['MainStory'] = wallytoolbox_rss_item_to_array_new_textobject();
  return $array_item;
}

/**
 * Initialise an array following the schema of a Wallymport textobject.
 * Only required fields are initialised (+ the taxonomy field).
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_flow_to_array_new_textobject() {
  $textobject = array();
  $textobject['ObjectID'] = '';
  $textobject['PublicationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $textobject['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $textobject['Title']['value'] = '';
  $textobject['ExternalReference']['value'] =  '';
  $textobject['Taxonomy'] = array();
  $textobject['Taxonomy']['Vocabulary'] = array();
  $textobject['Taxonomy']['Vocabulary']['VocabularyName'] = 'Default';
  $textobject['Taxonomy']['Vocabulary']['VocabularyType'] = 'free';
  $textobject['Taxonomy']['Vocabulary']['Term'] = array();
  $textobject['TextTitle']['value'] = '';
  $textobject['TextBody']['value'] = '';
  return $textobject;
}

/**
 * Initialise an array following the schema of a Wallymport photoobject.
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_flow_to_array_new_photoobject() {
  $photoobject = array();
  $photoobject['ObjectID'] = '';
  $photoobject['PublicationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $photoobject['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $photoobject['Title']['value'] = '';
  $photoobject['ExternalReference']['value'] = '';
  $photoobject['FileURI']['value'] = 'http://';
  $photoobject['FileSize']['value'] = '';
  return $photoobject;
}

/**
 * Initialise an array following the schema of a Wallymport videoobject.
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_flow_to_array_new_videoobject() {
  $videoobject = array();
  $videoobject['ObjectID'] = '';
  $videoobject['PublicationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $videoobject['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $videoobject['Title']['value'] = '';
  $videoobject['ExternalReference']['value'] = '';
  $videoobject['FileURI']['value'] = 'http://';
  $videoobject['FileSize']['value'] = '';
  return $videoobject;
}

/**
 * @} End of "defgroup wallytoolbox".
 */
