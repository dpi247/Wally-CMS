<?php
/**
 * @defgroup wallytoolbox Wally ToolBox functions
 * @{
 * In this module we define functions that could be used in any of 
 * the wally modules. These function aren't linked to a specific context
 * and could be use anywhere. 
 */

// module_load_include('inc', 'wallytoolbox', 'includes/wally_gmap');

/**
 * A true boolean conversion function.
 * 
 * @param $v
 *   The value to be converted
 * @param $del
 *   default value return if conversion fail.
 *
 * @return
 *   boolean "true" or "false"
 */
function wallytoolbox_toboolean($v, $def=NULL) {
  if ($v===FALSE) return FALSE;
  if ($v===TRUE) return TRUE;
  if ($v=="true") return TRUE;
  if ($v=="false") return FALSE;
  if ($v==0) return FALSE;
  if ($v==1) return TRUE;
  return $def;
}

/**
 * Search for taxonomy terms for a specific "path". 
 *
 * @param $path
 *   The taxonomy term path to match ( /term1/term2/term3 ). 
 * @param $voc
 *   The taxonomy vocabulary used for filtering on a single vocabulary.
 *   If not set, will seach into all vocabularies.
 *
 * @return
 *   an array of taxonomy term object
 */
function wallytoolbox_taxonomy_get_term_by_path($path, $voc=null) {
	$t = explode("/", trim($path,"/"));
	$t = $t[count($t)-1];

	if ($voc) {
		$db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s') AND t.vid = %s", trim($t), $voc);
	} else {
		$db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s')", trim($t));
	}

	$result = array();

	// Reverse building of path for founded terms.
	while ($term = db_fetch_object($db_result)) {
		$ppath = "";
		$parents = taxonomy_get_parents_all($term->tid);
		foreach ($parents as $parent) $ppath = strtolower($parent->name)."/".$ppath;
		if (trim($ppath,"/")==strtolower(trim($path,"/"))) $result[] = $term;
	}
	return ($result ? $result : null);
}

/**
 * Return the parents hierarchy of a taxonomic term according to the vocabulary structure.
 * Example: if given the tid of the term "Belgium", returns "News/World/Belgium".
 * 
 * @param string $term
 *   A taxonomy term ID or name. If it is a name, the chosen term will
 * be the one matching the $vid, if given, or the first in the results
 * list.
 * @param string $vid
 *   The vocabulary ID.
 * 
 * @return
 *   A string containing the parents hierarchy, separated by "/".
 */
function wallytoolbox_taxonomy_get_path_by_tid_or_term($term, $vid = '') {
  $return = '';
  
  if (!is_numeric($term)) {
    $terms_list = taxonomy_get_term_by_name($term);
    if ($vid != '') {
      foreach ($terms_list as $term_elem) {
        if ($term_elem->vid == $vid) {
          $tid = $term_elem->tid;
          break;
        }
      }
    } else {
      $tid = $terms_list[0]->tid;
    }
  } else {
    $tid = $term;
  }
  
  $tax_list = taxonomy_get_parents_all($tid);
  foreach (array_reverse($tax_list) as $tax_elem) {
    $return .= $tax_elem->name.'/';
  }
  
  return substr($return, 0, strlen($return)-1);
}

/**
 * Add a taxonomy term into a vocabulary without 
 * need to store a node.
 *
 * @param $name
 *   That's the taxonomy term name. 
 * @param $vid
 *   The Taxonomy Vocabulary to store the term. 
 * @param $description
 *   Description of the term to be stored.
 * @param $weight
 *   Weight of the term into vocabulary (default 0).
 * @param $parent
 *   Parent term if needed (default null).
 * 
 * @return
 *   Taxonomy TID of the created term. 
 */
function wallytoolbox_add_taxonomy_term($name, $vid, $description = '', $weight = 0, $parent = null){
  $form_values = array();
  $form_values['name'] = $name;
  $form_values['description'] = $description;
  $form_values['vid'] = $vid;
  $form_values['weight'] = $weight;
  if ($parent) $form_values['parent'] = $parent;
  taxonomy_save_term($form_values);
  return $form_values['tid'];
}


/**
 * Get all nodes associated with a array of taxonomy term.  
 *  
 * @param $tid
 *   An array of term IDs to match. 
 * @param $operator
 *   Could be 'or' or 'and' (default 'or') 
 * @param $depth
 *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative integer or "all". 
 * @param $pager 
 *   Whether the nodes are to be used with a pager (the case on most Drupal pages) or not (in an XML feed, for example).
 * @param $type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * @param $order
 *   Order close for TID (SSL format). See @link http://api.drupal.org/api/drupal/includes--database.inc/group/database/6 Data Base abstraction layer @endlink for table aliases.
 * 
 * @return
 *   Array of Node ID. 
 */
function wallytoolbox_taxonomy_get_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $type = null, $order = 'n.sticky DESC, n.created DESC'){

  $r = array();

  if (count($tids) > 0) {
        
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    
    foreach ($tids as $index => $tid) {
      $term = taxonomy_get_term($tid);
      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
    }

    if ($operator == 'or') {
      $args = call_user_func_array('array_merge', $descendant_tids);
      $placeholders = db_placeholders($args, 'int');
      $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
    }
    else {
      $joins = '';
      $wheres = '';
      $args = array();
      foreach ($descendant_tids as $index => $tids) {
        $joins .= ' INNER JOIN {term_node} tn' . $index . ' ON n.vid = tn' . $index . '.vid';
        $wheres .= ' AND tn' . $index . '.tid IN (' . db_placeholders($tids, 'int') . ')';
        $args = array_merge($args, $tids);
      }
      $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.created  FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
    }

    if ($type) {
      $sql = $sql . ' AND n.type = "'.$type.'"';
      $sql_count = $sql_count . ' AND n.type = "'.$type.'"';
    }

    // add Order Clause
    $sql = $sql . ' ORDER BY ' . $order; 

    $sql = db_rewrite_sql($sql);
    $sql_count = db_rewrite_sql($sql_count);

    if ($pager) {
      $results = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);
    } else {
      $results = db_query($sql, $args);
    }

    while ($result = db_fetch_object($results)) {
      $r[] = $result->nid;
    }

  }
  return $r;
}


/**
 * Get all nodes where cckfield match a value. 
 *
 * @param $param
 *   An associative array containing:
 *   - key: An existing cck_field name with the prfix "field_" 
 *   - value: The value to match specified cck_field
 * @param $node_type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * 
 * @return
 *   An array of nodes
 */
function wallytoolbox_get_node_by_cckfield($param,$node_type=null){

	$nodes = array();
	foreach ($param as $key => $value) {
		$sql="
			SELECT node.nid AS nid
			 FROM {node} node 
			 LEFT JOIN {content_".$key."} node_data_".$key." ON node.vid = node_data_".$key.".vid
			 WHERE (node_data_".$key.".".$key."_value = '%s')
			";

		// Fetch all node from CCK field table.
		if ($result = db_query($sql, $value)) {
			while ($item = db_fetch_object($result)) {
				if ($node = node_load($item->nid)) {
					if ($node_type) {
						if ($node->type == $node_type) {
							$nodes[$node->nid] = $node;
						}
					} else {
						$nodes[$node->nid] = $node;
					}
				} 
			}
		}
	}
	
	$result = array(); 
	foreach($nodes as $node) $result[]=$node;

	if (count($result)) { 
		return $result;
	} else {
		return null;
	}
}

/**
 * Get nid from packages who reference the current node.
 *
 * @param $node
 *   Node currently processed(TextObject, AudioObject, DigitalObject,PhotoObject, Videoobject, PollObject)
 *
 * @return
 *   Array() of array() of nid
 */
function wallytoolbox_get_node_by_reference($node) {
  $rows = array();

  if($node->type=='wally_textobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_articlepackage} WHERE field_mainstory_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  } elseif($node->type=='wally_audioobject' || $node->type=='wally_digitalobject' || $node->type=='wally_photoobject' || $node->type=='wally_videoobject'){
    if ($res=db_query("SELECT nid FROM {content_field_embededobjects} WHERE field_embededobjects_nid = %d", $node->nid)){
      while ($row = db_fetch_array($res)) {
        if (!in_array($row, $rows)) $rows[] = $row;
      }
    } else
    if ($res2=db_query("SELECT nid FROM {content_type_wally_gallerypackage} WHERE field_mainobject_nid = %d", $node->nid)) {
      while ($row = db_fetch_array($res2)) {
        if (!in_array($row, $rows)) $rows[] = $row;
      }
    }
  } elseif($node->type=='wally_pollobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_pollpackage} WHERE field_mainpoll_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  }
  return $rows;
}

/**
 * Transform a DOMDocument, DOMNode, DOMElement, wathever, in an array.
 */
function dom2array($node) {
  $res = array();
  if($node->nodeType == XML_TEXT_NODE){
      $res = $node->nodeValue;
  }
  else{
      if($node->hasAttributes()){
          $attributes = $node->attributes;
          if(!is_null($attributes)){
              $res['@attributes'] = array();
              foreach ($attributes as $index=>$attr) {
                  $res['@attributes'][$attr->name] = $attr->value;
              }
          }
      }
      if($node->hasChildNodes()){
          $children = $node->childNodes;
          for($i=0;$i<$children->length;$i++){
              $child = $children->item($i);
              $res[$child->nodeName] = dom2array($child);
          }
      }
  }
  return $res;
}

/**
 * Recursively remove a dir.
 */
function rrmdir($dir) { 
  if ($dir && isset($dir) && is_dir($dir)) { 
    $objects = scandir($dir); 
    foreach ($objects as $object) { 
      if ($object != "." && $object != "..") { 
        if (filetype($dir."/".$object) == "dir") rrmdir($dir."/".$object); else unlink($dir."/".$object); 
      } 
    } 
    reset($objects); 
    rmdir($dir); 
  } 
}

/**
 * Build an array from a RSS item. The array structure is based on the
 * structure required by Wallymport.
 * 
 * The structure follows the rule :
 * $array[element_name][attribute_name] = attribute_value
 * or
 * $array[element_name][subelement_name] = subelement (array)
 * And so on..
 * 
 * If the subelement is just a text value, use 'value' as subelement_name.
 * 
 * @param $channel
 *   The full RSS channel, needed because of the media fields which can
 *   be written anywhere in the feed.
 * @param $item
 *   The RSS to be transformed.
 * @param $feed_infos
 *   The infos of the feed as recorded in the DB.
 * 
 * @return
 *   The array-restructured item.
 */
function wallytoolbox_rss_item_to_array($channel, $item, $media_namespace = 'http://search.yahoo.com/mrss/', $feed_infos = array('name'=>'RSS', 'destination'=>'0///', 'channel_img'=>0)) {
  $array_item = wallytoolbox_rss_item_to_array_init_array();
  
  $feed_name = wallytoolbox_rss_item_to_array_set_package($array_item, $item, $feed_infos);
  wallytoolbox_rss_item_to_array_set_mainstory($array_item, $item, $feed_name);

  $enclosure = $item->getElementsByTagName('enclosure');
  if ($enclosure->item(0) && $enclosure->item(0)->getAttribute('type') && strstr($enclosure->item(0)->getAttribute('type'), 'image')) {
    wallytoolbox_rss_item_to_array_set_enclosure($array_item, $enclosure, $feed_name);
  }

  $media_contents = $item->getElementsByTagNameNS($media_namespace, 'content');
  if ($media_contents->item(0)) {
    wallytoolbox_rss_item_to_array_set_medias($array_item, $channel, $item, $media_contents, $feed_name, $media_namespace);
  }

  $channel_img = $channel->getElementsByTagName('image');
  if ($feed_infos['channel_img'] && !isset($array_item['Package']['EmbeddedContent']) && $channel_img->item(0)) {
    wallytoolbox_rss_item_to_array_set_image($array_item, $channel_img->item(0));
  }

  return $array_item;
}

/**
 * Search an item for a desired element.
 * 
 * @param $dom_item
 *   The item in which the search is performed.
 * @param $name
 *   The name of the searched element.
 * @param $namespace
 *   Value of the namespace if used.
 * @param $second_choice
 *   If the element given by $name isn\'t found, you have a second chance.
 * @param $feed_name
 *   The name of the feed as recorded in the DB. Needed as default
 *   external reference value.
 * 
 * @return
 *   The element value or ''.
 */
function _wallytoolbox_checkifelementexists($dom_item, $name, $namespace = 'none', $second_choice = '', $feed_name = '') {
  if ($namespace != 'none') {
    $return = $dom_item->getElementsByTagNameNS($namespace, $name)->item(0) ? $dom_item->getElementsByTagNameNS($namespace, $name)->item(0)->firstChild->wholeText : '';
    if ($second_choice != '') {
      if ($return == '') {
        $return = $dom_item->getElementsByTagNameNS($namespace, $second_choice)->item(0) ? $dom_item->getElementsByTagNameNS($namespace, $second_choice)->item(0)->firstChild->wholeText : '';
      } else {
        $return = $feed_name.':::'.$return;
      }
    }
  } else {
    $return = $dom_item->getElementsByTagName($name)->item(0) ? $dom_item->getElementsByTagName($name)->item(0)->firstChild->wholeText : '';
    if ($second_choice != '') {
      if ($return == '') {
        $return = $dom_item->getElementsByTagName($second_choice)->item(0) ? $dom_item->getElementsByTagName($second_choice)->item(0)->firstChild->wholeText : '';
      } else {
        $return = $feed_name.':::'.$return;
      }
    }
  }
  return $return;
}

/**
 * Perform a recursive search in a media item for a desired element.
 * 
 * @param $media_content
 *   The item in which the first step search is performed.
 * @param $item
 *   The item in which the second step search is performed.
 * @param $channel
 *   The channel in which the third and last step search is performed.
 * @param $namespace
 *   Value of the namespace if used.
 * @param $name
 *   The name of the searched element.
 * 
 * @return
 *   The element value or ''.
 */
function _wallytoolbox_checkifmediaelementexists($media_content, $item, $channel, $namespace, $name) {
  $return = _wallytoolbox_checkifelementexists($media_content, $name, $namespace);
  if ($return == '') {
    $return = _wallytoolbox_checkifelementexists($item, $name, $namespace);
    if ($return == '') {
      $return = _wallytoolbox_checkifelementexists($channel, $name, $namespace);
    }
  }
  return $return;
}

/**
 * Initialise an array following the schema of a Wallymport articlepackage.
 * Only required fields are initialised.
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_rss_item_to_array_init_array() {
  $array_item = array();
  $array_item['Package']['PackageID'] = '';
  $array_item['Package']['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $array_item['Package']['EmbargoDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $array_item['Package']['Language'] = '';
  $array_item['Package']['PackageTitle']['value'] = '';
  $array_item['Package']['ExternalReference']['value'] = '';
  $array_item['Package']['ProductID']['value'] = '';
  $array_item['Package']['Destinations'] = array();
  $array_item['Package']['Destinations']['Destination'] = array();
  $array_item['Package']['Destinations']['Destination']['DestinationRank'] = '';
  $array_item['Package']['Destinations']['Destination']['Position'] = '';
  $array_item['Package']['Destinations']['Destination']['DocumentLayout'] = '';
  $array_item['Package']['Destinations']['Destination']['DestinationPath']['value'] = '';
  $array_item['Package']['Editions'] = array();
  $array_item['Package']['Editions']['Edition']['EditionID'] = 'all';
  $array_item['Package']['Editions']['Edition']['value'] = 'true';
  $array_item['Package']['Channels'] = array();
  $array_item['Package']['Channels']['Channel']['Name'] = '';
  $array_item['Package']['Summary']['value'] = '';
  $array_item['Package']['ExternalURI']['value'] = 'http://';
  $array_item['Package']['MainStory'] = wallytoolbox_rss_item_to_array_new_textobject();
  return $array_item;
}

/**
 * Initialise an array following the schema of a Wallymport textobject.
 * Only required fields are initialised (+ the taxonomy field).
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_rss_item_to_array_new_textobject() {
  $textobject = array();
  $textobject['ObjectID'] = '';
  $textobject['PublicationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $textobject['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $textobject['Title']['value'] = '';
  $textobject['ExternalReference']['value'] =  '';
  $textobject['Taxonomy'] = array();
  $textobject['Taxonomy']['Vocabulary'] = array();
  $textobject['Taxonomy']['Vocabulary']['VocabularyName'] = 'Default';
  $textobject['Taxonomy']['Vocabulary']['VocabularyType'] = 'free';
  $textobject['Taxonomy']['Vocabulary']['Term'] = array();
  $textobject['TextTitle']['value'] = '';
  $textobject['TextBody']['value'] = '';
  return $textobject;
}

/**
 * Initialise an array following the schema of a Wallymport photoobject.
 * 
 * @return
 *   The initialised array.
 */
function wallytoolbox_rss_item_to_array_new_photoobject() {
  $photoobject = array();
  $photoobject['ObjectID'] = '';
  $photoobject['PublicationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $photoobject['CreationDate'] = date('Y-m-d').'T'.date('H:i:sP');
  $photoobject['Title']['value'] = '';
  $photoobject['ExternalReference']['value'] = '';
  $photoobject['FileURI']['value'] = 'http://';
  $photoobject['FileSize']['value'] = '';
  return $photoobject;
}

/**
 * Get package available parameters from an RSS feed item domElement
 * and set an array item according to the structure defined in
 * Wallymport.
 * 
 * @param array &$array_item
 *   The array item under construction.
 * @param domElement $item
 *   The XML RSS feed item domElement.
 * @param array $feed_infos
 *   General informations about the feed being analyzed.
 */
function wallytoolbox_rss_item_to_array_set_package(&$array_item, $item, $feed_infos) {
  $feed_name = $feed_infos['name'];
  $feed_destination = explode('/',$feed_infos['destination']);
  $array_item['Package']['PackageID'] = _wallytoolbox_checkifelementexists($item, 'guid', 'none', 'link', $feed_name);
  $channel_pubDate = strtotime(_wallytoolbox_checkifelementexists($item, 'pubDate'));
  $pubDate = date('Y-m-d', $channel_pubDate).'T'.date('H:i:sP', $channel_pubDate);
  $array_item['Package']['PublicationDate'] = $pubDate;
  $array_item['Package']['PackageTitle']['value'] = _wallytoolbox_checkifelementexists($item, 'title');
  $array_item['Package']['ExternalReference']['value'] = _wallytoolbox_checkifelementexists($item, 'guid', 'none', 'link', $feed_name);
  $array_item['Package']['ProductID']['value'] = variable_get('wallymport_productID', $_SERVER['HTTP_HOST']);
  $array_item['Package']['Destinations']['Destination']['DestinationRank'] = $feed_destination[3];
  $array_item['Package']['Destinations']['Destination']['Position'] = $feed_destination[1];
  $array_item['Package']['Destinations']['Destination']['DocumentLayout'] = $feed_destination[2];
  $array_item['Package']['Destinations']['Destination']['DestinationPath']['value'] = taxonomy_get_term($feed_destination[0]) ? taxonomy_get_term($feed_destination[0])->name : '';
  $array_item['Package']['ExternalURI']['value'] = _wallytoolbox_checkifelementexists($item, 'link');
  
  return $feed_name;
}

/**
 * Get mainstory available parameters from an RSS feed item domElement
 * and set an array item according to the structure defined in
 * Wallymport.
 * 
 * @param array &$array_item
 *   The array item under construction.
 * @param domElement $item
 *   The XML RSS feed item domElement.
 * @param string $feed_name
 *   The name of the feed being analyzed.
 */
function wallytoolbox_rss_item_to_array_set_mainstory(&$array_item, $item, $feed_name) {
  $array_item['Package']['MainStory']['ObjectID'] = _wallytoolbox_checkifelementexists($item, 'title');
  $array_item['Package']['MainStory']['PublicationDate'] = $array_item['Package']['PublicationDate'];
  $array_item['Package']['MainStory']['Title']['value'] = _wallytoolbox_checkifelementexists($item, 'title');
  $array_item['Package']['MainStory']['ExternalReference']['value'] =  _wallytoolbox_checkifelementexists($item, 'guid', 'none', 'link', $feed_name);
  $array_item['Package']['MainStory']['Taxonomy']['Vocabulary']['VocabularyName'] = 'RSS feeds';
  $categories = $item->getElementsByTagName('category');
  if ($categories->item(0)) {
    foreach ($categories as $category) {
      $array_item['Package']['MainStory']['Taxonomy']['Vocabulary']['Term'][] = $feed_name.'/'.str_replace('/', '-', $category->firstChild->wholeText);
    }
  }
  $array_item['Package']['MainStory']['Copyright']['value'] = _wallytoolbox_checkifelementexists($item, 'author');
  $array_item['Package']['MainStory']['TextTitle']['value'] = _wallytoolbox_checkifelementexists($item, 'title');
  $array_item['Package']['MainStory']['TextBody']['value'] = _wallytoolbox_checkifelementexists($item, 'description');
}

/**
 * Get available parameters from an enclosure domElement of a RSS feed
 * item and set an array item according to the structure defined in
 * Wallymport.
 * 
 * @param array &$array_item
 *   The array item under construction.
 * @param domElement $enclosure
 *   The enclosure domElement from the XML RSS feed item.
 * @param string $feed_name
 *   The name of the feed being analyzed.
 */
function wallytoolbox_rss_item_to_array_set_enclosure(&$array_item, $enclosure, $feed_name) {
  $array_item['Package']['EmbeddedContent'] = array();
  $array_item['Package']['EmbeddedContent']['EmbeddedObjects'] = array();
  $array_item['Package']['EmbeddedContent']['EmbeddedObjects']['Object'] = array();
  $tempobject = wallytoolbox_rss_item_to_array_new_photoobject();
  $tempobject['ObjectID'] = _wallytoolbox_checkifelementexists($item, 'title');
  $tempobject['PublicationDate'] = $array_item['Package']['PublicationDate'];
  $tempobject['MimeType'] = $enclosure->item(0)->getAttribute('type');
  $tempobject['Title']['value'] = $enclosure->item(0)->getAttribute('url');
  $tempobject['ExternalReference']['value'] = _wallytoolbox_checkifelementexists($item, 'guid', 'none', 'link', $feed_name);
  $tempobject['FileURI']['value'] = $enclosure->item(0)->getAttribute('url');
  $tempobject['FileSize']['value'] = $enclosure->item(0)->getAttribute('length');
  $array_item['Package']['EmbeddedContent']['EmbeddedObjects']['Object'][] = $tempobject;
}

/**
 * Get available parameters from medias domElement of a RSS feed
 * item and set an array item according to the structure defined in
 * Wallymport.
 * 
 * @param array &$array_item
 *   The array item under construction.
 * @param domNode $channel
 *   The full RSS channel from a RSS feed.
 * @param domElement $item
 *   The XML RSS feed item domElement.
 * @param domElement $media_contents
 *   The medias domElements from a RSS feed.
 * @param string $feed_name
 *   The name of the feed being analyzed.
 */
function wallytoolbox_rss_item_to_array_set_medias(&$array_item, $channel, $item, $media_contents, $feed_name, $media_namespace = 'http://search.yahoo.com/mrss/') {
  $first_media = TRUE;
  foreach ($media_contents as $media_content) {
    if (($media_content->getAttribute('type') && strstr($media_content->getAttribute('type'), 'image')) || ($media_content->getAttribute('medium') && strstr($media_content->getAttribute('medium'), 'image'))) {
      if (getimagesize($media_content->getAttribute('url'))) {
        wallytoolbox_rss_item_to_array_set_media($array_item, $channel, $item, $media_content, $feed_name, $first_media, $media_namespace);
        $first_media = FALSE;
      }
    }
  }
}

/**
 * Get available parameters from a media domElement of a RSS feed
 * item and set an array item according to the structure defined in
 * Wallymport.
 * 
 * @param array &$array_item
 *   The array item under construction.
 * @param domNode $channel
 *   The full RSS channel from a RSS feed.
 * @param domElement $item
 *   The XML RSS feed item domElement.
 * @param domElement $media_content
 *   One of the media domElement from a RSS feed.
 * @param string $feed_name
 *   The name of the feed being analyzed.
 * @param boolean $first_media
 *   Check if it's the first media added to this array item.
 */
function wallytoolbox_rss_item_to_array_set_media(&$array_item, $channel, $item, $media_content, $feed_name, $first_media, $media_namespace = 'http://search.yahoo.com/mrss/') {
  static $media_num = 0;
  if ($first_media) {
    $array_item['Package']['EmbeddedContent'] = array();
    $array_item['Package']['EmbeddedContent']['EmbeddedObjects'] = array();
    $array_item['Package']['EmbeddedContent']['EmbeddedObjects']['Object'] = array();
    $first_media = FALSE;
  }
  $tempobject = wallytoolbox_rss_item_to_array_new_photoobject();
  $tempobject['ObjectID'] = _wallytoolbox_checkifelementexists($item, 'title');
  $tempobject['PublicationDate'] = $array_item['Package']['PublicationDate'];
  $tempobject['MimeType'] = $media_content->getAttribute('type');
  $media_title = _wallytoolbox_checkifmediaelementexists($media_content, $item, $channel, $media_namespace, 'title');
  $tempobject['Title']['value'] = ($media_title == '') ? $tempobject['ObjectID'].'_image_'.$media_num : $media_title;
  $media_num += 1;
  $tempobject['ExternalReference']['value'] = _wallytoolbox_checkifelementexists($item, 'guid', 'none', 'link', $feed_name);
  $tempobject['Copyright']['value'] = _wallytoolbox_checkifmediaelementexists($media_content, $item, $channel, $media_namespace, 'copyright');
  $tempobject['Summary']['value'] =_wallytoolbox_checkifmediaelementexists($media_content, $item, $channel, $media_namespace, 'description');
  $tempobject['FileURI']['value'] = $media_content->getAttribute('url');
  $object_filesize = $media_content->getAttribute('fileSize');
  if (!$object_filesize) $object_filesize = 0;
  $tempobject['FileSize']['value'] = $object_filesize;
  $keywords = _wallytoolbox_checkifmediaelementexists($media_content, $item, $channel, $media_namespace, 'keywords');
  if ($keywords != '') {
    $keywords = explode(',',$keywords);
    foreach ($keywords as $keyword) {
      $array_item['Package']['MainStory']['Taxonomy']['Vocabulary']['Term'][] = $feed_name.'/'.str_replace('/', '-', $keyword);
    }
  }
  $media_categories = _wallytoolbox_checkifmediaelementexists($media_content, $item, $channel, $media_namespace, 'category');
  if ($media_categories != '') {
    $media_categories = explode('/',$media_categories);
    foreach ($media_categories as $media_category) {
      $array_item['Package']['MainStory']['Taxonomy']['Vocabulary']['Term'][] = $feed_name.'/'.str_replace('/', '-', $media_category);
    }
  }
  $media_thumbnails = $media_content->getElementsByTagNameNS($media_namespace, 'thumbnail');
  if ($media_thumbnails->item(0)) {
    $media_thumbnail = $media_thumbnails->item(0);
    $tempobject['Thumbnail']['URI'] = $media_thumbnail->getAttribute('url');
    $thumbnail_w = $media_content->getAttribute('width');
    if ($thumbnail_w) $tempobject['Thumbnail']['W'] = $thumbnail_w;
    $thumbnail_h = $media_content->getAttribute('height');
    if ($thumbnail_h) $tempobject['Thumbnail']['H'] = $thumbnail_h;
  }
  $media_rating = _wallytoolbox_checkifmediaelementexists($media_content, $item, $channel, $media_namespace, 'rating');
  $acceptable_rating = array();
  $all_voc = taxonomy_get_vocabularies();
  foreach ($all_voc as $voc) {
    if ($voc->name == 'Rating') {
      $available_ratings = taxonomy_get_tree($voc->vid);
      foreach ($available_ratings as $available_rating) {
        $acceptable_rating[] = $available_rating->name;
      }
      break;
    }
  }
  if (in_array(strtoupper($media_rating), $acceptable_rating)) {
    $tempobject['Rating']['value'] = strtoupper($media_rating);
  }
  
  $array_item['Package']['EmbeddedContent']['EmbeddedObjects']['Object'][] = $tempobject;
}

/**
 * Get available parameters from an image domElement of a RSS feed
 * item and set an array item according to the structure defined in
 * Wallymport.
 * 
 * @param array &$array_item
 *   The array item under construction.
 * @param domElement $channel_img
 *   The image domElement from the XML RSS feed item.
 */
function wallytoolbox_rss_item_to_array_set_image(&$array_item, $channel_img) {
  static $chan_img_num = 100;
  $array_item['Package']['EmbeddedContent'] = array();
  $array_item['Package']['EmbeddedContent']['EmbeddedObjects'] = array();
  $array_item['Package']['EmbeddedContent']['EmbeddedObjects']['Object'] = array();
  $tempobject = wallytoolbox_rss_item_to_array_new_photoobject();
  $tempobject['ObjectID'] = _wallytoolbox_checkifelementexists($channel_img, 'title');
  $tempobject['PublicationDate'] = $array_item['Package']['PublicationDate'];
  $tempobject['MimeType'] = 'image';
  $media_title = $channel_img->getAttribute('title');
  $tempobject['Title']['value'] = ($media_title == '') ? $tempobject['ObjectID'].'_image_'.$chan_img_num : $media_title;
  $chan_img_num += 1;
  $tempobject['ExternalReference']['value'] = $channel_img->getAttribute('url');
  $tempobject['FileURI']['value'] = $channel_img->getAttribute('url');
  $tempobject['FileSize']['value'] = 0;
  $tempobject['LinkTitle']['value'] = $channel_img->getAttribute('title');
  $tempobject['LinkURI']['value'] = $channel_img->getAttribute('link');
  $array_item['Package']['EmbeddedContent']['EmbeddedObjects']['Object'][] = $tempobject;
}

/**
 * Return all available destinations in an array following the
 * structure :
 * 
 * array[destination_path_tid][position][layout][rank] = TRUE;
 */
function wallytoolbox_destinations_items_array(){
  $all_dests = cckdestinations_get_classes_and_options();
  $ranks_list = array('1', '2', '3', '4', '5');
  $array_dests = array();

  foreach ($all_dests['tid']['#options'] as $tid=>$term_infos) {
    $array_dests[$tid] = array();
    foreach ($all_dests['target']['#options'] as $target_name=>$target_infos) {
      if (substr($target_name, 0, strlen($tid)) == $tid && !is_numeric(substr($target_name, strlen($tid), 1))) {
        $target = substr($target_name, strlen($tid));
        $array_dests[$tid][$target] = array();
        foreach ($all_dests['layout']['#options'] as $layout_name=>$layout_infos) {
          if (substr($layout_name, 0, strlen($target_name)) == $target_name) {
            $layout = $layout_infos[substr($layout_name, strlen($target_name))];
            $array_dests[$tid][$target][$layout] = array();
            foreach ($ranks_list as $rank_elem) {
              $array_dests[$tid][$target][$layout][$rank_elem] = TRUE;
            }
          }
        }
      }
    }
  }
  
  return $array_dests; 
}
		
/**
 * Adds a META TAG to the process template queue.
 * 
 * @param $attributes
 *   Array of meta key keyword & key value. 
 *   If key keyword is one of "http-equiv, name, property"
 *   the Meta is updated in case of 2 calls.
 * @param $content
 *   Content of the meta tag.
 *   
 * @return
 * 	Return an array of meta.
 */
function wallytoolbox_add_meta($attributes = array(), $content = NULL) {

	static $wally_meta = array();
	$meta_key = NULL; 

	// Supported "Meta Keys" are : http-equiv, name, property. 
	foreach ($attributes as $attribute_name => $attribute_value) {
		switch (strtolower($attribute_name)) {
			case "name":
			case "http-equiv":
			case "property":
				$meta_key = strtolower($attribute_name)."_".$attribute_value;
				$wally_meta[$meta_key] = array( $attribute_name => $attribute_value, "content" => $content); 
				break;
			default:
				$wally_meta[] = array( $attribute_name => $attribute_value, "content" => $content); 
				break; 
		}
	}
	return $wally_meta;
}

/**
 * Generate HTML tag for meta tags.
 */
function wallytoolbox_get_meta() {

  if (!isset($wally_meta)) {
    $wally_meta = wallytoolbox_add_meta(NULL, NULL);
  }

  if (empty($wally_meta)) {
    return '';
  }

  $output = '';
  
  foreach ($wally_meta as $meta_k => $meta) {
    if (!$meta) {
      continue;
    }
    $output .= "<meta ";
		foreach($meta as $data_k => $data_v) {
			$output .= " ".$data_k."=\"".$data_v."\"";
		}
    $output .= " />\n";
  }
  
  return $output;
}

/*
 * Hook preprocess for meta tags.
 */
function wallytoolbox_preprocess_page(&$variables) {
  $variables['meta'] = wallytoolbox_get_meta();	
}

/**
 * @} End of "defgroup wallytoolbox".
 */
