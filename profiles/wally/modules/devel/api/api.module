<?php

/**
 * @file
 * Generates and displays API documentation pages.
 *
 * This is an implementation of a subset of the Doxygen documentation generator
 * specification, tuned to produce output that best benefits the Drupal code
 * base. It is designed to assume the code it documents follows Drupal coding
 * conventions, and supports documentation blocks in formats described on
 * http://drupal.org/node/1354
 */

/**
 * Regular expression for matching file names.
 */
define('API_RE_FILENAME', '([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)+)');

/**
 * Regular expression for matching PHP functions.
 *
 * Taken from Drupal 7's DRUPAL_PHP_FUNCTION_PATTERN.
 */
define('API_RE_PHP_FUNCTION', '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*');

/**
 * Regular expression for matching PHP functions and methods in text.
 *
 * These are patterns like ClassName::methodName(), or just function_name().
 */
define('API_RE_PHP_FUNCTION_IN_TEXT', '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff:]*');

/**
 * Regular expression for matching hook names.
 *
 * Since the actual PHP function name already has a prefix, these can
 * technically start with a number, although it's unlikely.
 */
define('API_RE_HOOK_NAME', '[a-zA-Z0-9_\x7f-\xff]+');

/**
 * Regular expression for matching class names in text.
 *
 * Although class names can technically be just like function names, we
 * only want to match class names if they include a capital letter, so as
 * not to be too overly aggressive.
 */
define('API_RE_CLASS_NAME_TEXT', '[a-zA-Z0-9_\x7f-\xff]*[A-Z][a-zA-Z0-9_\x7f-\xff]*');

/**
 * Regular expression for starting inline \@tags.
 */
define('API_RE_TAG_START', '(?<!\\\)@');

/**
 * File path separator.
 */
define('API_FILEPATH_SEPARATOR', '/');

/**
 * File path separator replacement.
 */
define('API_FILEPATH_SEPARATOR_REPLACEMENT', '!');

/**
 * File path separator replacement for API v 1.3.
 */
define('API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT', '--');

/**
 * Implements hook_help().
 */
function api_help($path, $arg) {
  switch ($path) {
    case 'admin/help#api':
      return t('
<p>This is an implementation of a subset of the Doxygen documentation generator specification, tuned to produce output that best benefits the Drupal code base. It is designed to assume the code it documents follows Drupal coding conventions, and supports documentation blocks in formats described on !doxygen_link.</p>

<h3>Set up</h3>

<p>Visit the !api_settings_page to configure the module. You must have the relevant Drupal code base on the same machine as the site hosting the API module. Follow the descriptions in the \'Branches to index\' section to set up the code base for indexing.</p>

<p>Indexing of PHP functions is also supported. If the site has internet access, then the default settings for the \'PHP Manual\' section should work fine. For local development environments that have a PHP manual installed, you can edit the paths to point to the appropriate locations.</p>

<p>The module indexes code branches during cron runs, so make sure the site has cron functionality set up properly.</p>
', array('!api_settings_page' => l(t('API settings page'), 'admin/settings/api'), '!doxygen_link' => l('http://drupal.org/node/1354', 'http://drupal.org/node/1354')));
  }
}

/**
 * Returns a list of all defined branches.
 *
 * @param $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return
 *   Array of branch objects, in order by branch weight.
 */
function api_get_branches($_reset = FALSE) {
  static $branches;

  if (!isset($branches) || $_reset) {
    $result = db_query("SELECT branch_id, project, project_title, branch_name, title, type, data, status, weight FROM {api_branch} ORDER BY weight");
    $branches = array();
    while ($branch = db_fetch_object($result)) {
      drupal_unpack($branch);
      $branches[$branch->branch_id] = $branch;
    }
  }

  return $branches;
}

/**
 * Returns a branch, given a branch ID number.
 *
 * @param $id
 *   Branch ID number.
 *
 * @return
 *   Branch object for the given branch ID. If $id is not set, the default
 *   branch is returned. If the requested branch does not exist, NULL.
 */
function api_get_branch_by_id($id = NULL) {
  $branches = api_get_branches();
  if (!isset($id)) {
    $id = variable_get('api_default_branch', NULL);
  }
  if (isset($branches[$id])) {
    return $branches[$id];
  }

  return NULL;
}

/**
 * Returns the list of currently-used branch names across all projects.
 *
 * @param $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return
 *   Array of branch names in use.
 */
function api_get_branch_names($_reset = FALSE) {
  static $branch_names;

  if (!isset($branch_names) || $_reset) {
    $result = db_query("SELECT DISTINCT branch_name FROM {api_branch} WHERE status = 1");
    $branch_names = array();
    while ($branch = db_fetch_object($result)) {
      $branch_names[$branch->branch_name] = $branch->branch_name;
    }
  }

  return $branch_names;
}

/**
 * Implements hook_menu().
 */
function api_menu() {
  $items = array();
  $branches = api_get_branches();
  if (count($branches)) {
    $default_branch = $branches[variable_get('api_default_branch', NULL)];
    $projects = array();
    // We need a default branch for each project. If a project has a branch_name
    // matching $default_branch, use that. Otherwise, use the max. This assumes
    // branch names like '5' and '6'.
    foreach ($branches as $branch) {
      if ($branch->status) {
        if (!isset($projects[$branch->project])) {
          $projects[$branch->project] = array(
            'max branch' => $branch->branch_name,
            'use branch' => NULL,
          );
        }
        else {
          $projects[$branch->project]['max branch'] = max($projects[$branch->project]['max branch'], $branch->branch_name);
        }
        if ($branch->branch_name === $default_branch->branch_name) {
          $projects[$branch->project]['use branch'] = $branch->branch_name;
        }
      }
    }
    foreach (array_keys($projects) as $project) {
      if (is_null($projects[$project]['use branch'])) {
        $projects[$project]['use branch'] = $projects[$project]['max branch'];
      }
    }

    // Part 1: No object, Default branch
    $items['api/search'] = array(
      'title' => 'API Search',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('api_search_form', $default_branch),
      'access arguments' => array('access API reference'),
      'type' => MENU_CALLBACK,
    );
    $items['apis'] = array(
      'title' => 'API search',
      'page callback' => 'api_search_redirect',
      'access arguments' => array('access API reference'),
      'type' => MENU_CALLBACK,
      'file' => 'api.pages.inc',
    );
  }

  // Admin
  $items['admin/settings/api'] = array(
    'title' => 'API reference',
    'description' => 'Configure branches for documentation.',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_page_admin_overview',
    'file' => 'api.admin.inc',
  );
  $items['admin/settings/api/branches'] = array(
    'title' => 'Branches',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/settings/api/branches/list'] = array(
    'title' => 'List',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
  $items['admin/settings/api/branches/new'] = array(
    'title' => 'New branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_new_branch_page',
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/settings/api/branches/reset_queue'] = array(
    'title' => 'Reset parse queue',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_reset_queue_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/settings/api/branches/new/%'] = array(
    'title' => 'New branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/settings/api/branches/%'] = array(
    'title' => 'Edit branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_edit_form', 4),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/settings/api/reparse/%'] = array(
    'title' => 'Reparse branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_reparse',
    'page arguments' => array( 4),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/settings/api/branches/%/delete'] = array(
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_delete_form', 4),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  if (module_exists('comment')) {
    $items['admin/settings/api/comments'] = array(
      'title' => 'Comments',
      'access arguments' => array('administer API reference'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('api_comments_settings_form'),
      'file' => 'api.admin.inc',
    );
  }

  // OpenSearch metadata callback.
  $items['api/opensearch/%'] = array(
    'page callback' => 'api_opensearch',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // OpenSearch suggestions callback.
  $items['api/suggest/%/%menu_tail'] = array(
    'page callback' => 'api_suggest',
    'page arguments' => array(2, 3),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Autocomplete callback.
  // This returns ALL possibilities for a search term.
  $items['api/autocomplete/%'] = array(
    'page callback' => 'api_autocomplete',
    'page arguments' => array(2, TRUE),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
  );

  // Function dumps for IDEs and code editors.
  $items['api/function_dump/%'] = array(
    'page callback' => 'api_page_function_dump',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  foreach (api_get_branches() as $branch) {
    if ($branch->status) {
      $items['api/search/'. $branch->branch_name .'/%menu_tail'] = array(
        'title' => $branch->branch_name,
        'page callback' => 'api_search_listing',
        'page arguments' => array($branch->branch_name, 3),
        'access arguments' => array('access API reference'),
        'type' => MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
    }
  }

  // Listings

  // Projects
  $items['api/projects'] = array(
    'title' => 'Projects',
    'page callback' => 'api_page_projects',
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Files
  $items['api/%/%api_filename'] = array(
    'title' => 'File',
    'load arguments' => array(1, 3), // project, branch
    'page callback' => 'api_page_file',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%api_filename/theme_invokes'] = array(
    'title' => 'File',
    'load arguments' => array(1, 4), // project, branch
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(2, 'theme_invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Items
  $items['api/%/%/function/%api_item'] = array(
    'title' => 'Function',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/%/function/calls/%api_item'] = array(
    'title' => 'Function calls',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'calls'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/implementations/%api_item'] = array(
    'title' => 'Function implementations',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'implementations'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/references/%api_item'] = array(
    'title' => 'Function references',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'references'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/invokes/%api_item'] = array(
    'title' => 'Hook invocations',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/theme_invokes/%api_item'] = array(
    'title' => 'Theme invokes',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'theme_invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/%/constant/%api_item'] = array(
    'title' => 'Constant',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'constant'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/global/%api_item'] = array(
    'title' => 'Global',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'global'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/property/%api_item'] = array(
    'title' => 'Property',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'property'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/class/%api_item'] = array(
    'title' => 'Class',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/interface/%api_item'] = array(
    'title' => 'Interface',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/group/%api_item'] = array(
    'title' => 'Group',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_group',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  foreach ($branches as $branch) {
    if ($branch->status) {
      $is_default = ($branch->branch_name === $projects[$branch->project]['use branch']);

      // Main branch page
      if ($is_default) {
        $items['api/' . $branch->project] = array(
          'title' => 'API reference',
          'page callback' => 'api_page_branch',
          'page arguments' => array($branch),
          'access arguments' => array('access API reference'),
          'type' => $branch->branch_id === $default_branch->branch_id ? MENU_NORMAL_ITEM : MENU_CALLBACK,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_branch',
        'page arguments' => array($branch),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );

      // Listings
      if ($is_default) {
        $items['api/' . $branch->project . '/functions'] = array(
          'title' => 'Functions',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'function'),
          'type' => MENU_CALLBACK,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/functions/'. $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'function'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/constants'] = array(
          'title' => 'Constants',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'constant'),
          'type' => MENU_CALLBACK,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/constants/'. $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'constant'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/globals'] = array(
          'title' => 'Globals',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'global'),
          'type' => MENU_CALLBACK,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/globals/'. $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'global'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/files'] = array(
          'title' => 'Files',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'file'),
          'type' => MENU_CALLBACK,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/files/'. $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'file'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/classes'] = array(
          'title' => 'Classes and interfaces',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'class'),
          'type' => MENU_CALLBACK,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/classes/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'class'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/groups'] = array(
          'title' => 'Topics',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'group'),
          'type' => MENU_CALLBACK,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/groups/'. $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'group'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
    }
  }

  // Redirect 1.0 file links.
  $items['api/file/%menu_tail'] = array(
    'page callback' => 'api_file_redirect',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'file' => 'legacy.inc',
  );

  // Redirect 1.1 links.
  // Objects
  $items['api/function/%api_legacy_1_2_object'] =
  $items['api/function/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('function', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constant/%api_legacy_1_2_object'] =
  $items['api/constant/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('constant', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/global/%api_legacy_1_2_object'] =
  $items['api/global/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('global', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/group/%api_legacy_1_2_object'] =
  $items['api/group/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('group', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // Default listings
  $items['api/functions'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/functions'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/files'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/files'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constants'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/constants'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/globals'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/globals'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/groups'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/groups'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // Branch listings
  $items['api/functions/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('functions'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/files/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('files'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constants/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('constants'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/globals/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('globals'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/groups/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('groups'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/%api_legacy_1_2_listing'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Finds objects for old URLs and returns the new URL.
 *
 * @param $object_name
 *   Name of the object to find the URL of.
 * @param $object_type
 *   Type of object ('function', 'constant', etc.).
 * @param $branch_name
 *   Name of the branch to find the object in (across projects).
 *
 * @return
 *   First matching URL for this combination of object name, type, and branch
 *   name, or NULL if none is found.
 */
function api_legacy_1_2_object_load($object_name, $object_type, $branch_name) {
  foreach (api_get_branches_by_name($branch_name) as $branch) {
    $object = api_object_load($object_name, $branch, $object_type);
    if (isset($object)) {
      return api_url($object);
    }
  }
}

/**
 * Returns the current path to listing pages accessed with old URLs.
 *
 * @param $branch_name
 *   Name of the branch to redirect.
 * @param $type
 *   Type of listing page ('functions', etc.), or NULL for the home page.
 *
 * @return
 *   URL to redirect this listing to, in the default project.
 */
function api_legacy_1_2_listing_load($branch_name, $type = NULL) {
  $branch = api_get_branch_by_id();
  if (empty($branch_name)) {
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      $branch_name = '';
    }
  }
  if (isset($type)) {
    return 'api/' . $branch->project . '/' . $type . '/' . $branch_name;
  }
  else {
    return 'api/' . $branch->project . '/' . $branch_name;
  }
}

/**
 * Finds all branches matching a branch name, across projects.
 *
 * @param $branch_name
 *   Branch name to match. If empty, defaults to the default branch.
 *
 * @return
 *   Array of all branch objects with this name.
 */
function api_get_branches_by_name($branch_name) {
  $return = array();
  if (empty($branch_name)) {
    $branch = api_get_branch_by_id();
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      return array();
    }
  }

  foreach (api_get_branches() as $branch) {
    if ($branch->branch_name === $branch_name) {
      $return[] = $branch;
    }
  }

  return $return;
}

/**
 * Loads a branch, given a project and branch name.
 *
 * @param $project
 *   The project name matching {api_branch}.project.
 * @param $branch_name
 *   The branch name matching {api_branch}.branch_name. If not set, uses the
 *   default branch name.
 *
 * @return
 *   Object representing the branch, or NULL if there is no match.
 */
function api_get_branch_by_name($project, $branch_name) {
  if (empty($branch_name)) {
    $branch = api_get_branch_by_id();
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      $branch_name = '';
    }
  }

  foreach (api_get_branches() as $branch) {
    if ($branch->project === $project && $branch->branch_name === $branch_name) {
      return $branch;
    }
  }

  return NULL;
}

/**
 * Loads an API object for the menu router.
 *
 * Menu object load callback for %api_item in menu paths.
 *
 * @param $object_name
 *   The object name matching {api_documentation}.object_name.
 * @param $project
 *   The project name matching {api_branch}.project.
 * @param $branch_name
 *   The branch name matching {api_branch}.branch_name.
 * @param $file_name
 *   The name of the file the object is in, with API_FILEPATH_SEPARATOR for path
 *   separators. We convert all API_FILEPATH_SEPARATOR_REPLACEMENTs back to
 *   API_FILEPATH_SEPARATORs to maintain the original file path information.
 *   (When a URL is created for a documentation object, all
 *   API_FILEPATH_SEPARATORs in the original file path are replaced with
 *   API_FILEPATH_SEPARATOR_REPLACEMENTs so that API_FILEPATH_SEPARATORs won't
 *   be interpreted as part the of URL.
 * @param $type
 *   API item type; one of function, constant, global, property, class,
 *   interface, or group.
 *
 * @return
 *   Loaded documentation object, or FALSE if not found (returning FALSE will
 *   cause the Drupal menu system to recognize it's a 404 error).
 */
function api_item_load($object_name, $project, $branch_name, $file_name, $type) {
  // Check type
  if (!in_array($type, array('function', 'constant', 'global', 'property', 'class', 'interface', 'group'))) {
    return FALSE;
  }

  // Load branch
  $branch = api_get_branch_by_name($project, $branch_name);
  if (is_null($branch)) {
    return FALSE;
  }

  // Load object
  $back_to_orig_filename = str_replace(API_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name);
  $doc_object = api_object_load($object_name, $branch, $type, $back_to_orig_filename);

  if (empty($doc_object) && (strpos($file_name, API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) !== FALSE)) {
    // May be an API 1.3 style path. See if we can load a valid object with the
    // old replacement pattern.
    $doc_object = api_object_load($object_name, $branch, $type, str_replace(API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name) );
    // If we could, redirect to the current URL.
    if (!empty($doc_object)) {
      drupal_goto(api_url($doc_object));
    }
  }

  if (empty($doc_object)) {
    return FALSE;
  }

  return $doc_object;
}

/**
 * Implements hook_cron_queue_info().
 */
function api_cron_queue_info() {
  return array(
    'api_parse' => array(
      'worker callback' => 'api_queue_parse_file',
      'time' => 15,
    ),
    'api_delete' => array(
      'worker callback' => 'api_queue_file_delete',
      'time' => 15,
    ),
  );
}

/**
 * Loads an API file object.
 *
 * Menu object load callback for %api_filename in menu paths.
 *
 * API v 1.3 replaced all '/'s in the file path with '--' for the URL generated
 * for the file. We need to handle a URL with '--' (=
 * API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) and redirected it to the current,
 * correct URL.  We now convert all '/'s (= API_FILEPATH_SEPARATOR) to
 * API_FILEPATH_SEPARATOR_REPLACEMENT when a URL is created for a documentatio
 * object. Here we need to go back to the original filename and path.
 *
 * @param $file_name
 *   Name of the file to load.
 * @param $project
 *   Name of the project the file is in.
 * @param $branch_name
 *   Name of the branch the file is in.
 *
 * @return
 *   Loaded documentation object, or FALSE if not found (returning FALSE will
 *   cause the Drupal menu system to recognize it's a 404 error).
 */
function api_filename_load($file_name, $project, $branch_name) {
  $branch = api_get_branch_by_name($project, $branch_name);
  if (is_null($branch)) {
    return FALSE;
  }

  $doc_object = api_object_load(str_replace(API_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name), $branch, 'file');

  if (empty($doc_object) && (strpos($file_name, API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) !== FALSE)) {
    // May be an API 1.3 style path. See if we can load a valid object with the
    // old replacement pattern.
    $doc_object = api_object_load(str_replace(API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name), $branch, 'file');
    // If we could, redirect to the current URL.
    if (!empty($doc_object)) {
      drupal_goto(api_url($doc_object));
    }
  }

  if (empty($doc_object)) {
    return FALSE;
  }

  return $doc_object;
}

/**
 * Loads a documentation object.
 *
 * @param $object_name_or_did
 *   The string object name or documentation ID to load.
 * @param $branch
 *   Branch object.
 * @param $object_type
 *   A string type, or array of strings: class, interface, function, etc.
 * @param $file_name
 *   Name of the file the object is in (if needed).
 *
 * @return
 *   Object with information about the matching documentation, or NULL if it
 *   does not exist.
 */
function api_object_load($object_name_or_did, $branch, $object_type, $file_name = NULL) {
  static $cache;

  if (!is_array($object_type)) {
    $object_type = array($object_type);
  }
  $key = $object_name_or_did . ':' . implode('-', $object_type) . ':' . $branch->branch_id . ':' . $file_name;

  // See if we have this cached.
  if (isset($cache[$key])) {
    return $cache[$key];
  }

  // We don't have a cached value. Prepare the query.
  $tables = array('{api_documentation} ad', 'LEFT JOIN {api_overrides} ao ON ao.did = ad.did');
  $fields = array('ad.did', 'ad.branch_id', 'ad.object_name', 'ad.object_type', 'ad.title', 'ad.file_name', 'ad.summary', 'ad.documentation', 'ad.code', 'ad.start_line', 'ad.see', 'ad.class_did', 'ad.var', 'ad.throws', 'ao.overrides_did', 'ao.root_did', 'ad.member_name', 'ao.documented_did');
  $where = "WHERE ad.object_type IN (" . db_placeholders($object_type, 'text') . ") AND ad.branch_id = %d";
  $arguments = $object_type;
  $arguments[] = $branch->branch_id;
  if (is_int($object_name_or_did)) {
    $where .= " AND ad.did = %d";
    $arguments[] = $object_name_or_did;
  }
  else {
    $where .= " AND ad.object_name = '%s'";
    $arguments[] = $object_name_or_did;
  }

  if (!is_null($file_name)) {
    $where .= " AND ad.file_name = '%s'";
    $arguments[] = $file_name;
  }

  if (in_array('function', $object_type)) {
    $tables[] = 'LEFT JOIN {api_function} af ON af.did = ad.did';
    $fields[] = 'af.signature, af.parameters, af.return_value';
  }
  elseif (in_array('file', $object_type)) {
    $tables[] = 'LEFT JOIN {api_file} af ON af.did = ad.did';
    $fields[] = 'af.modified, af.queued';
  }

  // Now build the object. Don't store a NULL or FALSE result in the cache in
  // case we need to try again with a different filename or other argument.
  $result_object =  db_fetch_object(db_query_range('SELECT '. implode(', ', $fields) .' FROM '. implode(' ', $tables) .' '. $where, $arguments, 0, 1));

  if (isset($result_object) && $result_object) {
    // Grab documentation from documented parent.
    if (!empty($result_object->documented_did) && $result_object->documented_did !== $result_object->did) {
      $documented_object = api_object_load((int) $result_object->documented_did, $branch, $object_type);
      if (isset($documented_object)) {
        foreach (array('documentation', 'parameters', 'return_value', 'see', 'throws', 'var') as $member) {
          $result_object->$member = $documented_object->$member;
        }
      }
    }
    // Store in the cache.
    $cache[$key] = $result_object;
    return $result_object;
  }

  return NULL;
}

/**
 * Implements hook_perm().
 */
function api_perm() {
  return array('access API reference', 'administer API reference');
}

/**
 * Implements hook_theme().
 */
function api_theme() {
  return array(
    'api_branch_table' => array(
      'arguments' => array('element' => NULL),
    ),
    'api_defined' => array(
      'arguments' => array(
        'branch' => NULL,
        'object' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-defined',
      'file' => 'api.pages.inc',
      'preprocess functions' => array('api_preprocess_api_defined'),
    ),
    'api_related_topics' => array(
      'arguments' => array(
        'topics' => array(),
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-related-topics',
    ),
    'api_functions' => array(
      'arguments' => array(
        'functions' => array(),
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-functions',
    ),
    'api_function_page' => array(
      'arguments' => array(
        'branch' => NULL,
        'object' => NULL,
        'signatures' => NULL,
        'documentation' => NULL,
        'parameters' => NULL,
        'return' => NULL,
        'related_topics' => NULL,
        'call_links' => array(),
        'code' => NULL,
        'see' => NULL,
        'throws' => NULL,
      ),
      'preprocess functions' => array('api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-function-page',
      'file' => 'api.pages.inc',
    ),
    'api_constant_page' => array(
      'arguments' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-constant-page',
      'file' => 'api.pages.inc',
    ),
    'api_global_page' => array(
      'arguments' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-global-page',
      'file' => 'api.pages.inc',
    ),
    'api_property_page' => array(
      'arguments' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
        'var' => NULL,
      ),
      'preprocess functions' => array('api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-property-page',
      'file' => 'api.pages.inc',
    ),
    'api_class_page' => array(
      'arguments' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'implements' => NULL,
        'hierarchy' => NULL,
        'objects' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-class-page',
      'file' => 'api.pages.inc',
    ),
    'api_file_page' => array(
      'arguments' => array(
        'object' => NULL,
        'documentation' => NULL,
        'objects' => NULL,
        'code' => NULL,
        'see' => NULL,
        'related_topics' => NULL,
        'defined' => '',
        'call_links' => array(),
      ),
      'preprocess functions' => array('api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-file-page',
      'file' => 'api.pages.inc',
    ),
    'api_group_page' => array(
      'arguments' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'objects' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-group-page',
      'file' => 'api.pages.inc',
    ),
    'api_branch_default_page' => array(
      'arguments' => array(
        'branch' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-branch-default-page'
    ),
    'api_function_reference_link' => array(
      'arguments' => array(
        'type' => '',
        'count' => 0,
        'function' => (object) array(),
      ),
      'file' => 'api.pages.inc',
    ),
  );
}

/**
 * Sets or returns the HTML page title.
 *
 * @param $title
 *   If provided, sets the page title to this string.
 *
 * @return
 *   The previously-set page title, or NULL if it has not been set during
 *   this page load.
 */
function api_set_html_page_title($title = NULL) {
  static $page_title = NULL;

  if (isset($title)) {
    $page_title = $title;
  }

  return $page_title;
}

/**
 * Preprocess pages: sets the page title if it's an API module page.
 */
function api_preprocess_page(&$variables) {
  $title = api_set_html_page_title();
  if ($title) {
    $variables['head_title'] = $title;
  }
}

/**
 * Implements hook_init().
 *
 * Adds CSS and JavaScript for the search auto-complete. Adds OpenSearch
 * autodiscovery links. Redirects nodes of type 'api' to the correct URL.
 */
function api_init() {
  drupal_add_css(drupal_get_path('module', 'api') . '/jquery-autocomplete/jquery.autocomplete.css');
  drupal_add_js(drupal_get_path('module', 'api') . '/jquery-autocomplete/jquery.autocomplete.js');
  drupal_add_css(drupal_get_path('module', 'api') . '/api.css');
  drupal_add_js(drupal_get_path('module', 'api') . '/api.js');
  $branch = api_get_active_branch();
  if (isset($branch)) {
    drupal_add_js(array('apiAutoCompletePath' => base_path() . variable_get('api_autocomplete_path_' . $branch->branch_name, 'api/autocomplete/' . $branch->branch_name)), 'setting');
  }

  // Add OpenSearch autodiscovery links.
  foreach (api_get_branch_names() as $branch_name) {
    $title = t('Drupal API @branch', array('@branch' => $branch_name));
    $url = url('api/opensearch/'. $branch_name, array('absolute' => TRUE));
    drupal_set_html_head('<link rel="search" type="application/opensearchdescription+xml" href="'. $url .'" title="'. $title .'" />');
  }

  // If we happen to be on an API node page, redirect.
  if (($node = menu_get_object()) && $node->type == 'api') {
    $documentation = db_fetch_object(db_query('SELECT branch_id, object_type, file_name, object_name FROM {api_documentation} WHERE did = %d', $node->nid));
    drupal_goto(api_url($documentation));
  }
}

/**
 * Implements hook_db_rewrite_sql().
 *
 * Excludes nodes of type 'api' from node queries.
 */
function api_db_rewrite_sql($query, $primary_table, $primary_field) {
  if ($primary_field == 'nid' && $primary_table == 'n') {
    return array('where' => "n.type <> 'api'");
  }
}

/**
 * Implements hook_block().
 */
function api_block($op, $delta = NULL, $edit = array()) {
  switch ($op) {
    case 'list':
      return array(
        'api-search' => array(
          'info' => t('API search'),
          'cache' => BLOCK_CACHE_PER_PAGE,
        ),
        'navigation' => array(
          'info' => t('API navigation'),
          'cache' => BLOCK_CACHE_PER_PAGE,
        ),
      );

    case 'view':
      $branch = api_get_active_branch();

      switch ($delta) {
        case 'api-search':
          if (user_access('access API reference') && !empty($branch)) {
            return array(
              'subject' => t('Search @branch', array('@branch' => $branch->branch_name)),
              'content' => drupal_get_form('api_search_form', $branch),
            );
          }
          return;

        case 'navigation':
          if (user_access('access API reference') && !empty($branch)) {
            $links = array();
            $links[] = l($branch->title, 'api/' . $branch->project . '/' . $branch->branch_name);
            $counts = api_listing_counts($branch);
            if ($counts['constants'] > 0) {
              $links[] = l(t('Constants'), 'api/' . $branch->project . '/constants/' . $branch->branch_name);
            }
            if ($counts['classes'] > 0) {
              $links[] = l(t('Classes'), 'api/' . $branch->project . '/classes/' . $branch->branch_name);
            }
            if ($counts['files'] > 0) {
              $links[] = l(t('Files'), 'api/' . $branch->project . '/files/' . $branch->branch_name);
            }
            if ($counts['functions'] > 0) {
              $links[] = l(t('Functions'), 'api/' . $branch->project . '/functions/' . $branch->branch_name);
            }
            if ($counts['globals'] > 0) {
              $links[] = l(t('Globals'), 'api/' . $branch->project . '/globals/' . $branch->branch_name);
            }
            if ($counts['groups'] > 0) {
              $links[] = l(t('Topics'), 'api/' . $branch->project . '/groups/' . $branch->branch_name);
            }

            return array(
              'subject' => t('API Navigation'),
              'content' => theme('item_list', $links),
            );
          }
          return;
      }
  }
}

/**
 * Calculates the counts of each type of listing for a branch.
 *
 * @param $branch
 *   Object representing the branch to count.
 *
 * @return
 *   Associative array where the keys are the type of listing ('functions',
 *   'classes', etc.) and the values are the count of how many there are in
 *   that listing for the given branch.
 */
function api_listing_counts($branch) {

  static $cached_counts = array();

  // Check the cache.
  $key = $branch->branch_name . $branch->branch_id;
  if (isset($cached_counts[$key])) {
    return $cached_counts[$key];
  }

  $return = array(
    'groups' => 0,
    'classes' => 0,
    'functions' => 0,
    'constants' => 0,
    'globals' => 0,
    'files' => 0,
  );

  // These queries mirror what is done in api_page_listing().
  $result = db_query("SELECT COUNT(*) as num FROM {api_documentation} WHERE branch_id = %d AND object_type = 'group' GROUP BY branch_id", $branch->branch_id);
  while ($obj = db_fetch_object($result)) {
    $return['groups'] = $obj->num;
    break;
  }

  $result = db_query("SELECT COUNT(*) as num FROM {api_documentation} WHERE branch_id = %d AND ( object_type = 'class' OR 'object_type' = 'interface') AND class_did = 0 GROUP BY branch_id", $branch->branch_id);
  while ($obj = db_fetch_object($result)) {
    $return['classes'] = $obj->num;
    break;
  }

  foreach (array('function', 'constant', 'global', 'file') as $type) {
    $result = db_query("SELECT COUNT(*) as num FROM {api_documentation} WHERE branch_id = %d AND object_type = '%s' AND class_did = 0 GROUP BY branch_id", $branch->branch_id, $type);
    while ($obj = db_fetch_object($result)) {
      $return[$type . 's'] = $obj->num;
      break;
    }
  }

  $cached_counts[$key] = $return;
  return $return;
}

/**
 * Implementation of hook_filter().
 */
function api_filter($op, $delta = 0, $format = -1, $text = '') {
  switch ($op) {
    case 'list':
      return array(0 => t('API filter'));

    case 'description':
      return t('Add links to API objects, like theme() or theme.inc.');

    case 'process':
      return api_filter_documentation($text, api_get_active_branch());

    default:
      return $text;
  }
}

/**
 * Constructs a link to an API object page.
 *
 * Construct a URL for an object, replacing any API_FILEPATH_SEPARATOR in a
 * file path with API_FILEPATH_SEPARATOR_REPLACEMENT.
 *
 * @param $object
 *   An API object with object_type, object_name, and file_name properties.
 * @param $file
 *   TRUE links to the objectâ€™s containing file, FALSE links to the object
 *   itself.
 *
 * @return
 *   A URL string, or an empty string if there was a problem.
 */
function api_url($object, $file = FALSE) {
  $branch = api_get_branch_by_id($object->branch_id);
  if (!$branch) {
    return '';
  }

  if ($file) {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->file_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $branch->branch_name;
  }
  elseif ($object->object_type === 'file') {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->object_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $branch->branch_name;
  }
  else {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->file_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $object->object_type . '/' . $object->object_name . '/' . $branch->branch_name;
  }
}

/**
 * Saves an API branch.
 *
 * @param $branch
 *   A branch object, with branch_name, title, and directories properties.
 */
function api_save_branch($branch) {
  $branch->data = serialize($branch->data);
  if (empty($branch->branch_id)) {
    drupal_write_record('api_branch', $branch);
    if (is_null(variable_get('api_default_branch', NULL))) {
      variable_set('api_default_branch', $branch->branch_id);
    }
  }
  else {
    drupal_write_record('api_branch', $branch, 'branch_id');
  }

  // Reweight all branches.
  api_get_branch_names(TRUE);
  $branches = api_get_branches(TRUE);
  usort($branches, 'api_branch_sort');
  $weight = 0;
  foreach ($branches as $branch) {
    $branch->weight = $weight;
    $weight += 1;
    drupal_write_record('api_branch', $branch, 'branch_id');
  }

  menu_rebuild();
}

/**
 * Callback for usort() within api_save_branch().
 *
 * Sorts branches by type, version number, and branch name.
 */
function api_branch_sort($a, $b) {
  // PHP type branches should come after file type branches.
  $result = strcmp($a->type, $b->type);
  if ($result != 0) {
    return $result;
  }
  // Sort by numeric version number next.
  $result = version_compare($a->branch_name, $b->branch_name);
  if ($result != 0) {
    return $result;
  }

  // If they are the same type and version_compare said they were the same,
  // then just do alphabetical.
  return strcasecmp($a->branch_name, $b->branch_name);
}

/**
 * Returns the currently active branch object.
 */
function api_get_active_branch() {
  static $branch;

  if (!isset($branch)) {
    $item = menu_get_item();
    $branches = api_get_branches();
    $branch_names = api_get_branch_names();
    $default_branch = variable_get('api_default_branch', NULL);
    if (isset($item['page_arguments'][0]->branch_id)) {
      $branch = $branches[$item['page_arguments'][0]->branch_id];
    }
    elseif (isset($item['page_arguments'][0]->branch_name)) {
      $branch = $item['page_arguments'][0];
    }
    elseif (strpos($item['path'], 'api/search') === 0 && isset($branch_names[$item['page_arguments'][0]])) {
      // Search page, use the default project if possible
      foreach ($branches as $possible_branch) {
        if ($possible_branch->project === $branches[$default_branch]->project && $possible_branch->branch_name === $item['page_arguments'][0]) {
          $branch = $possible_branch;
        }
      }
    }
    if (!isset($branch)) {
      if (!is_null($default_branch)) {
        $branch = $branches[$default_branch];
      }
      else {
        $branch = NULL;
      }
    }
  }

  return $branch;
}

/**
 * Form constructor for the API search form.
 *
 * @param $branch
 *   Object representing the branch to build the search form for.
 *
 * @see api_search_form_submit()
 */
function api_search_form($form_state, $branch) {
  $form = array();

  $form['#token'] = FALSE;
  $form['#attributes']['class'] = 'api-search-form';
  $form['#branch'] = $branch;

  $form['search'] = array(
    '#title' => t('Function, file, or topic'),
    '#type' => 'textfield',
    '#default_value' => '',
    '#required' => TRUE,
    '#attributes' => array('class' => 'api-search-keywords'),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );

  return $form;
}

/**
 * Form submission handler for api_search_form().
 */
function api_search_form_submit($form, &$form_state) {
  $form_state['redirect'] = 'api/search/'. $form['#branch']->branch_name .'/'. $form_state['values']['search'];
}

/**
 * Prepares a listing of documentation objects for a branch.
 *
 * @param $branch_name
 *   Name of the branch to list.
 * @param $page
 *   TRUE if this will be embedded in a page, and FALSE if it is an AHAH
 *   callback.
 *
 * @return
 *   JavaScript listing of all the objects in the branch.
 */
function api_autocomplete($branch_name, $page = TRUE) {
  $result = db_query("SELECT ad.title, ad.object_type FROM {api_documentation} ad INNER JOIN {api_branch} b ON ad.branch_id = b.branch_id WHERE b.branch_name = '%s' AND ad.object_type <> 'mainpage' ORDER BY LENGTH(ad.title), ad.title", $branch_name);
  $objects = array();
  while ($object = db_fetch_object($result)) {
    $objects[] = $object->title;
  }

  $objects = array_values(array_unique($objects));
  if ($page) {
    drupal_json($objects);
  }
  else {
    return drupal_to_js($objects);
  }
}

/**
 * Implements hook_cron().
 */
function api_cron() {
  include_once './'. drupal_get_path('module', 'api') .'/parser.inc';
  api_update_all_branches();
}

/**
 * Turns function names into links in code.
 *
 * @param $code
 *   PHP code to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $class_did
 *   Documentation ID of the class the code is in (if any).
 *
 * @return
 *   Code with function names formatted as links.
 */
function api_link_code($code, $branch, $class_did = NULL) {
  return _api_link_documentation($code, $branch, $class_did, array('code hook name', 'code alter hook name', 'code theme hook name', 'code function', 'code member', 'code string'));
}

/**
 * Turns function names into links in documentation.
 *
 * @param $documentation
 *   Documentation to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @param $aggressive_classes
 *   Try linking every word with a capital letter to a class or interface, if
 *   TRUE.
 *
 * @return
 *   Documentation with function names formatted as links.
 */
function api_link_documentation($documentation, $branch, $class_did = NULL, $aggressive_classes = FALSE) {
  return _filter_url(api_filter_documentation($documentation, $branch, $class_did, $aggressive_classes), NULL);
}

/**
 * Turns function names into links for a text filter.
 *
 * This is the process callback for the API filter supplied by api_filter().
 * It turns function names into links on output, using the currently active
 * branch.
 *
 * @param $text
 *   Text to filter.
 * @param $branch
 *   Branch object to use for links.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @param $aggressive_classes
 *   Try linking every word with a capital letter to a class or interface, if
 *   TRUE.
 *
 * @return
 *   Text with function names turned into links.
 */
function api_filter_documentation($text, $branch, $class_did = NULL, $aggressive_classes = FALSE) {
  // Remove escaping from \@.
  $stages = array('tags', 'link', 'function', 'file', 'constant');
  if ($aggressive_classes) {
    $stages[] = 'class';
  }
  return preg_replace('!\\\@!', '@', _api_link_documentation($text, $branch, $class_did, $stages));
}

/**
 * Recursive internal callback for turning function names into links in code.
 *
 * @param $documentation
 *   PHP code to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @stages
 *   Array of stages to process.
 *
 * @return
 *   Code with function names formatted as links.
 *
 * @see api_link_code()
 * @see api_link_name()
 */
function _api_link_documentation($documentation, $branch, $class_did = NULL, $stages = array()) {

  $stage = array_shift($stages);

  $callback_match = 'api_link_name';
  $prepend = '';
  $append = '';
  $prepend_if_not_found = NULL;
  $use_php = TRUE;
  $type = '';
  $pattern = '';

  switch ($stage) {
    case 'tags':
      // Find HTML tags, not filtered.
      $callback_match = NULL;
      $pattern = '/(<[^>]+?'.'>)/';
      break;

    case 'link':
      // Find @link.
      $pattern = '/' . API_RE_TAG_START . 'link\s+(.*)\s+' . API_RE_TAG_START . 'endlink/U';
      $callback_match = 'api_link_link';
      break;

    case 'function':
      // Find function names, which are preceded by white space and followed by
      // '('.
      $append = '(';
      $pattern = '!(?<=^|\s)(' . API_RE_PHP_FUNCTION_IN_TEXT . ')\(!';
      $type = 'function';
      break;

    case 'code function':
      // Find function names in marked-up code.
      $pattern = '!<span class="php-function-or-constant">(' . API_RE_PHP_FUNCTION . ')</span>!';
      $prepend = '<span class="php-function-or-constant">';
      $append = '</span>';
      break;

    case 'code string':
      // Find potential function names (callback strings) in marked-up code.
      // These are all strings that are legal function names, where the function
      // name is put into something like a hook_menu() page callback as a
      // string.
      $pattern = '!<span class="php-string">\'(' . API_RE_PHP_FUNCTION . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'function';
      break;

    case 'code hook name':
      // Find potential hook names in marked-up code. These are strings that
      // are legal function names, which were found in parsing to be inside
      // module_implements() and related functions.
      $pattern = '!<span class="php-string potential-hook">\'(' . API_RE_HOOK_NAME . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'hook';
      break;

    case 'code alter hook name':
      // Works like 'code hook name' above, but for alter hooks.
      $pattern = '!<span class="php-string potential-alter">\'(' . API_RE_HOOK_NAME . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'alter hook';
      break;

    case 'code theme hook name':
      // Works like 'code hook name' above, but for theme hooks.
      $pattern = '!<span class="php-string potential-theme">\'(' . API_RE_PHP_FUNCTION . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'theme';
      break;

    case 'code member':
      // Works like 'code hook name' above, but for class members.
      $callback_match = 'api_link_member_name';
      $pattern = '!(<span class="php-function-or-constant [^"]+ member-of-[^"]+">' . API_RE_PHP_FUNCTION . '</span>)!';
      break;

    case 'file':
      // Find file names, which are an arbitrary number of strings joined with
      // '.'
      $pattern = '%(?<=^|\s|\()'. API_RE_FILENAME .'(?=$|\s|[.,:;?!\)])%';
      $type = 'file';
      break;

    case 'constant':
      // Find constants, UPPERCASE_LETTERS_WITH_UNDERSCORES.
      $pattern = '/\b([A-Z_]+)\b/';
      $type = 'constant';
      break;

    case 'class':
      // Find class names, which have a capital letter.
      $pattern = '/\b(' . API_RE_CLASS_NAME_TEXT . ')\b/';
      $type = 'class';
      break;
  }

  if (count($stages) > 0) {
    $callback = '_api_link_documentation';
  }
  else {
    $callback = NULL;
  }

  return api_split($pattern, $documentation, $callback_match, array($branch, $prepend, $append, $class_did, NULL, NULL, $use_php, $prepend_if_not_found, NULL, $type), $callback, array($branch, $class_did, $stages));
}

/**
 * Splits a string using a regular expression and processes using callbacks.
 *
 * @param $pattern
 *   The regular expression to match for splitting.
 * @param $subject
 *   The string to process.
 * @param $callback_match
 *   Function name to be called for text which matches $pattern. The first
 *   argument will be the parenthesized expression in the pattern. Should
 *   return a string. NULL to pass the text through unchanged.
 * @param $callback_match_arguments
 *   An array of additional parameters for $callback_match.
 * @param $callback
 *   Function name to be called for text which does not match $pattern. The
 *   first argument will be the text. Should return a string. NULL to pass the
 *   text through unchanged.
 * @param $callback_arguments
 *   An array of additional parameters for $callback.
 *
 * @return
 *   The original string, with both matched and unmatched portions filtered by
 *   the appropriate callbacks.
 */
function api_split($pattern, $subject, $callback_match = NULL, $callback_match_arguments = array(), $callback = NULL, $callback_arguments = array()) {
  $return = '';
  $matched = FALSE;
  foreach (preg_split($pattern . 'sm', $subject, -1, PREG_SPLIT_DELIM_CAPTURE) as $part) {
    if ($matched) {
      if (is_null($callback_match)) {
        $return .= $part;
      }
      else {
        $return .= call_user_func_array($callback_match, array_merge(array($part), $callback_match_arguments));
      }
    }
    else {
      if (is_null($callback)) {
        $return .= $part;
      }
      else {
        $return .= call_user_func_array($callback, array_merge(array($part), $callback_arguments));
      }
    }
    $matched = !$matched;
  }
  return $return;
}

/**
 * Links an object name to its documentation.
 *
 * @param $name
 *   Object name to link to.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Text to prepend on the link.
 * @param $append
 *   Text to append on the link.
 * @param $class_did
 *   (unused) Documentation ID of the class this is part of (if any).
 * @param $text
 *   Link text. If omitted, uses $name.
 * @param $is_link
 *   TRUE if this was inside a @link.
 * @param $use_php
 *   TRUE if links to PHP functions should be made; FALSE if only Drupal
 *   objects.
 * @param $prepend_if_not_found
 *   Text to prepend if object is not found (defaults to $prepend).
 * @param $append_if_not_found
 *   Text to append if object is not found (defaults to $append).
 * @param $type
 *   The type of information $name represents. Possible values:
 *   - '': (default) $name is a normal object name.
 *   - 'hook': $name is a hook name.
 *   - 'alter hook': $name is an alter hook name.
 *   - 'theme': $name is a theme hook name.
 *   - 'function': $name is specifically a function ('file', 'constant', etc.
 *     also are supported).
 *
 * @return
 *   The text as a link to the object page.
 */
function api_link_name($name, $branch, $prepend = '', $append = '', $class_did = NULL, $text = NULL, $is_link = FALSE, $use_php = TRUE, $prepend_if_not_found = NULL, $append_if_not_found = NULL, $type = '') {

  if (is_null($text)) {
    $text = $name;
  }

  $query = "SELECT ad.did, ad.branch_id, ad.object_name, ad.title, ad.object_type, ad.summary, ad.file_name, ad.object_name as match_name FROM {api_documentation} ad WHERE ad.branch_id = %d AND ad.object_name = '%s'";

  // See if this is a link to a group/topic.
  if ($is_link) {
    $result = db_query($query . " AND ad.object_type = 'group'", $branch->branch_id, $name);
    while ($object = db_fetch_object($result)) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($object->match_name == $name) {
        // Note: Use html = TRUE here because the @link stuff was check_plained
        // during parsing. If we run it through check_plain() again, we get
        // double encoding of entities.
        return $prepend . l($text, api_url($object), array('attributes' => array('title' => api_entity_decode($object->summary), 'class' => 'local'), 'html' => TRUE)) . $append;
      }
    }

    // See if it could be a file name being linked.
    $tmpquery = "SELECT ad.did, ad.branch_id, ad.object_name, ad.title, ad.object_type, ad.summary, ad.file_name, af.basename as match_name FROM {api_documentation} ad INNER JOIN {api_file} af ON ad.did = af.did WHERE ad.branch_id = %d AND af.basename = '%s' AND ad.object_type = 'file'";
    $result = db_query($tmpquery, $branch->branch_id, $name);
    while ($object = db_fetch_object($result)) {
      if ($object->match_name == $name) {
        return $prepend . l($text, api_url($object), array('attributes' => array('title' => api_entity_decode($object->summary), 'class' => 'local'), 'html' => TRUE)) . $append;
      }
    }
  }

  // Figure out what potential names we should match on.

  $potential_names = array($name);
  if ($type == 'hook') {
    $potential_names = array(
      'hook_' . $name,
      'hook_field_' . $name,
      'field_default_' . $name,
      'hook_user_' . $name,
    );
    $query .= " AND ad.object_type = 'function'";
  }
  elseif ($type == 'alter hook') {
    $potential_names = array('hook_' . $name . '_alter');
    $query .= " AND ad.object_type = 'function'";
  }
  elseif ($type == 'theme') {
    $potential_names = array();
    // Potential matches are the whole theme call, or with stripped off pieces
    // separated by __. And we look for template files preferably over
    // functions.
    $hook_elements = explode('__', $name);
    while (count($hook_elements) > 0) {
      $hook = implode('__', $hook_elements);
      $potential_names[] = str_replace('_', '-', $hook) . '.tpl.php';
      $potential_names[] = 'theme_' . $hook;
      array_pop($hook_elements);
    }
    // Because this needs to match theme files, change the query to match on
    // object title (which is the file base name).
    $query = "SELECT ad.did, ad.branch_id, ad.object_name, ad.title, ad.object_type, ad.summary, ad.file_name, ad.title as match_name FROM {api_documentation} ad WHERE ad.branch_id = %d AND ad.title = '%s' AND (ad.object_type = 'file' OR ad.object_type = 'function')";
  }
  elseif ($type == 'function') {
    $query .= " AND ad.object_type = 'function'";
  }
  elseif ($type == 'file') {
    // Because this needs to match files, change the query to match on
    // basename field in {api_files}.
    $query = "SELECT ad.did, ad.branch_id, ad.object_name, ad.title, ad.object_type, ad.summary, ad.file_name, af.basename as match_name FROM {api_documentation} ad INNER JOIN {api_file} af ON ad.did = af.did WHERE ad.branch_id = %d AND af.basename = '%s' AND ad.object_type = 'file'";
  }
  elseif ($type == 'constant') {
    $query .= " AND ad.object_type = 'constant'";
  }
  elseif ($type == 'class') {
    $query .= " AND (ad.object_type = 'class' OR ad.object_type = 'interface')";
  }

  foreach ($potential_names as $possible_name) {
    $url = NULL;
    $options = array();
    // See if there are any matches for this name.
    $result = db_query($query, $branch->branch_id, $possible_name);
    while ($object = db_fetch_object($result)) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($object->match_name != $possible_name) {
        continue;
      }
      if (isset($url)) {
        // This is the second match, so make this a search.
        $url = 'api/search/' . $branch->branch_name . '/' . $possible_name;
        $options = array(
          'attributes' => array(
            'title' => t('Multiple implementations exist.'),
            'class' => 'local',
          ),
        );
        break;
      }
      else {
        $url = api_url($object);
        $options = array(
          'attributes' => array(
            'title' => api_entity_decode($object->summary),
            'class' => 'local',
          ),
        );
      }
    }

    // See if we found a match.
    if (isset($url)) {
      return $prepend . l($text, $url, $options) . $append;
    }
  }

  // If we get here, there wasn't a match. Try PHP functions.
  if ($use_php) {
    $result = db_query("SELECT d.object_name, d.summary, b.data FROM {api_documentation} d INNER JOIN {api_branch} b ON b.branch_id = d.branch_id AND b.type = 'php' WHERE d.object_type = 'function' AND d.object_name = '%s'", $name);
    while ($info = db_fetch_object($result)) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($info->object_name != $name) {
        continue;
      }

      $data = unserialize($info->data);
      $link = strtr($data['path'], array('!function' => $name));
      return $prepend . l($text, $link, array('attributes' => array('title' => api_entity_decode($info->summary), 'class' => 'php-manual'))) . $append;
    }
  }

  // If we get here, there still wasn't a match, so return non-linked text.
  if (isset($prepend_if_not_found)) {
    $prepend = $prepend_if_not_found;
  }
  if (isset($append_if_not_found)) {
    $append = $append_if_not_found;
  }

  return $prepend . $text . $append;
}

/**
 * Links text to an appropriate class member variable, constant, or function.
 *
 * @param $text
 *   Text matched by the regular expression.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Unused.
 * @param $append
 *   Unused.
 * @param $class_did
 *   Documentation ID of the class this is part of (if any).
 */
function api_link_member_name($text, $branch, $prepend = '', $append = '', $class_did = NULL) {

  // The pattern matched to get here contains the entire span with all of its
  // classes. Parse it out.
  $matches = array();
  preg_match('!<span class="php-function-or-constant ([^"]+) member-of-([^"]+)">(' . API_RE_PHP_FUNCTION . ')</span>!', $text, $matches);
  $name = $matches[3];
  $member_type = $matches[2];
  $object_type = $matches[1];

  if ($object_type == 'function') {
    $object_type_where = " AND ad.object_type = 'function'";
  }
  else {
    $object_type_where = " AND ad.object_type <> 'function'";
  }
  $prepend = '<span class="php-function-or-constant">';
  $append = '</span>';

  // Figure out what class we're looking for a member of, and build a query.
  // $member_type is one of: parent, self, variable, or class-NAME.
  $result = NULL;

  if ($member_type == 'parent') {
    // We're looking for a member of the parent class. Find the class doc ID.
    if ($item = db_fetch_object(db_query("SELECT ad.did FROM {api_reference_storage} ars INNER JOIN {api_documentation} ad ON ad.did = ars.to_did WHERE ars.from_did = %d AND ars.object_type = 'class'", $class_did))) {
      $class_did = $item->did;
      $member_type = 'self';
    }
    else {
      // There is no parent class recorded (probably a built-in PHP class).
      $member_type = 'none';
    }
  }
  elseif (strpos($member_type, 'class-') === 0) {
    // We're looking for a specific class. Find the class doc ID.
    $class_name = substr($member_type, 6);
    if ($item = db_fetch_object(db_query("SELECT ad.did FROM {api_documentation} ad WHERE ad.object_type = 'class' AND ad.branch_id = %d AND ad.object_name = '%s'", $branch->branch_id, $class_name))) {
      $class_did = $item->did;
      $member_type = 'self';
    }
    else {
      // Class name doesn't exist (probably a built-in PHP class).
      $member_type = 'none';
    }
  }

  if ($member_type == 'self') {
    // Looking for a member of a particular class. Note that we use the
    // {api_members} table here, since it includes members inherited from
    // parent classes.
    $result = db_query("SELECT ad.branch_id, ad.title, ad.object_name, ad.summary, ad.object_type, ad.file_name, ad.did, ad.member_name FROM {api_members} am INNER JOIN {api_documentation} ad ON am.did = ad.did WHERE am.class_did = %d AND ad.member_name = '%s'" . $object_type_where, $class_did, $name);
  }
  elseif ($member_type == 'variable') {
    // This was some kind of a variable like $foo->member(). So match any member
    // of any class.
    $result = db_query("SELECT ad.branch_id, ad.title, ad.object_name, ad.summary, ad.object_type, ad.file_name, ad.did, ad.member_name FROM {api_documentation} ad WHERE ad.member_name = '%s'" . $object_type_where, $name);
  }

  // See if we have one result, more than one result, or no results.
  $url = NULL;
  $options = array();
  if (isset($result)) {
    while ($object = db_fetch_object($result)) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($object->member_name != $name) {
        continue;
      }
      if (strlen($url)) {
        // This is the second match, so make this a search.
        $url = 'api/search/' . $branch->branch_name . '/' . $name;
        $options = array(
          'attributes' => array(
            'title' => t('Multiple implementations exist.'),
            'class' => 'local',
          ),
        );
        break;
      }
      else {
        // This is the first match, make a link.
        $url = api_url($object);
        $options = array(
          'attributes' => array(
            'title' => api_entity_decode($object->summary),
            'class' => 'local',
          ),
        );
      }
    }

    // See if we found a match.
    if (isset($url)) {
      return $prepend . l($name, $url, $options) . $append;
    }
  }

  // If we got here, we didn't have a match.
  return $prepend . $name . $append;
}

/**
 * Decodes HTML entities.
 *
 * @param $text
 *   Text to decode.
 *
 * @return
 *   Text with all HTML entities decoded.
 */
function api_entity_decode($text) {
  $text = html_entity_decode($text);
  // html_entity_decode does not decode numeric entities, and there are
  // many cases of &#39; (quote) in here.
  $text = str_replace('&#039;', "'", $text);
  $text = str_replace('&#39;', "'", $text);
  return $text;
}

/**
 * Turns text into a link, using the first word as the object name.
 *
 * @param $name
 *   Text to link.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Text to prepend on the link.
 * @param $append
 *   Text to append on the link.
 * @param $class_did
 *   Documentation ID of the class the link is in (if any).
 *
 * @return
 *   The text as a link.
 */
function api_link_link($name, $branch, $prepend = '', $append = '', $class_did = NULL) {
  $words = preg_split('/\s+/', $name);
  $name = array_shift($words);
  return api_link_name($name, $branch, $prepend, $append, $class_did, implode(' ', $words), TRUE);
}

/**
 * Flags a file, branch, or all branches, to be reparsed on the next cron run.
 *
 * @param $branch_or_file
 *   (optional) Identifier or ID number of the branch to reparse, or name of a
 *   single file to reparse. If omitted all branches will be reparsed. File
 *   names must include the path relative to the common path to the directories
 *   indexed by this branch.
 * @param $is_branch_name
 *   If passing in a branch name, set to TRUE so that if it happens to be an
 *   integer, it won't be considered to be a branch ID number by mistake.
 *   Otherwise, just leave this as the default FALSE.
 *
 * @return
 *   Number of files marked for reparsing.
 */
function api_mark_for_reparse($branch_or_file = NULL, $is_branch_name = FALSE) {
  $time_in_past = 52;
  if (empty($branch_or_file)) {
    // Reparse all.
    db_query("UPDATE {api_file} SET modified = %d", $time_in_past);
  }
  else {
    if (!$is_branch_name && is_numeric($branch_or_file) && ($branch_or_file == intval($branch_or_file))) {
      $branch_id = $branch_or_file;
    }
    else {
      $branch_id = db_result(db_query("SELECT branch_id FROM {api_branch} WHERE branch_name = '%s'", $branch_or_file));
    }
    if (!empty($branch_id)) {
      // Reparse a branch.
      db_query("UPDATE {api_file} f INNER JOIN {api_documentation} d ON d.object_type = 'file' AND d.did = f.did SET f.modified = %d WHERE d.branch_id = %d", $time_in_past, $branch_id);
    }
    else {
      // Reparse a file.
      db_query("UPDATE {api_file} f INNER JOIN {api_documentation} d ON d.object_type = 'file' AND d.did = f.did SET f.modified = %d WHERE d.file_name = '%s'", $time_in_past, $branch_or_file);
    }
  }

  return db_affected_rows();
}

/**
 * Parses a queued file.
 *
 * @data
 *   Array of information about the file to be parsed.
 */
function api_queue_parse_file($data) {
  module_load_include('inc', 'api', 'parser');

  api_parse_file($data['parser'], $data['path'], $data['branch'], $data['file']);
  watchdog('api', 'API parse %branch %file', array('%branch' => $data['branch_name'], '%file' => $data['file']));
}

/**
 * Deletes an obsolete JavaScript autocomplete index file.
 *
 * @param $data
 *   Array of infomration about the file to be deleted.
 */
function api_queue_file_delete($data) {
  file_delete($data['path']);
  watchdog('api', 'Remove expired API JSON, %path.', array('%path' => $data['path']));
}

/**
 * Resets the parse queue.
 *
 * Empties all parse jobs from the queue, and sets all files to "unqueued"
 * status.
 */
function api_reset_parse_queue() {
  drupal_queue_include();
  $queue = DrupalQueue::get('api_parse');
  $queue->deleteQueue();

  db_query('UPDATE {api_file} SET queued=0');
}
