<?php
// $Id: press_image_cache.module,v 1.00 2010/09/22 15:54:00 rso (Rouslan Sorokine) Exp $

/**
 * @file
 *   Imagecache Functions to support Wally Press Content
 *
 *	 The goal of this module is to change the standard imagecache behavior to:
 *	1. Incorporate node id of the Image Object Node Type node into the file name
 *	2. Instead of putting presetted images as "preset_name/file_name"
 *	   incorporate a subdirectory structure based on the node id of (1)
 *	For example, for a nid=123 this structure will be
 *	   "preset_name/1/12/file_name_123"
 */


//==================
//IMAGECACHE ACTIONS
//==================

/**
 * Implementation of hook_imagecache_actions().
 */
function press_image_cache_imagecache_actions() {
  $actions = array(
    'imagecrop_wally' => array(
      'name' => 'Wally crop and scale',
      'description' => 'Create a crop and scale of an image from a Photo object node.',
      'file' => 'press_image_cache_actions.inc',
    ),
  );
  return $actions;
}

//=============
//DRUPAL HOOKS.
//=============

/**
 * Implementation of hook_menu().
 * Take control over imagecache.
 * Adapted from imagecache_menu()
 */
function press_image_cache_menu() {
  $items = array();

  // make our own standard imagecache callback.
  $items[file_directory_path() .'/imagecache'] = array(
//  'page callback' => 'imagecache_cache',
	'page callback' => 'press_image_cache_imagecache_cache',	//RSO+
	'access callback' => TRUE,
	'type' => MENU_CALLBACK
  );

  return $items;
}

//==========
//CALLBACKS.
//==========

/**
 * callback for handling public files imagecache requests.
 * Adapted from imagecache_cache()
 */
function press_image_cache_imagecache_cache() {
  $args = func_get_args();
  $preset = check_plain(array_shift($args));
  $path = implode('/', $args);	// = subdirectory name + original file name + nid, e.g. 1/12/photo_123.jpg  
  _press_image_cache_imagecache_cache($preset, $path);
}

//=============================
//IMAGECACHE MODIFIED FUNCTIONS
//=============================

/**
 * Create and image tag for an imagecache derivative.
 * Adapted from theme_imagecache()
 * Used in template.php / current theme
 *
 * @param $presetname
 *   String with the name of the preset used to generate the derivative image.
 * @param $path
 *   String path to the original image you wish to create a derivative image
 *   tag for.
 * @param $alt
 *   Optional string with alternate text for the img element.
 * @param $title
 *   Optional string with title for the img element.
 * @param $attributes
 *   Optional drupal_attributes() array. If $attributes is an array then the
 *   default imagecache classes will not be set automatically, you must do this
 *   manually.
 * @param $getsize
 *   If set to TRUE, the image's dimension are fetched and added as width/height
 *   attributes.
 * @return
 *   HTML img element string.
 */
function press_image_cache_theme_imagecache($presetname, $path, $alt = '', $title = '', $attributes = NULL, $getsize = TRUE, $nid = '') {
  // Check is_null() so people can intentionally pass an empty array of
  // to override the defaults completely.
  
  if (is_null($attributes)) {
    $attributes = array('class' => 'imagecache imagecache-'. $presetname);
  }
  if ($getsize && ($image = image_get_info(press_image_cache_imagecache_create_path($presetname, $path, $nid)))) {	//RSO+
    $attributes['width'] = $image['width'];
    $attributes['height'] = $image['height'];
  }

  $attributes = drupal_attributes($attributes);
  $imagecache_url = press_image_cache_imagecache_create_url($presetname, $path, FALSE, $nid);	//RSO+ instead of imagecache_create_url()
  return '<img src="'. $imagecache_url .'" alt="'. check_plain($alt) .'" title="'. check_plain($title) .'" '. $attributes .' />';
}


/**
 * Return a URL that points to the location of a derivative of the
 * original image transformed with the given preset.
 * Adapted from cache_imagecache_create_url()
 *
 * Special care is taken to make this work with the possible combinations of
 * Clean URLs and public/private downloads. For example, when Clean URLs are not
 * available an URL with query should be returned, like
 * http://example.com/?q=files/imagecache/foo.jpg, so that imagecache is able
 * intercept the request for this file.
 *
 * This code is very similar to the Drupal core function file_create_url(), but
 * handles the case of Clean URLs and public downloads differently however.
 *
 * @param $presetname
 * @param $filepath
 *   String specifying the path to the image file.
 * @param $bypass_browser_cache
 *   A Boolean indicating that the URL for the image should be distinct so that
 *   the visitors browser will not be able to use a previously cached version.
 *   This is
 */
function press_image_cache_imagecache_create_url($presetname, $filepath, $bypass_browser_cache = FALSE, $nid = '') {
  $path = _imagecache_strip_file_directory($filepath);
  if (module_exists('transliteration')) {
    $path = transliteration_get($path);
  }

  $subdir=_press_image_cache_get_subdir($nid);		//RSO+ Calculate the subdirectory 
  $path=_press_image_cache_get_fname($path,$nid);	//RSO+ Append node id to the file name
  
  $args = array('absolute' => TRUE, 'query' => empty($bypass_browser_cache) ? NULL : time());
  switch (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC)) {
    case FILE_DOWNLOADS_PUBLIC:
      return url($GLOBALS['base_url'] . '/' . file_directory_path() .'/imagecache/'. $presetname .'/'. $subdir . $path, $args);	//RSO+
    case FILE_DOWNLOADS_PRIVATE:
      return url('system/files/imagecache/'. $presetname .'/'. $subdir . $path, $args);
  }
}


/**
 * handle request validation and responses to imagecache requests.
 * Adapted from _imagecache_cache()
 *	$path = subdirectory name + original file name + nid, e.g. 9/99/photo_999.jpg
 */
function _press_image_cache_imagecache_cache($presetname, $path) {
  if (!$preset = imagecache_preset_by_name($presetname)) {
    // Send a 404 if we don't know of a preset.
    header("HTTP/1.0 404 Not Found");
    exit;
  }
  
  //RSO+
  // Load the Photo Object node, to get x,y,h,w to apply to the preset
  // If the photo node is not found, default preset values will be applied
  $nid=_press_image_cache_strip_nid($path);
  $photo_node=FALSE;
  if ($nid != '') 
    $photo_node=node_load($nid);
  if ($photo_node && $photo_node->type == 'wally_photoobjecttype') {
	// an array of crops
	$crops=$photo_node->field_wally_crop;
	if (is_array($crops))
	  foreach($crops as $crop) {
		$crop_value=unserialize($crop['value']);
		// The crop matches the used preset
		if ($crop_value && strtolower($crop_value['crop_type'])==strtolower($presetname)) {
		  // Find imagecrop_wally action(s)
		  foreach($preset['actions'] as $preset_key => $preset_action) {
			if ($preset_action['action'] == 'imagecrop_wally') {
			// Update the preset with the values from the crop
			  if (isset($crop_value['crop_w']))
				$preset['actions'][$preset_key]['data']['width']=$crop_value['crop_w'];
			  if (isset($crop_value['crop_h']))
				$preset['actions'][$preset_key]['data']['height']=$crop_value['crop_h'];
			  if (isset($crop_value['crop_x']))
				$preset['actions'][$preset_key]['data']['xoffset']=$crop_value['crop_x'];
			  if (isset($crop_value['crop_y']))
				$preset['actions'][$preset_key]['data']['yoffset']=$crop_value['crop_y'];
			}
		  }
		}
	  }
  }

  // umm yeah deliver it early if it is there. especially useful
  // to prevent lock files from being created when delivering private files.
  $dst = press_image_cache_imagecache_create_path($preset['presetname'], $path);	//RSO+
  if (is_file($dst)) {
    imagecache_transfer($dst);
  }

  // preserve path for watchdog.
  $src = _press_image_cache_strip_fname($path);		//RSO+

  // Check if the path to the file exists.
  if (!is_file($src) && !is_file($src = file_create_path($src))) {
    watchdog('imagecache', '404: Unable to find %image ', array('%image' => $src), WATCHDOG_ERROR);
    header("HTTP/1.0 404 Not Found");
    exit;
  };

  // Bail if the requested file isn't an image you can't request .php files
  // etc...
  if (!getimagesize($src)) {
    watchdog('imagecache', '403: File is not an image %image ', array('%image' => $src), WATCHDOG_ERROR);
    header('HTTP/1.0 403 Forbidden');
    exit;
  }

  $lockfile = file_directory_temp() .'/'. $preset['presetname'] . basename($src);
  if (file_exists($lockfile)) {
    watchdog('imagecache', 'ImageCache already generating: %dst, Lock file: %tmp.', array('%dst' => $dst, '%tmp' => $lockfile), WATCHDOG_NOTICE);
    // 307 Temporary Redirect, to myself. Lets hope the image is done next time around.
    header('Location: '. request_uri(), TRUE, 307);
    exit;
  }
  touch($lockfile);
  // register the shtdown function to clean up lock files. by the time shutdown
  // functions are being called the cwd has changed from document root, to
  // server root so absolute paths must be used for files in shutdown functions.
  register_shutdown_function('file_delete', realpath($lockfile));

  // check if deriv exists... (file was created between apaches request handler and reaching this code)
  // otherwise try to create the derivative.
  if (file_exists($dst) || imagecache_build_derivative($preset['actions'], $src, $dst)) {
    imagecache_transfer($dst);
  }
  // Generate an error if image could not generate.
  watchdog('imagecache', 'Failed generating an image from %image using imagecache preset %preset.', array('%image' => $path, '%preset' => $preset['presetname']), WATCHDOG_ERROR);
  header("HTTP/1.0 500 Internal Server Error");
  exit;
}


/**
 * Return a file system location that points to the location of a derivative
 * of the original image at @p $path, transformed with the given @p $preset.
 * Keep in mind that the image might not yet exist and won't be created.
 * Adapted from imagecache_create_path()
 *	$path = original file path, e.g. sites/default/files/photo.jpg 
 */
function press_image_cache_imagecache_create_path($presetname, $path, $nid='') {
  $path = _imagecache_strip_file_directory($path);
  
  if ($nid=='')
	$subdir='';
  else {
	$subdir=_press_image_cache_get_subdir($nid);		//RSO+ Calculate the subdirectory 
	$path=_press_image_cache_get_fname($path,$nid);	//RSO+ Append node id to the file name
  }

  return file_create_path() .'/imagecache/'. $presetname .'/'. $subdir. $path;	//RSO+
}

//================
//HELPER FUNCTIONS
//=================
/**
 * Return a subdirectory (of preset) name calculated out of node id, e.g.:
 * $nid=1234567 ==> $subdir='000/001/234/'
 * $nid=''		==> $subdir=''
 * 
 */

function _press_image_cache_get_subdir($nid) {
  if ($nid == '')
	$subdir='';
  else
	$subdir=chunk_split(str_pad(substr($nid,0,strlen($nid)-3),9,'0',STR_PAD_LEFT),3,'/');
  return $subdir;
}

/**
 * Return a file name calculated with node id, e.g.:
 * $filename='xxx/file.jpg'; $nid=123 ==> 'xxx/file_123.jpg'
 * 
 */

function _press_image_cache_get_fname($filename,$nid = '') {
  $new_name='';
  $name_info=pathinfo($filename);
  if (isset($name_info['dirname']) && $name_info['dirname'] != '.')
	$new_name .= $name_info['dirname'].'/';
  $new_name .= $name_info['filename'];
  if ($nid != '')
	$new_name .= '_'.$nid;
  if (isset($name_info['extension']))
	$new_name .= '.'.$name_info['extension'];
  return $new_name;
}

/**
 * Return a file name stripped of its appended node id and of preceding subdirectory, e.g.:
 * $filename='1/12/xxx/file_123.jpg' ==> 'xxx/file.jpg'
 * 
 */

function _press_image_cache_strip_fname($filename) {
  if ($filename=='')
	return '';

  $name_info=pathinfo($filename);
  $file_name_info=explode("_", $name_info['filename']);
  $count=count($file_name_info);
  if ($count>1) {
    $nid=$file_name_info[$count-1];		// keep nid for later
	if (!is_numeric($nid))
	  $nid='';
	unset($file_name_info[$count-1]);	// remove the nid
  }
  $file_name_info=implode("_",$file_name_info);
  $original_filename=$file_name_info;
  if (isset($name_info['extension']))
	$original_filename .= '.'.$name_info['extension'];
  $subdir=_press_image_cache_get_subdir($nid);
  if (isset($name_info['dirname']) && $name_info['dirname'] != '.') {
	$dirname = substr($name_info['dirname'],strlen($subdir)).'/';
  }
  else
	$dirname = '';

  $new_name = $dirname.$original_filename;
  return $new_name;
}

/**
 * Return the nid of a file name, e.g.:
 * $filename='1/12/xxx/file_123.jpg' ==> '123'
 * $filename='1/12/xxx/file.jpg'	 ==> ''
 * 
 */

function _press_image_cache_strip_nid($filename) {
  if ($filename=='')
	return '';
  $nid='';
  $name_info=pathinfo($filename);
  $file_name_info=explode("_", $name_info['filename']);
  $count=count($file_name_info);
  if ($count>1) {
    $nid=$file_name_info[$count-1];		// keep nid for later
	if (!is_numeric($nid))
	  $nid='';
  }
  return $nid;
}
