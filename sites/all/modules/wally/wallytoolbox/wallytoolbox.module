<?php
/**
 * @defgroup wallytoolbox Wally ToolBox functions
 * @{
 * In this module we define functions that could be used in any of 
 * the wally modules. These function aren't linked to a specific context
 * and could be use anywhere. 
 */

/**
 * A true boolean conversion function.
 * 
 * @param $v
 *   The value to be converted
 * @param $del
 *   default value return if conversion fail.
 *
 * @return
 *   boolean "true" or "false"
 */
function wallytoolbox_toboolean($v,$def=null){
	if ($v===false) return false;
	if ($v===true) return true;
	if ($v=="true") return true;
	if ($v=="false") return false;
	if ($v==0) return false;
	if ($v==1) return true;
	return $def;
}

/**
 * Search for taxonomy terms for a specific "path". 
 *
 * @param $path
 *   The taxonomy term path to match ( /term1/term2/term3 ). 
 * @param $voc
 *   The taxonomy vocabulary used for filtering on a single vocabulary.
 *   If not set, will seach into all vocabularies.
 *
 * @return
 *   an array of taxonomy term object
 */
function wallytoolbox_taxonomy_get_term_by_path($path, $voc=null){

	$t = explode("/", trim($path,"/"));
	$t = $t[count($t)-1];

	if ($voc) {
		$db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s') AND t.vid = %s", trim($t), $voc);
	} else {
		$db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s')", trim($t));
	}

	$result = array();

	// Reverse building of path for founded terms.
	while ($term = db_fetch_object($db_result)) {
		$ppath = "";
		$parents = taxonomy_get_parents_all($term->tid);
		foreach ($parents as $parent) $ppath = strtolower($parent->name)."/".$ppath;
		if (trim($ppath,"/")==strtolower(trim($path,"/"))) $result[] = $term;
	}
	return ($result ? $result : null);
}

/**
 * Add a taxonomy term into a vocabulary without 
 * need to store a node.
 *
 * @param $name
 *   That's the taxonomy term name. 
 * @param $vid
 *   The Taxonomy Vocabulary to store the term. 
 * @param $description
 *   Description of the term to be stored.
 * @param $weight
 *   Weight of the term into vocabulary (default 0).
 * @param $parent
 *   Parent term if needed (default null).
 * 
 * @return
 *   Taxonomy TID of the created term. 
 */
function wallytoolbox_add_taxonomy_term($name, $vid, $description = '', $weight = 0, $parent = null){
  $form_values = array();
  $form_values['name'] = $name;
  $form_values['description'] = $description;
  $form_values['vid'] = $vid;
  $form_values['weight'] = $weight;
  if ($parent) $form_values['parent'] = $parent;
  taxonomy_save_term($form_values);
  return $form_values['tid'];
}


/**
 * Get all nodes associated with a array of taxonomy term.  
 *  
 * @param $tid
 *   An array of term IDs to match. 
 * @param $operator
 *   Could be 'or' or 'and' (default 'or') 
 * @param $depth
 *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative integer or "all". 
 * @param $pager 
 *   Whether the nodes are to be used with a pager (the case on most Drupal pages) or not (in an XML feed, for example).
 * @param $type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * @param $order
 *   Order close for TID (SSL format). See @link http://api.drupal.org/api/drupal/includes--database.inc/ Data Base abstraction layer @endlink for table aliases.
 * 
 * @return
 *   Array of Node ID. 
 */
function wallytoolbox_taxonomy_get_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $type = null, $order = 'n.sticky DESC, n.created DESC'){

  $r = array();
  
  if (count($tids) > 0) {
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    
    foreach ($tids as $index => $tid) {
      $term = taxonomy_get_term($tid);
      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
    }

    if ($operator == 'or') {
      $args = call_user_func_array('array_merge', $descendant_tids);
      $placeholders = db_placeholders($args, 'int');
      $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
    }
    else {
      $joins = '';
      $wheres = '';
      $args = array();
      foreach ($descendant_tids as $index => $tids) {
        $joins .= ' INNER JOIN {term_node} tn' . $index . ' ON n.vid = tn' . $index . '.vid';
        $wheres .= ' AND tn' . $index . '.tid IN (' . db_placeholders($tids, 'int') . ')';
        $args = array_merge($args, $tids);
      }
      $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.created  FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
    }

	if ($type) {
		$sql = $sql . ' AND n.type = "'.$type.'"';
		$sql_count = $sql_count . ' AND n.type = "'.$type.'"';
	}

	// add Order Clause
	$sql = $sql . ' ORDER BY ' . $order; 
	
    $sql = db_rewrite_sql($sql);
	$sql_count = db_rewrite_sql($sql_count);

    if ($pager) {
      $results = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);
    }
    else {
      $results = db_query($sql, $args);
    }

    while ($result = db_fetch_object($results)) {
		$r[] = $result->nid;
    }
    
  }
  return $r;
}


/**
 * Get all nodes where  cckfield match a value. 
 *
 * @param $param
 *   An associative array containing:
 *   - key: An existing cck_field name with the prfix "field_" 
 *   - value: The value to match specified cck_field
 * @param $node_type
 *   Node Type Filter. Could be use to return only a certain type of nodes. 
 * 
 * @return
 *   An array of nodes
 */
function wallytoolbox_get_node_by_cckfield($param,$node_type=null){

	$nodes = array();
	foreach ($param as $key => $value) {
		$sql="
			SELECT node.nid AS nid
			 FROM {node} node 
			 LEFT JOIN {content_".$key."} node_data_".$key." ON node.vid = node_data_".$key.".vid
			 WHERE (node_data_".$key.".".$key."_value = '%s')
			";

		// Fetch all node from CCK field table.
		if ($result = db_query($sql, $value)) {
			while ($item = db_fetch_object($result)) {
				if ($node = node_load($item->nid)) {
					if ($node_type) {
						if ($node->type == $node_type) {
							$nodes[$node->nid] = $node;
						}
					} else {
						$nodes[$node->nid] = $node;
					}
				} 
			}
		}
	}
	
	$result = array(); 
	foreach($nodes as $node) $result[]=$node;

	if (count($result)) { 
		return $result;
	} else {
		return null;
	}
}
	

/**
 * @} End of "defgroup wallytoolbox".
 */
