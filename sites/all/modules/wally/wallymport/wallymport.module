<?php

/**
 * Implementation of hook_menu().
 */
function wallymport_menu() {
  $items = array();
  $items['admin/settings/wallymport'] = array(
    'title' => 'Wally Import Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wallymport_page_admin_form'),
    'access arguments' => array('access administration pages'),
    'description' => 'Allows administrators to set paramaters for this module to function properly.',
    'file' => 'includes/wallymport.admin.inc',

  );

  $items['wallymport/process'] = array(
	'title' => 'Run XML Import Process',
	'description' => 'Run data import',
	'page callback' => 'wallymport_page_process_folder',
	'access arguments' => array('access administration pages'),
	'type' => MENU_CALLBACK,
    'file' => 'includes/wallymport.fields.inc',
  
  );
  $items['wallymport/process/%'] = array(
	'title' => 'Run XML Import Process',
	'description' => 'Run data import',
	'page callback' => 'wallymport_page_process_file',
	'page arguments' => array(2),
  	'access arguments' => array('access administration pages'),
	'type' => MENU_CALLBACK,
    'file' => 'includes/wallymport.fields.inc',
  
  );


  return $items;
}


/**
 * Page CallBack: Process the import folder folder 
 * 
 * Page Callback of the processing of the import folder and call for each element the wallymport_page_process_file.
 * *
 * @return
 *   html content
 */
function wallymport_page_process_folder(){
  return 'rrr';


}



/**
 * Page CallBack: Process a zip file or the folder containg the xml file 
 * 
 * Page Callback of the processing of a single pacakges.
 * The function load the XML file, validate it with the xsd defined in the module's settings
 *  and call the recursive process "wimprt_process_packages"
 *
 * @param $path_to_file
 *   The path to a zip or an XML file to be proccesed. if the path is an XML file, the parent folder will be considered.
 *
 * @return
 *   html content
 */

function wallymport_page_process_file($path_to_file){
  if(!$path_to_file){
    drupal_set_message("error",'You must to provide a path to the XML');
    return '';
  }
  $xsd_file= variable_get('wallymport_definition', 'definitions/yaxim.input.xsd');

  $xml_file = variable_get('wallymport_source','')."/".$path_to_file;
  $handle = fopen($xml_file, "r");
  $contents = fread($handle, filesize($xml_file));
  fclose($handle);
  $dom = new DomDocument();
  $dom->LoadXML($contents);
  if (!$dom->schemaValidate($xsd_file)){
    drupal_set_message('The XML file isn\'t validate by the XSD file',"error");
    return '';
  }

  $node=new StdClass();

  $log=array();
  $return=wimprt_process_packages($node,$dom,$log);

  dsm($node);
  
  //@todo: theming function
  return '<pre>'.print_r($return,1).'</pre>';

}

/**
 * Process the packages element of a DomDocument object
 * 
 * Initiate the node object Call an apropriate function to process the childs of the packages element (package) 
 *
 * @param $dom
 *   The DomDocument who is being proceed 
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *   
 * @return
 *   the log object
 */
function wimprt_process_packages($node,$dom,&$log){

  module_invoke_all('wimprt_process_packages',$dom,$log,'before_process');
  foreach($dom->getElementsByTagName('Package') as $package_element){
    $node=new stdClass;
    wimprt_process_package($node,$package_element,$log);
  }
  module_invoke_all('wimprt_process_packages',$dom,$log,'after_process');
  
  return $log;
}


/**
 * Process the package element
 * 
 * Call an apropriate function to process the childs of the package element 
 * depending the attribute type of the child element.
 * 
 * The naming convention to build a node from a specific package type is: wimprt_process_package_TYPE
 * 
 * if no specific fntion found the default fallback function is called: wimprt_process_package.
 *
 * @param $node
 *   The Node that's being build 
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *   
 * @return
 *   the node object that has been build
 */
function wimprt_process_package(&$node,$dom,&$log){
  
  $node->titi="eee";
  if(variable_get('wallymport_debug',0) or true)
    $log[]='process package: '.$dom->nodeName;
  
  
  module_invoke_all('wimprt_process_package',$node,$dom,$log,'before_process');
  
  $type=strtolower($dom->getAttributeNode('xsi:type')->value);
   // ?Posibility of extension with 'hook_wallymport_info' / CTools Plugin?
  if(function_exists("wimprt_process_package_".$type)){
    call_user_func("wimprt_process_package_".$type,&$node,$dom,&$log);
  }
  
  module_invoke_all('wimprt_process_package',$node,$dom,$log,'after_process');
  
  //@todo: call node_save()
  //node_save($node);
  return $node;
}


/**
 * Process an object element
 * 
 * Call an apropriate function to process an object element 
 * depending the attribute type of the child element.
 * 
 * The naming convention to build a node from a specific package type is: wimprt_process_object_TYPE
 * 
 * if no specific fntion found the default fallback function is called: wimprt_process_package.
 *
 * @param $node
 *   The Node that's being build 
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *   
 * @return
 *   the node object that has been build
 */
function wimprt_process_object($dom,&$log,$type=NULL){
  if(variable_get('wallymport_debug',0) or true)
    $log[]='process object: '.$dom->nodeName;
  
  
  $node=new stdClass;
  module_invoke_all('wimprt_process_object',&$node,$dom,&$log,'before_process');
  
  $type=strtolower($type);
  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  echo "wimprt_process_object_$type";
  if(function_exists("wimprt_process_object_$type")){
    call_usr_func("wimprt_process_object_$type",&$node,$dom,&$log);
  }
  
  module_invoke_all('wimprt_process_object',$node,$dom,$log,'after_process');
  //@todo: call node_save()
  //node_save($node);
  return $node;
}


function wimprt_process_type(&$node,$dom,&$log,$type=NULL){
    if(variable_get('wallymport_debug',0) or true)
    $log[]='process type: '.$dom->nodeName;
  
  
  module_invoke_all('wimprt_process_type',$node,$dom,$log,'before_process');
  if($type==NULL){
    $type=strtolower($dom->getAttribute('type'));
  }
  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  if(function_exists("wimprt_process_object_$type")){
    call_usr_func("wimprt_process_type_$type",&$node,$dom,&$log);
  }
  
  module_invoke_all('wimprt_process_type',$node,$dom,$log,'after_process');
  //@todo: call node_save()
  node_save($node);
  return $node;
}


function wimprt_process_list(&$node,$dom_node_list,$type,&$log){
   if(variable_get('wallymport_debug',0) or true)
    $log[]='process list: '.$dom->nodeName;
  
  
  
  $array_of_nodes=array();
  module_invoke_all('wimprt_process_list',$array_of_nodes,$dom_node_list,$type,$log,'before_process');
  
  foreach($dom_node_list as $dom_child){
    $element_name=$dom_child->nodeName;
    if(function_exists("wimprt_process_$type.'_'.$element_name")){
     $array_of_nodes[]= call_usr_func("wimprt_process_$type.'_'.$element_name",&$node,$dom,&$log);
    }
    
  }
  module_invoke_all('wimprt_process_list',$array_of_nodes,$dom_node_list,$type,$log,'after_process');
  
  //@todo: call node_save()
  //node_save($node);
  return $array_of_nodes;
}



//***************************



function wimprt_process_package_default(&$node,$dom,&$log){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){
    
    $name=strtolower($element->nodeName);
    if(function_exists("wimprt_set_field_$name")){
      call_user_func("wimprt_set_field_$name",&$node,$element,&$log);
    }
    

  }
  
}


function wimprt_process_package_articlepackagetype(&$node,$dom_element,&$log){
  //Process atributes
  //..
  
  $node->type='wally_articlepackage';
  $node->uid=1;
  $node->created_at= strtotime($dom_element->getAttributeNode("CreationDate")->value);
  $node->language= $dom_element->getAttributeNode("Language")->value;
  $node->created= $dom_element->getAttributeNode("PackageID")->value;
  $node->created_at= $dom_element->getAttributeNode("PublicationDate")->value;
  $node->created_at= $dom_element->getAttributeNode("LastUpdateDate")->value;
  $node->created_at= $dom_element->getAttributeNode("EmbargoDate")->value;
  
  imprt_set_field_mainstory($node,$dom_element->getElementsByTagName("MainStory")->item(0),$log);
  wimprt_process_package_default($node,$dom_element,$log);
}

//***************************
function wimprt_set_field_locations(&$node,$dom,&$log){
  
  $result=wimprt_process_list(&$node,$dom,'type',$log);
  dsm('REsult:');
  dsm($result);
  $name= $dom->nodeName;
  $node->{$name}[0]['value']=$dom->nodeValue;
}



function imprt_set_field_mainstory(&$node,$dom,&$log){
  $object=wimprt_process_object($dom,$log,'TextObject');
  $node->MainStory['nid'][0]=$object->nid;
}

function imprt_process_object_textobject(&$node,$dom,&$log){
  echo 'rrr';
  //  $object=wimprt_process_object($dom,$log,'TextObject');
//  $node->MainStory['nid'][0]=$object->nid;
}

