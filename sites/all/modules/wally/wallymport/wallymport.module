<?php


module_load_include('inc', 'wallymport', 'includes/wallymport.fields');
module_load_include('inc', 'wallymport', 'includes/wallymport.fieldshelpers');

/**
 * Implementation of hook_menu().
 */
function wallymport_menu() {
  $items = array();
  $items['admin/settings/wallymport'] = array(
    'title' => 'Wally Import Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wallymport_page_admin_form'),
    'access arguments' => array('access administration pages'),
    'description' => 'Allows administrators to set paramaters for this module to function properly.',
    'file' => 'includes/wallymport.admin.inc',

  );

  $items['wallymport/process'] = array(
	'title' => 'Run XML Import Process',
	'description' => 'Run data import',
	'page callback' => 'wallymport_page_process_folder',
	'access arguments' => array('access administration pages'),
	'type' => MENU_CALLBACK,
 
  );
  $items['wallymport/process/%'] = array(
	'title' => 'Run XML Import Process',
	'description' => 'Run data import',
	'page callback' => 'wallymport_page_process_file',
	'page arguments' => array(2),
  	'access arguments' => array('access administration pages'),
	'type' => MENU_CALLBACK,
  
  );


  return $items;
}


/**
 * Page CallBack: Process the import folder folder
 *
 * Page Callback of the processing of the import folder and call for each element the wallymport_page_process_file.
 * *
 * @return
 *   html content
 */
function wallymport_page_process_folder(){
  return 'rrr';


}



/**
 * Page CallBack: Process a zip file or the folder containg the xml file
 *
 * Page Callback of the processing of a single pacakges.
 * The function load the XML file, validate it with the xsd defined in the module's settings
 *  and call the recursive process "wimprt_process_packages"
 *
 * @param $path_to_file
 *   The path to a zip or an XML file to be proccesed. if the path is an XML file, the parent folder will be considered.
 *
 * @return
 *   html content
 */

function wallymport_page_process_file($path_to_file){
  if(!$path_to_file){
    drupal_set_message("error",'You must to provide a path to the XML');
    return '';
  }
  $xsd_file= variable_get('wallymport_definition', 'definitions/yaxim.input.xsd');

  $xml_file = variable_get('wallymport_source','')."/".$path_to_file;
  $handle = fopen($xml_file, "r");
  $contents = fread($handle, filesize($xml_file));
  fclose($handle);
  $dom = new DomDocument();
  $dom->LoadXML($contents);
  if (!$dom->schemaValidate($xsd_file)){
    drupal_set_message('The XML file isn\'t validate by the XSD file',"error");
    return '';
  }

  $node=new StdClass();

  $log=array();
  $return=wimprt_process_packages($node,$dom,$log);

  //@todo: theming function
  return '<pre>'.print_r($return,1).'</pre>';

}

/**
 * Process the packages element of a DomDocument object
 *
 * Initiate the node object Call an apropriate function to process the childs of the packages element (package)
 *
 * @param $dom
 *   The DomDocument who is being proceed
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   the log object
 */
function wimprt_process_packages($node,$dom,&$log){

  module_invoke_all('wimprt_process_packages',$dom,$log,'before_process');
  foreach($dom->getElementsByTagName('Package') as $package_element){
    $node=new stdClass;
    wimprt_process_package($node,$package_element,$log);
  }
  module_invoke_all('wimprt_process_packages',$dom,$log,'after_process');

  return $log;
}


/**
 * Process the package element
 *
 * Call an apropriate function to process the childs of the package element
 * depending the attribute type of the child element.
 *
 * The naming convention to build a node from a specific package type is: wimprt_process_package_TYPE
 *
 * if no specific function found nothing is done.
 *
 * @param $node
 *   The Node that's being build
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   the node object that has been build
 *   
 * @ingroup wallymport_process
 *   
 */
function wimprt_process_package(&$node,$dom,&$log,$callback=NULL){
  $callback=wimprt_set_callback($dom,$callback);
  $node=wimprt_create_or_load($dom, $callback,$log);
  
  //@todo: place in walymportlog module
  if(variable_get('wallymport_debug',0) or true)
    $log['log'][]='process package: '.$dom->nodeName;


  module_invoke_all('wimprt_process_package',$node,$dom,$log,'before_process');

  // ?Posibility of extension with 'hook_wallymport_info' / CTools Plugin?
  if(function_exists("wimprt_process_package_".$callback)){
    call_user_func("wimprt_process_package_".$callback,&$node,$dom,&$log);
  }

  module_invoke_all('wimprt_process_package',$node,$dom,$log,'after_process');

  //@todo: call node_save()
  //node_save($node);
  $log['node']=array('current'=>$node,'next'=>$log['node']);
    
  return $node;
}


/**
 * Process an object element
 *
 * Call an apropriate function to process an object element
 * depending the attribute type of the child element.
 *
 * The naming convention to load or create the node before his build is: wimprt_create_or_load_object_TYPE
 * 
 * The naming convention to build a node from a specific package type is: wimprt_process_object_TYPE
 *
 * if no specific function found nothing is done.
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   the node object that has been build
 *   
 * @ingroup wallymport_process
 */
function wimprt_process_object($dom,&$log,$callback=NULL){
  $callback=wimprt_set_callback($dom,$callback);
  $node=wimprt_create_or_load($dom, $callback,$log);

  //@todo: place in walymportlog module
  if(variable_get('wallymport_debug',0) or true)
    $log['log'][]='process object: '.$dom->nodeName;

  
  module_invoke_all('wimprt_process_object',$node,$dom,$log,'before_process');
  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  if(function_exists("wimprt_process_object_$callback")){
    call_user_func("wimprt_process_object_$callback",&$node,$dom,&$log);
  }

  module_invoke_all('wimprt_process_object',$node,$dom,$log,'after_process');
  //@todo: call node_save()
  //node_save($node);
  $log['node']=array('current'=>$node,'next'=>$log['node']);
    return $node;
}

/**
 * Process a type element
 *
 * Call an apropriate function to process an object element
 * depending the attribute type of the child element.
 *
 * The naming convention to load or create the node before his build is: wimprt_create_or_load_type_TYPE
 * 
 * The naming convention to build a node from a specific package type is: wimprt_process_type_TYPE
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   the node object that has been build
 *   
 * @ingroup wallymport_process
 */
function wimprt_process_type($dom,&$log,$callback=NULL){
  $callback=wimprt_set_callback($dom,$callback);
  $node=wimprt_create_or_load($dom, $callback,$log);

  //@todo: place in walymportlog module
  if(variable_get('wallymport_debug',0) or true)
    $log['log'][]='process type: '.$dom->nodeName;
    
  module_invoke_all('wimprt_process_type',$node,$dom,$log,'before_process');
  $callback=strtolower($callback);
  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  if(function_exists("wimprt_process_type_$callback")){
    call_user_func("wimprt_process_type_$callback",&$node,$dom,&$log);
  }

  module_invoke_all('wimprt_process_type',$node,$dom,$log,'after_process');
  //@todo: call node_save()
  //node_save($node);
  $log['node']=array('current'=>$node,'next'=>$log['node']);
  return $node;
}



/**
 * Process a type list of element
 *
 * Call an apropriate function to process an object element
 * depending the attribute type of the child element.
 *
 * The naming convention to build a node from a specific package type is: wimprt_process_type_TYPE
 *
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *
 * @return
 *   the node object that has been build
 *   
 * @ingroup wallymport_process
 */
function wimprt_process_list($dom_element,&$log,$callback=NULL){
  $callback=wimprt_set_callback($dom,$callback);

  //@todo: place in walymportlog module  
  if(variable_get('wallymport_debug',0) or true){
    $log['log'][]='process list: '.$dom_element->nodeName;
  }
   

  $array_of_nodes=array();
  module_invoke_all('wimprt_process_list',$array_of_nodes,$dom_element,$callback,$log,'before_process');

  foreach($dom_element->childNodes as $dom_child){
    $element_name=$dom_child->nodeName;
    if(function_exists("wimprt_process_".$callback)){
      $array_of_nodes[]= call_user_func("wimprt_process_".$callback,$dom_child,&$log);
    }

  }
  module_invoke_all('wimprt_process_list',$array_of_nodes,$dom_element,$callback,$log,'after_process');

  //@todo: call node_save()
  //node_save($node);
  
  $log['node']=array('current'=>$array_of_nodes);
  return ;
}


/**
 * @defgroup wallymport_process Wallymport Process Function
 * @{
 * Functions that are part of the processing of the XML Data.
 */

// Everything in here is automatically added to the group.

/**
 * @} End of "defgroup mymodule_validation".
 */


/**
 * @defgroup wallymport_process_default Wallymport Default Process Function
 * @{
 * Functions that can be called by specific function as default behavior to process child element.
 */

// Everything in here is automatically added to the group.

/**
 * @} End of "defgroup mymodule_validation".
 */


//***************************





function wimprt_process_package_default(&$node,$dom,&$log){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){

    $name=strtolower($element->nodeName);
    if(function_exists("wimprt_set_field_$name")){
      call_user_func("wimprt_set_field_$name",&$node,$element,&$log);
    }
  }

}


function wimprt_process_object_default(&$node,$dom,&$log){
  //Beware of namespace colision

  foreach($dom->childNodes as $element){

    $name=strtolower($element->nodeName);
    if(function_exists("wimprt_set_field_$name")){
      call_user_func("wimprt_set_field_$name",&$node,$element,&$log);
    }
     
  }

}
function wimprt_process_type_default(&$node,$dom,&$log){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){

    $name=strtolower($element->nodeName);
    if(function_exists("wimprt_set_field_$name")){
      call_user_func("wimprt_set_field_$name",&$node,$element,&$log);
    }
  }

}

/**
 * determine the callback function
 *
 * If a callback is passed dont change else try to determine the next callback:
 * first try the xsi:type
 * second try the tag name in xsi:type doesn't exist
 *
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $callback
 *   The callback passing as argument to the caller function
 *   
 * @return
 *   the next callback
 *   
 */
function wimprt_set_callback($dom,$callback=NULL){
  if(get_class($dom)=='DOMElement'){
    if($callback==NULL){
      if($dom->hasAttribute('xsi:type'))
        $callback=$dom->getAttributeNode('xsi:type')->value;
      else
        $callback=$dom->nodeName;
    }
  }
  return strtolower($callback);
}


function wimprt_create_or_load($dom, $callback,$log){
if(function_exists("wimprt_create_or_load_object_$callback")){
    $node=call_user_func("wimprt_create_or_load_object_$callback",$dom,&$log);
  }
  else{
   $node=new stdClass;
  }
  return $node;
}

