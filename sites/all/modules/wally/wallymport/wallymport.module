<?php

/**
 * Implementation of hook_menu().
 */
function wallymport_menu() {
  $items = array();
  $items['admin/settings/wallymport'] = array(
    'title' => 'Wally Import Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wallymport_page_admin_form'),
    'access arguments' => array('access administration pages'),
    'description' => 'Allows administrators to set paramaters for this module to function properly.',
    'file' => 'includes/wallymport.admin.inc',

  );

  $items['wallymport/process'] = array(
	'title' => 'Run XML Import Process',
	'description' => 'Run data import',
	'page callback' => 'wallymport_page_process_folder',
	'access arguments' => array('access administration pages'),
	'type' => MENU_CALLBACK,
    'file' => 'includes/wallymport.fields.inc',
  
  );
  $items['wallymport/process/%'] = array(
	'title' => 'Run XML Import Process',
	'description' => 'Run data import',
	'page callback' => 'wallymport_page_process_file',
	'page arguments' => array(2),
  	'access arguments' => array('access administration pages'),
	'type' => MENU_CALLBACK,
    'file' => 'includes/wallymport.fields.inc',
  
  );


  return $items;
}


/**
 * Page CallBack: Process the import folder folder 
 * 
 * Page Callback of the processing of the import folder and call for each element the wallymport_page_process_file.
 * *
 * @return
 *   html content
 */
function wallymport_page_process_folder(){
  return 'rrr';


}



/**
 * Page CallBack: Process a zip file or the folder containg the xml file 
 * 
 * Page Callback of the processing of a single pacakges.
 * The function load the XML file, validate it with the xsd defined in the module's settings
 *  and call the recursive process "wimprt_process_packages"
 *
 * @param $path_to_file
 *   The path to a zip or an XML file to be proccesed. if the path is an XML file, the parent folder will be considered.
 *
 * @return
 *   html content
 */

function wallymport_page_process_file($path_to_file){
  if(!$path_to_file){
    drupal_set_message("error",'You must to provide a path to the XML');
    return '';
  }
  $xsd_file= variable_get('wallymport_definition', 'definitions/yaxim.input.xsd');

  $xml_file = variable_get('wallymport_source','')."/".$path_to_file;
  $handle = fopen($xml_file, "r");
  $contents = fread($handle, filesize($xml_file));
  fclose($handle);
  $dom = new DomDocument();
  $dom->LoadXML($contents);
  if (!$dom->schemaValidate($xsd_file)){
    drupal_set_message('The XML file isn\'t validate by the XSD file',"error");
    return '';
  }

  $node=new StdClass();

  $log=array();
  $return=wimprt_process_packages($dom,$log);

  //@todo: theming function
  return '<pre>'.print_r($return,1).'</pre>';

}

/**
 * Process the packages element of a DomDocument object
 * 
 * Initiate the node object Call an apropriate function to process the childs of the packages element (package) 
 *
 * @param $dom
 *   The DomDocument who is being proceed 
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *   
 * @return
 *   the log object
 */
function wimprt_process_packages($dom,&$log){

  module_invoke_all('wimprt_process_packages',$dom,$log,'before_process');
  foreach($dom->getElementsByTagName('Package') as $package_element){
    $node=new stdClass;
    wimprt_process_package(&$node,$package_element,&$log);
  }
  module_invoke_all('wimprt_process_packages',$dom,$log,'after_process');
  
  return $log;
}


/**
 * Process the package element
 * 
 * Call an apropriate function to process the childs of the package element 
 * depending the attribute type of the child element.
 * 
 * The naming convention to build a node from a specific package type is: wimprt_process_package_TYPE
 * 
 * if no specific fntion found the default fallback function is called: wimprt_process_package.
 *
 * @param $node
 *   The Node that's being build 
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *   
 * @return
 *   the node object that has been build
 */
function wimprt_process_package(&$node,$dom,&$log){
  
  module_invoke_all('wimprt_process_package',$node,$dom,$log,'before_process');
  $type=strtolower($dom->getAttribute('type'));
  // ?Posibility of extension with 'hook_wallymport_info' / CTools Plugin?
  if(function_exists("wimprt_process_package_$type")){
    call_usr_func("wimprt_process_package_$type",$node,$dom,$log);
  }
  else{
    wimprt_process_package_default($node,$dom,$log);
  }
  module_invoke_all('wimprt_process_package',$node,$dom,$log,'after_process');
  
  //@todo: call node_save()
  //node_save($node);
  return $node;
}


/**
 * Process an object element
 * 
 * Call an apropriate function to process an object element 
 * depending the attribute type of the child element.
 * 
 * The naming convention to build a node from a specific package type is: wimprt_process_object_TYPE
 * 
 * if no specific fntion found the default fallback function is called: wimprt_process_package.
 *
 * @param $node
 *   The Node that's being build 
 * @param $dom
 *   The DomDocument who is being proceed (A DomElement)
 * @param $log
 *   The log object build recursively in different operation. this could track error in the process and build nodes
 *   
 * @return
 *   the node object that has been build
 */
function wimprt_process_object(&$node,$dom,$log,$type=NULL){
  module_invoke_all('wimprt_process_object',$node,$dom,$log,'before_process');
  if($type==NULL){
    $type=strtolower($dom->getAttribute('type'));
  }
  wimprt_process_object_default($node,$dom,$log);

  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  if(function_exists("wimprt_process_object_$type")){
    call_usr_func("wimprt_process_object_$type",$node,$dom,$log);
  }
  module_invoke_all('wimprt_process_object',$node,$dom,$log,'after_process');
  //@todo: call node_save()
  //node_save($node);
  return $node;
}


function wimprt_process_type(&$node,$dom,$log,$type=NULL){
  module_invoke_all('wimprt_process_type',$node,$dom,$log,'before_process');
  if($type==NULL){
    $type=strtolower($dom->getAttribute('type'));
  }
  wimprt_process_object_default($node,$dom,$log);

  //Posibility of extension with 'hook_wallymport_info' / CTools Plugin
  if(function_exists("wimprt_process_object_$type")){
    call_usr_func("wimprt_process_object_$type",$node,$dom,$log);
  }
  module_invoke_all('wimprt_process_object',$node,$dom,$log,'after_process');
  //@todo: call node_save()
  //node_save($node);
  return $node;
}


function wimprt_process_list(&$node,$dom_node_list,$type,$log){
  
  $array_of_nodes=array();
  module_invoke_all('wimprt_process_list',$array_of_nodes,$dom_node_list,$type,$log,'before_process');
  
  foreach($dom_node_list->childsName as $dom_child){
    $element_name=$dom_child->nodeName;
    if(function_exists("wimprt_process_$type.'_'.$element_name")){
     $array_of_nodes[]= call_usr_func("wimprt_process_$type.'_'.$element_name",$node,$dom,$log);
    }
    else{
     $array_of_nodes[]= call_usr_func("wimprt_process_$type.'_default",$node,$dom,$log);
    }
    
  }
  module_invoke_all('wimprt_process_list',$array_of_nodes,$dom,$type,$log,'after_process');
  
  //@todo: call node_save()
  //node_save($node);
  return $arra_of_nodes;
}



//***************************



function wimprt_process_package_default(&$node,$dom,$log){
  //Beware of namespace colision
  foreach($dom->childNodes as $element){
    
    $name=strtolower($element->nodeName);
    if(function_exists("wimprt_set_field_$name")){
      call_user_func("wimprt_set_field_$name",$node,$element,$log);
    }
    else{
      wimprt_set_field_default($node,$element,$log);
    }

  }
  
}


function wimprt_process_package_articlepackagetype(&$node,$dom,$log){
  //Process atributes
  //..
  wimprt_process_package_default($node,$dom);
}

//***************************

function wimprt_set_field_default(&$node,$dom,$log){
  $name= $dom->nodeName;
  $node->{$name}[0]['value']=$dom->nodeValue;
}


function imprt_set_field_mainstory(&$node,$dom,$log){
  $object=wimport_process_object($node,$dom,$log,'TextObject');
  $node->MainStory['nid'][0]=$object->nid;
}

