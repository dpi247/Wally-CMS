<?php

include_once('wallycontenttypes.features.inc');

/**
 * @defgroup wallycontenttypes Wally main module.
 * @{
   * 
 * In this module we define all wally specific content types & taxonomies
 * Also include all invocation for specific theme hook & theming preprocess
 * functions. 
 */

/**
 *  ImplÃ©mentation du Hook_theme(); 
 */
function wallycontenttypes_theme(&$var) {

  $path = drupal_get_path('module', 'wallycontenttypes');
  $base = array(
    'file' => 'theme.inc',
    'path' => "$path/theme",
  );

 return array(

    'wallyct_photoobject_slider' => $base + array(
    'arguments' => array("nodes" => NULL, "node" => NULL),
    'template' => 'wallyct_photoobject_slider',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),

    'wallyct_mainmenu' => $base + array(
    'arguments' => array("menu" => 'primary-links', "menuid" =>'menu-primary-links' ),
    'template' => 'wallyct_mainmenu',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_rss' => $base + array(
    'arguments' => array("feed" => NULL, "options" => NULL),
    'template' => 'wallyct_rss',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),

    'wallyct_tofacebook' => $base + array(
    'arguments' => array("node" => NULL, "options" => NULL),
    'template' => 'wallyct_tofacebook',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),

    'wallyct_taxotermlist' => $base + array(
    'arguments' => array("tids" => NULL, "node" => NULL, "options" => NULL),
    'template' => 'wallyct_taxotermlist',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),

    'wallyct_taxotermlist_tree' => $base + array(
    'arguments' => array("tids" => NULL, "node" => NULL, "options" => NULL),
    'template' => 'wallyct_taxotermlist_tree',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),

    'wallyct_mainstory' => $base + array(
    'arguments' => array("mainstory" => NULL, "node" => NULL),
    'template' => 'wallyct_mainstory',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
    
    'wallyct_teaser' => $base + array(
    'arguments' => array("text" => NULL, "length" => 200, "node" => NULL),
    'template' => 'wallyct_teaser',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
        
    'wallyct_destinationlist' => $base + array(
    'arguments' => array("destinations" => NULL, "separator" => NULL, "prefix" => NULL, "suffix" => NULL),
    'template' => 'wallyct_destinationlist',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),

    'wallyct_linkedobjects' => $base + array(
    'arguments' => array("linkedobjects" => NULL, "node" => NULL),
    'template' => 'wallyct_linkedobjects',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),

/*
    'wallyct_personslist' => $base + array(
    'arguments' => array("persons" => NULL, "node" => NULL),
    'template' => 'wallyct_personslist',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
*/

/*
    'wallyct_personslist_detail' => $base + array(
    'arguments' => array("persons" => NULL, "node" => NULL),
    'template' => 'wallyct_personslist_detail',
    'preprocess functions' => array('wally_get_tpl_suggestions'),
    ),
*/
    
  ); 
}



/**
 * Implementation of hook_nodeapi().
 */
function wallycontenttypes_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){

 switch ($op) {
    case 'view':
      wallycontenttypes_packagepopulate($node,$op);
      break;
      
      //@todo: move to wallycontenttypes
  case 'update' :
    if($node->type == 'wally_articlepackage' || 
       $node->type == 'wally_gallerypackage' ||
       $node->type == 'wally_pollpackage')
        _wallycontenttypes_addtaxonomywheninserted($node);
		elseif( $node->type == 'wally_textobject' ||
            $node->type == 'wally_audioobject' ||
            $node->type == 'wally_digitalobject' || 
            $node->type == 'wally_photoobject' || 
            $node->type == 'wally_videoobject' ||
            $node->type == 'wally_pollobject')
			       _wallycontenttypes_addtaxonomywhenupdated($node);
            break;
 	}
}


/** 
 * Load related nodes into package object via nodepi - "op view". 
 * 
 * When a Wally specific node is loaded, this hook will load all the extra 
 * nodes from all the node reference fields.
 * 
 * Specific wally fields supported:
 *  
 * - NID (node reference) specific link ( NODE -> NODE ).
 *   - field_mainstory: Load the Mainstory text node. Load extra "types" into mainstory node.
 *   - field_linkedobjects: Load all the linked objects (any type).
 *   - field_embededobjects: Load all the embeded objects (any type).
 * 
 * - TID (Taxonomy field) specific link ( NODE -> TAXONOMY -> NODE ). 
 *   - field_authors: Load the Persons content type for authors.
 *   - field_locations: Load the Location content type for locations.
 *   - field_entities: Load the entity content type for entities.
 *   - field_persons: Load the Persons content type for persons.
 *
 * @param: &$node
 *   The node that will be inspected for node/taxonomy reference
 * @param: $op
 *   Nodeapi operation
 * @param: $a3
 *   3rd argument - depending of $op ( see @link http://api.drupal.org/api/drupal/developer--hooks--core.php/function/hook_nodeapi/6  hook_nodeapi @endlink
 * @param: $a4
 *   4th argument - depending of $op ( see @link http://api.drupal.org/api/drupal/developer--hooks--core.php/function/hook_nodeapi/6  hook_nodeapi @endlink
 * 
 * @return Nothing but modify the $node
 */
function wallycontenttypes_packagepopulate($node,$op){
  wallycontenttypes_fieldNID($node, $op);
  wallycontenttypes_fieldTID($node, $op);
  }

/**
 * Process Node Reference fields in for populate node.
 */
function wallycontenttypes_fieldNID(&$node, $op) {
	foreach ($node as $field=>$value) {
			switch($field) {
				case "field_mainstory":
					$node->field_mainstory_nodes = wallycontenttypes_fieldnodeload($field, $value);
					wallycontenttypes_fieldTID(&$node->field_mainstory_nodes[0]);
					break;
				case "field_linkedobjects":
					$results = wallycontenttypes_fieldnodeload($field, $value);
          foreach ($results as &$result) {
            $result->field_links_list_nodes = wallycontenttypes_fieldnodeload("field_links_list_nodes", $result->field_links_list);
          }
          $node->field_linkedobjects_nodes = $results;
					break;
				case "field_embededobjects":
					$node->field_embededobjects_nodes = wallycontenttypes_fieldnodeload($field, $value);
					break;
			}
	}
	return $node;
}

/**
 * Process Content Taxonomy fields for populate node.
 */
function wallycontenttypes_fieldTID(&$node) {
  	foreach ($node as $field=>$value) {
		switch($field) {
			case "field_authors":
				$node->field_authors_nodes = wallycontenttypes_fieldTIDload($field, $value, "wally_persontype");
				break;
			case "field_locations":	
				$node->field_locations_nodes = wallycontenttypes_fieldTIDload($field, $value, "wally_locationtype");
				break;
			case "field_entities":	
				$node->field_entities_nodes = wallycontenttypes_fieldTIDload($field, $value, "wally_entitytype");
				break;
			case "field_persons":
				$node->field_persons_nodes = wallycontenttypes_fieldTIDload($field, $value, "wally_persontype");
				break;
		}
	}
	return $node;
}

/**
 * Process all taxonomy reference and return an array of node
 */
function wallycontenttypes_fieldTIDload($field, $values, $type) {
	$r = array();
	$tids = array();  
	foreach ($values as $value=>$tid2load) {
		if ($tid2load["value"]) {
			$tids[] = $tid2load["value"]; 
		}
	}
  $results = (count($tids)) ? wallytoolbox_taxonomy_get_nodes($tids, 'or', 0, false, $type) : array(); 
	foreach ($results as $value=>$node2load) {
		if (!($r[$value] = node_load($node2load))) {
			unset($r[$value]); 
		}
	}
	return $r; 
}


/**
 * Process all node reference fields and return array of node
 */
function wallycontenttypes_fieldnodeload($field, $values=null) {
	$r = array(); 
	foreach ($values as $value=>$node2load) {
		if (!($r[$value] = node_load($node2load["nid"]))) { 
			unset($r[$value]); 
		}
	} 
	return $r; 
}


/**
* Add taxonomy term from textobject to articlepackage when textobject is updated
* 
* Packagenode is the node who reference the current node (It can be ArticlePackage, GalleryPackage or PollPackage
* Because we dont want the package node to update its taxonomies fwhen we saved it from
* here, we set a speciel field: "no_taxonomy_update" to TRUE, see _wallycontenttypes_addtaxonomywheninserted(); 
* 
* @param $node
*   Node currently processed(TextObject, AudioObject, DigitalObject,PhotoObject, Videoobject, PollObject)
* 
* @see _wallycontenttypes_addtaxonomywheninserted()
* 
* @return
*   Nothing
*/
function _wallycontenttypes_addtaxonomywhenupdated($node){
 
			$rows =_wallycontenttypes_getpackagesid($node);
			foreach($rows as $row){
				$packagenode=node_load($row['nid']);
        // Because we dont want node-save api to update
        // taxonomies from main object. We set this
        // field to true. 
        $packagenode->no_taxonomy_update = TRUE; 
				$packagenode->taxonomy = $node->taxonomy;
				$packagenode->field_markers = $node->field_markers;
				$packagenode->field_locations = $node->field_locations;
				$packagenode->field_entities = $node->field_entities;
				$packagenode->field_persons = $node->field_persons;
				$packagenode->field_tags = $node->field_tags;
				$packagenode->field_free_tags = $node->field_free_tags;	
				$r = node_save($packagenode);
			}
	}

/**
 * Add taxonomy term of textobject to articlepackage when articlepackage is inserted or updated
 * 
 * objectnode is the node who is referenced by the current node
 * (It can be TextObject, AudioObject, DigitalObject,PhotoObject, Videoobject or PollObject)
 * 
 * Notice: When a mainobject is updated (we also save package node) we set the
 * "no_taxonomy_update field" to TRUE, so we dont want to update taxonomies from
 * the main object node. See _wallycontenttypes_addtaxonomywhenupdated();
 * 
 * @param $node
 *   Node currently processed(ArticlePackage, GalleryPackage or PollPackage)
 *
 * @see _wallycontenttypes_addtaxonomywhenupdated
 * 
 * @return
 *   Nothing
*/
 function _wallycontenttypes_addtaxonomywheninserted(&$node){

      // When a mainobject is updated we set the
      // no_taxonomy_update field to TRUE
      // so we dont want to update taxonomies from
      // the main object node. 
      
      
      if (!$node->no_taxonomy_update) { 

        switch ($node->type){
          case 'wally_articlepackage':
            $objectnode=node_load($node->field_mainstory[0]['nid']);
            break;
          case 'wally_gallerypackage':
            $objectnode=node_load($node->field_mainobject[0]['nid']);
            break;
          case 'wally_pollpackage':
            $objectnode=node_load($node->field_mainpoll[0]['nid']);
            break;
            }

        if($objectnode){
          $node->taxonomy=$objectnode->taxonomy;
          $node->field_markers=$objectnode->field_markers;
          $node->field_locations=$objectnode->field_locations;
          $node->field_entities=$objectnode->field_entities;
          $node->field_persons=$objectnode->field_persons;
          $node->field_tags=$objectnode->field_tags;
          $node->field_free_tags=$objectnode->field_free_tags;
        }
      }
	 }
   
/**
 * Get nid from packages who reference the current node
 * 
 * @param $node
 *   Node currently processed(TextObject, AudioObject, DigitalObject,PhotoObject, Videoobject, PollObject)
 *
 * @return
 *   Array() of array() of nid
 */
function _wallycontenttypes_getpackagesid($node){

  $rows = array(); 
  
  if($node->type=='wally_textobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_articlepackage} WHERE field_mainstory_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  }
  elseif($node->type=='wally_audioobject' || $node->type=='wally_digitalobject' || $node->type=='wally_photoobject' || $node->type=='wally_videoobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_gallerypackage} WHERE field_mainobject_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  }
  elseif($node->type=='wally_pollobject'){
    $res=db_query("SELECT nid FROM {content_type_wally_pollpackage} WHERE field_mainpoll_nid = %d", $node->nid);
    while ($row = db_fetch_array($res)) {
      if (!in_array($row, $rows)) $rows[] = $row;
    }
  }
  return $rows;
}

/*
 * Implementation of hook_ctools_plugin_directory().
 * 
 * It simply tells panels where to find the .inc files that define various
 * args, contexts, content_types. In this case the subdirectories of
 * ctools_plugin_example/panels are used.
 */
function wallycontenttypes_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return "plugins/$plugin";
  }
}

/*
 * Implement hook_ctools_plugin_api().
 * 
 * If you do this, CTools will pick up default panels pages in
 * <modulename>.pages_default.inc
 */
function wallycontenttypes_ctools_plugin_api($module, $api) {
  // @todo this example should explain how to put it in a different file.
  if ($module == 'panels_mini' && $api == 'panels_default') {
    return array('version' => 1);
  }
  if ($module == 'page_manager' && $api == 'pages_default') {
    return array('version' => 1);
  }
}

/**
 *  ImplÃ©mentation du hook_preprocess_page(); 
 */
function wallycontenttypes_preprocess_page(&$variables) {
  $suggestion = array(); 

  // For all Nodes types with a destination field.
  if (isset($variables['node']->field_destinations) && false) {
    $suggestion = wallycontenttypes_getpackagesuggestions(&$variables, 'page'); 
  }
  if(count($suggestion)) $variables['template_files'] = array_merge($suggestion, $variables['template_files']);
} 

/**
 *  ImplÃ©mentation du hook_preprocess_node(); 
 */
function wallycontenttypes_preprocess_node(&$variables) {
  $suggestion = array(); 

  // For all Nodes types with a destination field.
  if (isset($variables['node']->field_destinations[0])) {
    $suggestion = wallycontenttypes_getpackagesuggestions(&$variables, 'node'); 
  }
  if(count($suggestion)) $variables['template_files'] = array_merge($suggestion, $variables['template_files']);
}

/**
 *  ImplÃ©mentation du Hook_form_alter(); 
 */
function wallycontenttypes_form_alter(&$form, $form_state, $form_id){
  if (isset($form['type']) && isset($form['#node'])) {
    switch ($form_id) {
      case "wally_articlepackage_node_form":
      case "wally_gallerypackage_node_form" :
      case "wally_pollpackage_node_form":
        _wallycontenttypes_disabletaxonomy($form, $form_state, $form_id);
      break;
    }
  }
}

/**
 * Disable all taxonomy fields on package editing.
 * 
 * In case of package editing, all taxonomy/entities/persons/locations/...
 * are taken from the main object. So we disabled the edition for these
 * fields.
 * 
 * Because CCK fields didn't suppor the "disabled = true" attribute, and
 * because we must set all sub-element from a cck_field we add
 * an after_build callback function to the form. So all cck fields are
 * completly build.    
 *
 * @param &$form
 *   The form currently build
 * @param $form_state 
 *   A keyed array containing the current state of the form.
 * @param $form_id 
 *   String representing the name of the form itself. Typically this is the name of the function that generated the form.
 *
 * @return
 *   Nothing
 */
function _wallycontenttypes_disabletaxonomy(&$form, $form_state, $form_id){
  $form['#after_build'][] = 'wallycontenttypes_disabletaxonomy_after_build';
}

/**
 * call back to disable all taxonomy fields on package editing
 * 
 * Call back function used by after_build attribute to 
 * disabled all "taxonomy" from a package content types. 
 * 
 * Because CCK fields didn't suppor the "disabled = true" attribute, and
 * because we must set all sub-element from a cck_field we had to put 
 * a disabled attribute to all sub-element of the cck field. 
 * 
 * Because, we're in an after-build process, cck_field could
 * be already relocated to a cck_fieldset. So we have to 
 * seach recursivly for fields.
 *
 * @param &$form
 *   The form currently build
 * @param $form_state 
 *   A keyed array containing the current state of the form.
 *
 * @return
 *   Nothing
 */
function wallycontenttypes_disabletaxonomy_after_build(&$form, &$form_state) {

 $fields = array(   "field_locations",
                    "field_markers",
                    "field_entities",
                    "field_persons",
                    "field_tags",
                    "field_free_tags"
                 );

  foreach ($fields as $field) {
    
    // CCK field on the 1st level of $form
    if (isset($form[$field])) {
      _wallycontenttypes_mysnippetfixdisabled($form[$field]);
    } else {
      // Because we're in afterbuild function, fields could be already
      // relocated into cck fieldsets > $form['fiedset']['cckfield'] 
      foreach (element_children($form) as $k) {
          if (isset($form[$k][$field])) {
            _wallycontenttypes_mysnippetfixdisabled($form[$k][$field]);
          }
      }
    } 
  }
  return($form);
}

/**
* Recursively set the disabled attribute of a CCK field
* and all its dependent FAPI elements. For a content_taxonomy_tree
* cck field, we must disbaled all the childrens: checkboxes or radios.
* 
* @param $element
*   The form element to procedd.
* 
* @return
*   Nothing
*/
function _wallycontenttypes_mysnippetfixdisabled(&$elements) {
  if ($elements["#type"]!="content_taxonomy_tree") {
    foreach (element_children($elements) as $key) {
      if (isset($elements[$key]) && $elements[$key]) {
        _wallycontenttypes_mysnippetfixdisabled($elements[$key]);
      }
    }
    if (!isset($elements['#attributes'])) {
      $elements['#attributes'] = array();
    }
    $elements['#attributes']['disabled'] = 'disabled';
  } else {
    foreach (element_children($elements['value']['#elements']) as $key) {
      _wallycontenttypes_mysnippetdisabledtaxonomytree($elements['value']['#elements'][$key]);
    }
 }
}

/**
 * Recursvly search for each children element of a  content_taxonomy_tree
 * field. To disable all childrens. 
 * 
 * @param $element 
 *   Form element to proceed. Must be a content_taxonomy_tree element.
 *
 * @return
 *   Nothing
 */
function _wallycontenttypes_mysnippetdisabledtaxonomytree(&$elements) {
  foreach (element_children($elements) as $k) {
    $elements[$k]['#attributes']['disabled'] = 'disabled';
    if ($k=='children') {
      foreach (element_children($elements[$k]) as $key) {
        _wallycontenttypes_mysnippetdisabledtaxonomytree($elements[$k][$key]);
      }
    }
  }
 }
 
 /**
 * Build all the page/node suggestions template for a node of type "package"
 * of any content type with Destinations information.   
 *
 *  Wally specific suggestions are (for pages):  
 * 
 *  - page_{destinations_terms_underscore_separated}.tpl.php
 *  - page_{destinations_terms_underscore_separated}_{node_type}.tpl.php
 *  - page_{destinations_terms_underscore_separated}_{node_type}_{package_layout}.tpl.php
 *  - page_{node_type}_{package_layout}.tpl.php
 *  - page_{node_type}.tpl.php
 *  - page.tpl.php
 * 
 *  Wally specific suggestions are (for nodes):  
 * 
 *  - node-{node_type}.tpl.php
 *  - node_{destinations_terms_underscore_separated}.tpl.php
 *  - node_{destinations_terms_underscore_separated}_{node_type}.tpl.php
 *  - node_{destinations_terms_underscore_separated}_{node_type}_{package_layout}.tpl.php
 *  - node_{node_type}_{package_layout}.tpl.php
 *  - node_{node_type}.tpl.php < node.tpl.php
 *
 *  Wally specific suggestions are (other - types):  
 * 
 *  - {type}-{node_type}.tpl.php
 *  - {type}_{destinations_terms_underscore_separated}.tpl.php
 *  - {type}_{destinations_terms_underscore_separated}_{node_type}.tpl.php
 *  - {type}_{destinations_terms_underscore_separated}_{node_type}_{package_layout}.tpl.php
 *  - {type}_{node_type}_{package_layout}.tpl.php
 *  - {type}_{node_type}.tpl.php < node.tpl.php
 * 
 * @param $variables
 *   Templating variables
 * 
 * @param $type
 *   Prefix added to suggestions (default = page). Could be "page" or "node".
 * 
 * @return 
 *   Array of suggestion pages templates.
 */
function wallycontenttypes_getpackagesuggestions(&$variables, $type="page") {

  $destinations = array();
  $suggestion = array(); 
  $tax_children = array(); 
  $vid=variable_get('wallymport_destinationpath',null);
  $path = ""; 
  $package_layout = (isset($variables['node'])) ? wallycontenttypes_getpackagelayout($variables['node']) : NULL ; 

  // For a node, destination is taken on the 1st destination. 
  if (isset($variables['node']->field_testdes[0]['tid'])) {
    $destinations = array($variables['node']->field_testdes[0]['tid']);
  }
 
  (isset($variables['node']->type)) ? $suggestion[] = $type . '_' . strtolower($variables['node']->type) : NULL ;
 
  if ($package_layout) $suggestion[] = $type . '_' . strtolower($variables['node']->type) . '_' . $package_layout;

  if (count($destinations)) {
    $destination = $destinations[0];
    $tax_children = taxonomy_get_parents_all($destination, $vid);
    $count = count($tax_children);
    for ($i = $count-1; $i >= 0; $i--) {
      ($i == $count-1) ? $path .= strtolower($tax_children[$i]->name) : $path .= "_".strtolower($tax_children[$i]->name);
      if ($type) $suggestion[] = $type . '_' . $path;
      if (isset($variables['node']->type)) $suggestion[] = $type . '_' . $path . '_' . strtolower($variables['node']->type);
      if ($package_layout) $suggestion[] = $type . '_' .$path . '_' . strtolower($variables['node']->type) . '_' . $package_layout;
    }
  }
  return $suggestion;  
}

/**
 * Extract page layout information from the node. 
 *
 * @param $node
 *   The node currently processed
 *
 * @return 
 *   The Package layout as a string or NULL.
 */
function wallycontenttypes_getpackagelayout($node) {
  if (isset($node->field_packagelayout)) {
    $package_layout = taxonomy_get_term($node->field_packagelayout[0]["value"]);
    $package_layout = strtolower(trim($package_layout->name));
  } else {
    $package_layout = NULL;
  }
  return $package_layout; 
}




/**
 * @} End of "defgroup wallycontenttypes".
 */
