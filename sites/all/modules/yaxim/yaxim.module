<?php
// $Id: yaxim.module,v 1.00 2010/09/28 16:50:00 rso (Rouslan Sorokine) Exp $

/**
 * @file
 *  Yet Another XML Import Module. User defined Input XML schema and Import definition XML. 
 *	Input file format is ZIP. Only one XML file per ZIP input file is allowed.
 */

//================
//GLOBAL VARIABLES
//================

$defs=array();				// An array corresponding to the table of correspondance between input and Drupal (XML)
$created_nodes=array();		// Import result, for finish hook and report
$temp_subdir = '';			// Temporary directory for unzipped files
$test_level='';				// Test level for debugging

//=============
//DRUPAL HOOKS.
//=============

/**
 * Implementation of hook_help().
 */
function yaxim_help($path, $arg) {
  if ($path == 'admin/help#yaxim') {
    return t('Yet Another XML Import Module. User defined Input XML schema and Import definition XML.');
  }
}

/**
 * Implementation of hook_menu().
 */
function yaxim_menu() {
  $items = array();
  $items['admin/settings/yaxim'] = array(
    'title' => 'Yaxim Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('yaxim_admin'),
    'access arguments' => array('access administration pages'),
    'description' => 'Allows administrators to set paramaters for this module to function properly.',
    'file' => 'yaxim.admin.inc',
  );
  
  // run import
  $items['yaxim/import'] = array(
	'title' => 'Run XML Import Process',
	'description' => 'Run data import',
	'page callback' => '_yaxim_process_import',
	'access arguments' => array('access administration pages'),
	'type' => MENU_CALLBACK,
  );

  return $items;

}


/**
*
* Run import process
*
*/

function _yaxim_process_import()
{
  global $temp_subdir;
  global $created_nodes;
  global $defs;
  global $test_level;
  
  $test_level=variable_get('yaxim_debug', 0);								// 0=No debug; 1=Verbose; 2=No data written
  $temp=variable_get('yaxim_temp', file_directory_temp());					// temporary directory to unzip files
  $path=variable_get('yaxim_source', 'sites/default/files');				// import directory where zipped input files are received
  $format='zip';															// input file extension
  $files = drupal_system_listing('.*\.'. $format .'$', $path, 'name', 0);	// get list of all *.zip files
  if (count($files)==0) {
	return t('No input files found');
  }
  ksort($files);															// sort files by name

  $path = drupal_get_path('module', 'yaxim');
  $xmlschema = variable_get('yaxim_definition', $path.'/definitions/yaxim.input.xsd');
  require_once($path.'/libraries/minixml/minixml.inc.php');
  $defs=_yaxim_definitions();

  // For every input zip file

  foreach ($files as $file) {

	// Unzip input file to the temp directory
	$zip = new ZipArchive;
	$res = $zip->open($file->filename);
	if ($res === TRUE) {
	  // Create a subdirectory in the temp directory
	  $temp_subdir=$temp.'/'.$file->name;
	  if (!is_dir($temp_subdir))		// if subdirectory doesn't already exist
		$res=mkdir($temp_subdir,0775);	// then create it
	  if (is_dir($temp_subdir)) {
		$zip->extractTo($temp_subdir);	// extract all the files
		$import_files = drupal_system_listing('.*\.xml$', $temp_subdir, 'name', 0);	// get list of all *.xml files
		if (count($import_files)==0) {
		  $output.= t('No XML file found in the import %import.',array('%import' => $file->basename))."<br />\n";
		  continue;
		}
		elseif (count($import_files)>1) {
		  $output.= t('There is more than one XML file found in the import %import.',array('%import' => $file->basename))."<br />\n";
		  continue;
		}
		else {
		  $import_file=reset($import_files);
		  $xml_file=$import_file->filename;
		}
		$zip->close();
	  } else {
		  $output.= t('Temporary directory %dir could not be created or accessed.',array('%dir' => $temp_subdir))."<br />\n";
		  continue;
		}
	} else {
      $output.= t('Input file %filename could not be unzipped to %dir. Error code %error',
		array('%filename' => $file->filename, '%dir' => $temp_subdir, '%error' => $res))."<br />\n";
	  continue;
	}

	$xdoc = new DomDocument;
	$xml_doc = new MiniXMLDoc();
	
	$output.= 'processing <em>'.$xml_file.'</em>... ';
	
	//Load the xml document in the DOMDocument object
	if ($xdoc->Load($xml_file)) {
	  $xml_version=$xdoc->xmlVersion;
	
	  //Validate the XML file against the schema (if it exists)
	  if ($xmlschema=='' || $xdoc->schemaValidate($xmlschema)) {
		$output.= "is <b>valid</b>";
		
		$xml_source=$xdoc->saveXML();
		
		// Hook import on load, to let other modules to modify each XML source before it is imported:
		module_invoke_all('yaxim', 'load', &$xml_source);
		$xdoc->loadXML($xml_source);

		// Translate XML into a structured array
		$xml_doc->fromString($xml_source);
		$import = $xml_doc->toArray();
		
		//var_dump($import);

		// Import packages from the array
		$result = _yaxim_process_structure(&$import);
		$output.= " : ".count($result)." packages processed<br />\n";
	  }
	  else {
		$output.= "is <b>invalid</b> in regard of the XML schema file <em>$xmlschema</em><br />\n";
	  }
	}
	else
	  $output .= 'could not be loaded or is an <b>invalid</b> XML file.<br />';
  }

  // Hook import on finish (of all input files), to let other modules to work on created nodes, taxonomy, files:
  module_invoke_all('yaxim', 'finish', &$created_nodes);
  
  // Print out report of created nodes
  $output .= '<br />';
  foreach($created_nodes as $created_node) {
	$output.=t('Node "%title" (%content_type) created or updated. Edit : ',
				array(
					'%title' => $created_node->title, 
					'%content_type' => $created_node->type
					)).l('node/'.$created_node->nid.'/edit','node/'.$created_node->nid.'/edit').'<br />';
  }

  $output.='<br />Import ended.<br />';

  return $output;
}


/**
*
* Import one element into Drupal
*
*	Process a data structure corresponding to one element of the tree
*
*		Input:	$element - An array corresponding to the input data (XML)
*				$def     - Structure name within $defs - optional
*
*				 A corresponding Drupal structure will be created (one or more Drupal nodes), and fields filled in:
*		Return:
*				 Node id of the created node
*			or
*				 Value of the field
*			or
*				 An array of values
*
*/

function _yaxim_process_structure(&$element,$parent_type='',$def=NULL) {

  global $created_nodes;
  global $defs;
  global $test_level;
  
  // if structure name is not provided, get a default name from the element
  if (!$def) {
	$def=array_keys($element);
	$def=$def[0];
  }
  $def_name=$def;							// e.g. 'Package'
  // check if the element has a variant, e.g. 'ArticlePackageType' is based off 'Package'
  if (isset($element['_attributes']['xsd:type'])) {
    $def_name = $element['_attributes']['xsd:type'];
	if ($test_level>0)
		echo "<!-- Processing variant $def_name -->\n";
  }
  //TODO: REMOVE FROM YAXIM=> xsi is a CCI concept
  elseif (isset($element['_attributes']['xsi:type'])) {
	$def_name = $element['_attributes']['xsi:type'];
	if ($test_level>0)
		echo "<!-- Processing variant $def_name -->\n";
  }
  
  $def=$defs[$def_name];
  $def_type=$def['type'];					// list, node, field, fields

  if ($test_level>0)
	echo "<!-- Processing element $def_name ( $def_type ) -->\n";

  // ======== Process a list of sub-elements. Recursive call
  if ($def_type=='list') {
    $subdef_name=$def['def'];						// subtype, e.g. 'Package'
	$subdef=$def[$subdef_name];						// definition of 'Package'
	$subelements=reset($element);					// go down one level to 'Package'
	$subelements=reset($subelements);				// go down another level, to the array inside 'Package'

	// Make an array out of the $subelement if it is not already the case, to simplify further processing (foreach)
	if (is_string($subelements) || !isset($subelements['_num'])) {
	  $subelements=array(0 => $subelements);
	}
	unset($subelements['_num']);
	
	foreach ($subelements as $subelement) {
	  $result=_yaxim_process_structure($subelement,$def_type,$subdef_name);
	  // a callback
	  if (isset($def['callback']))
		$result=call_user_func($def['callback'], $result);
	  
	  // a list of keyed values
	  if (isset($def['array']))
		$result_list[]= array($def['array'] => $result);
	  else
	  // a regular list
		$result_list[]= $result;
	}
	return $result_list;	// an array of values
  }

 
  // ======== Process sub-elements (fields) of different types. Recursive call
  if ($def_type=='fields') {
	$def_fields=$def['fields'];
	foreach ($def_fields as $def_field_name => $def_field) {
	  
	  $key=$def_field['content_type'];
	  $subdef=$def_field['def'];
	  $subelement=array($def_field_name => $element[$def_field_name]);
	  $result[$key]=_yaxim_process_structure($subelement,$def_type,$subdef);
	}
	return $result;	// an array of values
  }

  // ======== Process a field (def, node, field, fields)
  $def_fields=$def['fields'];

  // Move all the attributes from ['_attributes'] subarray to a regular fields place in the array
  if (is_array($element['_attributes'])) {
	foreach($element['_attributes'] as $attr_field => $attr_value) {
	  $element[$attr_field]=$attr_value;
	}
  }

  // Is this element a node?
  if ($def_type=='node') {
	// Load an existing node or get a new one from scratch
	$def_dbkey=$def_fields[$def['dbkey']]['content_type'];	// the name of the field which holds a unique key
	if (isset($def_fields[$def['dbkey']]['vocabulary']))
	  $def_vocab=$def_fields[$def['dbkey']]['vocabulary'];
	else
	  $def_vocab='';
	$node=_yaxim_get_node($def_dbkey,$element[$def['dbkey']],$def_vocab);
	$node->type = $def['content_type'];
  }
  
  // Just in case we have a comment inserted anywhere in input XML
  if (!is_array($element)) {
	return $element;
}  
  $result_fields=array();
  // Process all the fields of the element.
  foreach ($element as $field => $value) {
	  
	  // If the field is defined, process it
	  if (isset($def_fields[$field])) {
		$field_name=$def_fields[$field]['content_type'];
		$field_type=$def_fields[$field]['type'];
		if (isset($def_fields[$field]['callback']))
		  $field_call=$def_fields[$field]['callback'];
		else
		  $field_call=NULL;

		if ($test_level>0)
			echo "  <!-- Processing field ".$def_fields[$field]['name']." ( $field_type ) -->\n";

		// Value of a field may be an array with [_attributes] and [_content]
		if (is_array($value) && isset($value['_content'])) {
			$value=$value['_content'];
		}
		
		//TODO: Rebuild this crappy logic with callBack!!!
		
		// If there is an Internal callback on the field and no User callback, use it
		if (!$field_call && substr($field_type,0,5)=='field' && substr($field_type,5,1)!='s') {
		  if (substr($field_type,5) != '') {
		    $field_call=str_word_count($field_type,1);
			$field_call='_yaxim_'.$field_call[1];	// internal callback
		  }
		  $field_type='field';	// get rid of callback info
		}
		// If there is an Internal or User callback function on the field, call it
		if ($field_call) {
		  if (isset($def_fields[$field]['parameters']))
			$value=call_user_func($field_call, $value, $element, $def_fields[$field]['parameters']);
		  elseif (substr($field_call,0,1) == '_')	// user defined function
			$value=call_user_func($field_call, $value, $element);
		  else										// standard PHP or Drupal function
			$value=call_user_func($field_call, $value);
		}


		// the field is an array
		if (isset($def_fields[$field]['array'])) {
		  $value=array($def_fields[$field]['array'] => $value);		// e.g. array('value' => 27)
		}
			
		// the field is a list
		if (isset($def_fields[$field]['list'])) {
		  //$value=array(0 => $value);	
		  							// e.g. array(0 => value)
		}

		// the field is of a simple type: 'field'
		if ($field_type=='field') {
		  echo 'field2Sec';
		  $result=$value;
          if ($def_type=='node'){
		    $node->{$field_name}=$result;
		  }
		}
		// the field is a taxonomy: 'taxonomy'
		if ($field_type=='taxonomy') {
		  $vocabulary=$def_fields[$field]['vocabulary'];
		  $result=_yaxim_field_taxonomy($value,$vocabulary);
		  if ($def_type=='node')
		    $node->{$field_name}=$result;
		}
		// the field is a file: 'file', 'file_image', ...
		elseif (substr($field_type,0,4)=='file') {
		  switch ($field_type) {
			// the field is any file
			case 'file':
			  $result=_yaxim_create_file($value);
			  break;
			// the field is an image file
			case 'file_image':
			  $result=_yaxim_create_file_image($value,$element['Title']);	// Get title from parent object
			  break;
		  }
		  $result=array(0 => $result);
		  if ($def_type=='node')
		    $node->{$field_name}=$result;
		}
		// the field is a node reference: 'node'
		elseif ($field_type=='node') {
		  $newdef=$def_fields[$field]['def'];
		  $result=_yaxim_process_structure($value,$def_type,$newdef);
		  if ($def_type=='node')
			$node->{$field_name}[0]['nid']=$result;
		}
		// the field is defined separately. Process it with the new definition: 'def'
		elseif ($field_type=='def') {
		  $newdef=$def_fields[$field]['def'];
		  $value=array($field => $value);	// Recreate the element
		  $result=_yaxim_process_structure($value,$def_type,$newdef);
		  if ($def_type=='node')
			$node->{$field_name}=$result;
		}
		// the field is a list of fields defined separately: 'fields'
		elseif ($field_type=='fields') {
		      echo'dim_fields2';
		  
		  $newdef=$def_fields[$field]['def'];
		  $result=_yaxim_process_structure($value,$def_type,$newdef);	// a keyed array is returned
		  // update each field with its value
		  if ($def_type=='node')
			foreach ($result as $field_name => $value) {
			  $node->{$field_name}=$value;
			}
		}
		
	  }
	if(isset($result))  
      if (is_array($result)){
	  $result_fields=array_merge($result_fields,$result);
      }
	elseif ($field != '_attributes' && isset($def_fields[$field]) && $def_fields[$field]['single'] != 'true') {
	  $result_fields=array_merge($result_fields,array(0 => $result));
	}	  
  }
  
  if (count($result_fields) > 0) { 
	$result=$result_fields;
  }
  
  if ($def_type=='node') {
	// Create or Save node
	global $user;
	$node->uid=$user->uid;
	global $test_level;
	if ($test_level>1)					// Debug Level 2: Don't create node
		$node->nid=rand(1000,2000);
	else
		node_save($node);

	if ($test_level>0) {
		echo '<!-- ======== created node='; print_r($node); echo " -->\n";
	}
	  
	$result=$node->nid;
	$created_nodes[]=$node;
  }
  
  return $result;
}

/**
*
* Load the Correspondence table between the input data and drupal data sctructure
*
*	This description will be used to process drupal fields corresponding to the input XML structure
*
*		Return: Array describing what to do with each field of each node type
*
*/
function _yaxim_definitions() {
  $path = drupal_get_path('module', 'yaxim');
  $xml_file=variable_get('yaxim_correspondence', $path.'/definitions/yaxim.defs.xml');
  $xml_doc = new MiniXMLDoc();
  //Load the xml definition file and translate into a structured array
  $xml_doc->fromFile($xml_file);
  $defs0 = $xml_doc->toArray();
  $defs0 = $defs0['definitions']['definition'];
  foreach ($defs0 as $def) {
    if (!isset($def['_attributes']))
	  continue;
    $dname=$def['_attributes']['name'];
	foreach($def['_attributes'] as $dkey => $dfield) {
	  $def[$dkey] = $dfield;
	}
	unset($def['_attributes']);
	if (is_array($def['fields'])) {
	  $fields0=$def['fields']['field'];
	  if (!isset($fields0['_num'])) {
		$fields0=array(0 => $fields0);
	  }
	  unset($fields0['_num']);
	  foreach($fields0 as $field) {
		$fname=$field['_attributes']['name'];
		foreach($field['_attributes'] as $fkey => $ffield) {
		  $field[$fkey] = $ffield;
		}
		unset($field['_attributes']);
		$def['fields'][$fname]=$field;
	  }
	  unset($def['fields']['field']);
	}
    $defs[$dname]=$def;
  }
  
  // expand extended definitions: copy type and missing fields from base definition (e.g. Package -> ArticlePackageType)
  foreach ($defs as $key => $def) {
	if ($def['type']=='extend') {
	  $base_def=$defs[$def['base']];
	  $def['type']=$base_def['type'];
	  $def['fields']=array_merge($def['fields'],$base_def['fields']);
	  $def['dbkey']=$base_def['dbkey'];
	  $defs[$key]=$def;
	}
  }
  
  return $defs;
}


/* =========== INTERNAL CALLBACK FUNCTIONS ============ */

/**
*
* Translates "comments allowed" setting to Drupal
*
*		Input:	- Disabled | Read Only | Read-Write
*		Return:
*				- 0 | 1 | 2
*
*/
function _yaxim_comment($comment,$element=NULL) {
  $comment_settings=array('Disabled', 'Read Only', 'Read-Write');
  return array_search($comment,$comment_settings);
}

/**
*
* Translates datetime into Drupal datetime field
*
*		Input:	- ISO Datetime (e.g. '2010-10-26T21:32:52')
*				- Processed element (not used)
*		Return:
*				- Unix time
*
*/
function _yaxim_time($date,$element=NULL) {
  $result=strtotime($date);
  return $result;
}

/**
*
* Translates datetime into CCK datetime field
*
*		Input:	- ISO Datetime (e.g. '2010-10-26T21:32:52')
*				- Processed element (not used)
*		Return:
*				- CCK datetime field (array)
*
*/
function _yaxim_ccktime($date,$element=NULL) {
  $result['value']=str_replace('T', ' ', $date);
  $result['timezone']=variable_get('date_default_timezone_name', 'UTC');
  $result['timezone_db']='UTC';
  $result['date_type']='datetime';
  return $result;
}

/**
*
* Translates taxonomy term name into term id number
*
*		Input:	- Term name(s) (e.g. 'web')
*				- Vocabulary variable name id (e.g. yaxim_taxonomy_channel)
*				- Processed element (not used)
*		Return:
*				- Term id (e.g. 26 which corresponds to 'web'). If it didn't exist, it will be added to the vocabulary
*
*/
function _yaxim_taxonomy($term,$element,$vocabulary) {
  if (!is_array($term))
	$term=array(0 => $term);
  $result=_yaxim_field_taxonomy($term,$vocabulary['parameter']);
  $result=reset($result);
  $tid=$result->tid;
  return $tid;
}


/* =========== HELPER FUNCTIONS ============ */
/**
*
* Find a node with a unique key
*
*		Input:	- Field name (e.g. ExternalReference)
*				- Key (field's value)
*				- Vocabulary var name (needed only when field name = "taxonomy")
*		Return:
*				- Existing Node if found; A new node otherwise
*
*/
function _yaxim_get_node($field_name,$field_value,$vocabulary) {
  global $test_level;
  if ($test_level>0)
	echo '<!-- '.__FUNCTION__."($field_name,$field_value,$vocabulary) -->\n";
  if (empty($field_value)) {
	drupal_set_message("Field ($field_name) value empty in function ".__FUNCTION_.". Check your input or definition file",'error');
	return NULL;
  }
  if ($field_name=="taxonomy") {
	$vid=variable_get($vocabulary, 0);
	$terms=taxonomy_get_term_by_name($field_value);

	// find the first term which corresponds to the given vocabulary
	foreach ($terms as $term) {
	  if ($term->vid==$vid) {
		$result=$term;		// term found, get it
		break;
	  }
	}
	// term not found, create a new node
	if (!isset($result)) {
	  $node = new stdClass();
	}
	// term found, find the matching node
	else {
	  $nids=yaxim_taxonomy_get_node_by_term_and_vocabulary($result->tid, $vid);
	  // no matching nodes found, create a new node
	  if (count($nids)==0) {
		$node = new stdClass();
	  }
	  // take the first matching node
	  else {
		$node=node_load($nids[0]);
	  }
	}
	return $node;
  }

  // Else the field is not a taxonomy, just a text key
$sql="
SELECT node.nid AS nid
 FROM {node} node 
 LEFT JOIN {content_".$field_name."} node_data_".$field_name." ON node.vid = node_data_".$field_name.".vid
 WHERE (node_data_".$field_name.".".$field_name."_value = '%s')
";
  $result = db_query($sql, $field_value);
  $node=db_fetch_object($result);		// we can do this because we know there is only one node if it exists
  // the node exists, load now the node using the nid
  if ($node)
	$node=node_load($node->nid);
  // or create a new one
  else
	$node = new stdClass();
  return $node;
}


/**
*
* Create an image file
*
*		Input:	- File URI, e.g. 'ObjectID:123456'
*		Return:
*				- An array corresponding to a file's field, e.g.:
*		array(
*			'fid' => 12
*			'list' => 1
*			'data' => array(
*				'alt' => ''
*				'title' => '')
*			'uid' => 1
*			'filename' => 'cherry.jpg'
*			'filepath' => 'sites/default/files/photos/cherry.jpg'
*			'filemime' => 'image/jpeg'
*			'filesize' => 164442
*			'status' => 1
*			'timestamp' => 1284386074)
*	or FALSE if the file is invalid
*/
function _yaxim_create_file_image($file_uri,$title='',$alt='') {
  // Create file
  $file=_yaxim_create_file($file_uri,'photos');

  // if the file has been created AND it is an image
  if (is_array($file) && image_get_info($file['filepath'])) {
	if ($alt=='') $alt=$title;		// if ALT is not provided, make it equal to TITLE
	// Add ALT and TITLE
	$file['data']=array('alt' => $alt, 'title' => $title);
  }

  return $file;
}


/**
*
* Create a file
*
*		Input:	- File URI, e.g. 'ObjectID:123456'
*				- Destination type ('', 'photos', ...)
*		Return:
*				- An array corresponding to a file's field, e.g.:
*		array(
*			'fid' => 12
*			'uid' => 1
*			'filename' => 'cherry.jpg'
*			'filepath' => 'sites/default/files/photos/cherry.jpg'
*			'filemime' => 'image/jpeg'
*			'filesize' => 164442
*			'status' => 1
*			'timestamp' => 1284386074)
*	or FALSE if failed for any reason
*/
function _yaxim_create_file($file_uri,$dest_type='') {
  global $temp_subdir;	// directory where input files of an input zip file are unzipped
  $file=FALSE;
  list($file_verb,$file_name)=explode(':',$file_uri);
  $file_verb=strtolower($file_verb);		// 'filename', ...
  
  // If the file is stored in the import directory
  if ($file_verb=='filename') {
	$filepath=$temp_subdir.'/'.$file_name;
  }
  if (isset($filepath)) {
	if (!is_file($filepath))
	  return FALSE;
	// Calculate destination path
	$destination=file_directory_path();		// 'sites/default/files'. Function doesn't exist in D7
	if ($dest_type != '') {
	  $destination .= '/'.$dest_type;		// e.g. 'sites/default/files/photos'
	}
	// Move file to the destination directory
	$file=_yaxim_file_copy($filepath,$destination);	// may return FALSE if failed
  }

  if (is_object($file))
	$file=get_object_vars($file);		// transform the $file object into an array

  return $file;
}


/**
 * Copies a file to a new location. Adapted from Drupal standard function file_move()
 *
 * @param $source
 *   A string specifying the file location of the original file
 * @param $dest
 *   A string containing the directory $source should be copied to.
 *   Replace behavior when the destination file already exists.
 *   - FILE_EXISTS_RENAME: Append _{incrementing number} until the filename is
 *     unique.
 * @return
 *   File object if success, 0 for failure.
 */

function _yaxim_file_copy($source, $dest) {
	global $user;

    // Build the list of non-munged extensions.
    $extensions = '';
    foreach ($user->roles as $rid => $name) {
      $extensions .= ' '. variable_get("upload_extensions_$rid",
      variable_get('upload_extensions_default', 'jpg jpeg gif png txt html doc xls pdf ppt pps odt ods odp'));
    }

    // If the destination is not writable, issue an error message
    if (file_check_path($dest) === FALSE) {
      form_set_error($dest, t('File move error. Destination directory is not writable.'));
      watchdog('file', 'Move error. Could not move imported file to destination %destination directory.', array('%destination' => $dest));
      return 0;
    }

    // Begin building file object.
    $file = new stdClass();
    $file->filename = file_munge_filename(trim(basename($source), '.'), $extensions);
    $file->filepath = $source;
    $file->filemime = file_get_mimetype($file->filename);
    $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), FILE_EXISTS_RENAME);
    $file->filesize = filesize($source);



    // Rename potentially executable files, to help prevent exploits.
    if (preg_match('/\.(php|pl|py|cgi|asp|js)$/i', $file->filename) && (substr($file->filename, -4) != '.txt')) {
      $file->filemime = 'text/plain';
      $file->filepath .= '.txt';
      $file->filename .= '.txt';
      // As the file may be named example.php.txt, we need to munge again to
      // convert to example.php_.txt, then create the correct destination.
      $file->filename = file_munge_filename($file->filename, $extensions);
      $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), FILE_EXISTS_RENAME);
    }

	// Copy file
	if (!file_copy($file,$file->destination)) {	//D7: difference
      form_set_error($source, t('File move error. Could not move imported file.'));
      watchdog('file', 'Move error. Could not move imported file %file to destination %destination.', array('%file' => $file->filename, '%destination' => $file->filepath));
      return 0;
    }

    // If we made it this far it's safe to record this file in the database.
    $file->uid = $user->uid;
    $file->status = FILE_STATUS_PERMANENT;
    $file->timestamp = time();
	unset($file->destination);
	global $test_level;
	if ($test_level>1) {		// Debug Level 2: Don't create file
		$file->fid=rand(10,99);
		return $file;
	}
    if (drupal_write_record('files', $file)===FALSE) {
      form_set_error($source, t('File create error. Could not create a file record.'));
      watchdog('file', 'File error. Could not create file %file.', array('%file' => $file->filename));
      return 0;
    }

    return $file;
}


/**
*
* Translates taxonomy term names into a taxonomy field. Creates the term or vocabulary if needed
*
*		Input:	- Array of Term names, e.g. Array (0 => 'Paris', 1 = 'London')
*				- Vocabulary variable name, e.g. 'yaxim_taxonomy_location'
*				- A parent term (optional) within the vocabulary
*				- Vocabulary id (NULL if must be found from the variable $vocabulary)
*		Return:
*				- Taxonomy field, e.g.:
*			Array(
*				28 => Object(
*					tid => 28
*					vid => 48
*					name => Paris
*					description => Capitale de la France
*					weight => 0
*					)
*				)
*		or	FALSE if the input vocabulary variable is not defined
*/
function _yaxim_field_taxonomy($term_names,$vocabulary,$parent='',$vid=NULL) {
  if ($vid==NULL)
	$vid=variable_get($vocabulary, 0);
  if ($vid==0)
    return FALSE;	// vocabulary not found
	
  // For each term name in the input list:
  foreach($term_names as $term_name) {
	// get an array of matching terms
	$terms=taxonomy_get_term_by_name($term_name);

	// find the first term which corresponds to the given vocabulary
	if (isset($result)) unset($result);
	foreach ($terms as $term) {
	  if ($term->vid==$vid) {
		$result=$term;		// term found, get it
		break;
	  }
	}
	// term not found, create and insert the term into vocabulary
	if (!isset($result)) {
	  $result=array(
		'name' => $term_name,
		'vid' => $vid,
		'description' => '',
		'weight' => 0,
	  );
	  if ($parent != '') {
		$parent_terms=taxonomy_get_term_by_name($parent);
		$parent_tid=NULL;
		foreach ($parent_terms as $parent_term) {
		  if ($parent_term->vid==$vid) {
			$parent_tid=$parent_term->tid;		// term found, get its tid
			break;
		  }
		}
		// if the parent doesn't exist, create it
		if (empty($parent_tid)) {
		  $new_parent=_yaxim_field_taxonomy(array(0 => $parent),$vocabulary);	// recursive call
		  $new_parent=reset($new_parent);
		  $parent_tid=$new_parent->tid;
		}
		$result['parent']=array(0 => $parent_tid);
	  }
	  // insert the term
	  $status=taxonomy_save_term($result);
	}
	
	// compile all the results in an array where the key is tid
	if (isset($result))
	  $results[$result->tid]=(object)$result;
  }
  return $results;	// return the terms
}


/**
*
* Finds the node ids of nodes having that taxonomy
*
*		Input:	- Term id
*				- Vocabulary id
*		Return:
*				- Array of node ids
*/
function yaxim_taxonomy_get_node_by_term_and_vocabulary($tid, $vid) {
  $result=taxonomy_select_nodes(array($tid));	// find nodes matching the taxonomy term
  while ($node = db_fetch_object($result)) {
    $nids[] = $node->nid;
  }
  return $nids;
}

